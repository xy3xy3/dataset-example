input,output
"# Context:
Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.

# Question:
If the lentils are added last, then which one of the following must be true?

# Options:
A) At least one of the foods is added at some time before the zucchini.
B) At least two of the foods are added at some time before the kale.
C) The mushrooms are added third.
D) The zucchini is added third.
E) The tomatoes are added fourth.","# Declarations
foods = EnumSort([kale, lentils, mushrooms, onions, tomatoes, zucchini])
order = Function([foods] -> [int])
# Constraints
ForAll([f:foods], And(order(f) <= 6, order(f) >= 1)) ::: **Implied Information**: The order is defined between 1 and 6.
ForAll([f1:foods, f2:foods], Implies(f1 != f2, order(f1) != order(f2))) ::: **Implied Information**: All food items have different positions.
Implies(order(mushrooms) == 3, order(lentils) == 6) ::: If the mushrooms are added third, then the lentils are added last
Implies(order(zucchini) == 1, order(lentils) < order(onions)) ::: If the zucchini is added first, then the lentils are added at some time before the onions
And(order(tomatoes) != 5, order(kale) != 5) ::: Neither the tomatoes nor the kale is added fifth
Exists([f:foods], And(Or(order(mushrooms) < order(tomatoes), order(mushrooms) < order(kale)), Not(And(order(mushrooms) < order(tomatoes), order(mushrooms) < order(kale))))) ::: The mushrooms are added at some time before the tomatoes or the kale, but not before both
order(lentils) == 6 ::: If the lentils are added last
# Options
is_valid(Exists([f:foods], order(f) < order(zucchini))) ::: (A)
is_valid(Count([f:foods], order(f) < order(kale)) >= 2) ::: (B)
is_valid(order(mushrooms) == 3) ::: (C)
is_valid(order(zucchini) == 3) ::: (D)
is_valid(order(tomatoes) == 4) ::: (E)"
"# Context:
Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.

# Question:
If Sara was born before Zoe was born, then which one of the following statements CANNOT be true?

# Options:
A) Will is left-handed.
B) Zoe is left-handed.
C) Theo was born after Will was born.
D) Uma was born after Zoe was born.
E) No child was born in 1990.","# Declarations
children = EnumSort([Sara, Theo, Uma, Will, Zoe])
handedness = EnumSort([left, right])
years = EnumSort([1990, 1991, 1992, 1993, 1994, 1995, 1996])
handed = Function([children] -> [handedness])
born_in = Function([children] -> [years])
# Constraints
Count([c:children], handed(c) == left) == 3 ::: three are left-handed
Count([c:children], handed(c) == right) == 2 ::: two are right-handed
ForAll([c1:children, c2:children], Implies(And(handed(c1) == left, handed(c2) == left, c1 != c2), Abs(born_in(c1) - born_in(c2)) != 1)) ::: No two left-handed children were born in consecutive years
ForAll([c1:children, c2:children], Implies(And(handed(c1) == right, handed(c2) == right, c1 != c2), Abs(born_in(c1) - born_in(c2)) != 1)) ::: No two right-handed children were born in consecutive years
born_in(Sara) < born_in(Uma) ::: Sara, who is left-handed, was born before Uma
born_in(Zoe) < born_in(Theo) ::: Zoe was born before Theo
born_in(Zoe) < born_in(Will) ::: Zoe was born before Will
Exists([c:children], And(handed(c) == left, born_in(c) == 1991)) ::: A left-handed child was born in 1991
born_in(Uma) == 1993 ::: Uma, who is right-handed, was born in 1993
handed(Sara) == left ::: Sara is left-handed
handed(Uma) == right ::: Uma is right-handed
born_in(Sara) < born_in(Zoe) ::: If Sara was born before Zoe was born
# Options
is_unsat(handed(Will) == left) ::: (A)
is_unsat(handed(Zoe) == left) ::: (B)
is_unsat(born_in(Theo) > born_in(Will)) ::: (C)
is_unsat(born_in(Uma) > born_in(Zoe)) ::: (D)
is_unsat(ForAll([c:children], born_in(c) != 1990)) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
Which one of the following is a pair of cities that CANNOT be connected?

# Options:
A) Honolulu and Montreal
B) Honolulu and Philadelphia
C) Montreal and Philadelphia
D) Montreal and Vancouver
E) Philadelphia and Toronto","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
# Options
is_unsat(And(connected(Honolulu, Montreal), ForAll([c:cities], Implies(c != Montreal, Not(connected(Honolulu, c)))))) ::: (A)
is_unsat(And(connected(Honolulu, Philadelphia), ForAll([c:cities], Implies(c != Philadelphia, Not(connected(Honolulu, c)))))) ::: (B)
is_unsat(And(connected(Montreal, Philadelphia), ForAll([c:cities], Implies(c != Philadelphia, Not(connected(Montreal, c)))))) ::: (C)
is_unsat(And(connected(Montreal, Vancouver), ForAll([c:cities], Implies(c != Vancouver, Not(connected(Montreal, c)))))) ::: (D)
is_unsat(And(connected(Philadelphia, Toronto), ForAll([c:cities], Implies(c != Toronto, Not(connected(Philadelphia, c)))))) ::: (E)"
"# Context:
Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.

# Question:
Which one of the following must be false?

# Options:
A) None of the children was born in 1990, nor was a child born in 1992.
B) None of the children was born in 1992, nor was a child born in 1995.
C) None of the children was born in 1994, nor was a child born in 1996.
D) One of the children was born in 1990, and another in 1993.
E) One of the children was born in 1993, and another in 1995.","# Declarations
children = EnumSort([Sara, Theo, Uma, Will, Zoe])
hand_types = EnumSort([left_handed, right_handed])
years = EnumSort([1990, 1991, 1992, 1993, 1994, 1995, 1996])
handedness = Function([children] -> [hand_types])
birth_year = Function([children] -> [years])
# Constraints
Count([c:children], handedness(c) == left_handed) == 3 ::: three are left-handed
Count([c:children], handedness(c) == right_handed) == 2 ::: two are right-handed
ForAll([c1:children, c2:children], Implies(And(handedness(c1) == left_handed, handedness(c2) == left_handed, c1 != c2), Abs(birth_year(c1) - birth_year(c2)) != 1)) ::: No two left-handed children were born in consecutive years
ForAll([c1:children, c2:children], Implies(And(handedness(c1) == right_handed, handedness(c2) == right_handed, c1 != c2), Abs(birth_year(c1) - birth_year(c2)) != 1)) ::: No two right-handed children were born in consecutive years
birth_year(Sara) < birth_year(Uma) ::: Sara, who is left-handed, was born before Uma
birth_year(Zoe) < birth_year(Theo) ::: Zoe was born before both Theo and Will
birth_year(Zoe) < birth_year(Will) ::: Zoe was born before both Theo and Will
Exists([c:children], And(handedness(c) == left_handed, birth_year(c) == 1991)) ::: A left-handed child was born in 1991
birth_year(Uma) == 1993 ::: Uma, who is right-handed, was born in 1993
handedness(Uma) == right_handed ::: Uma, who is right-handed, was born in 1993
# Options
is_unsat(And(ForAll([c:children], birth_year(c) != 1990), ForAll([c:children], birth_year(c) != 1992))) ::: (A)
is_unsat(And(ForAll([c:children], birth_year(c) != 1992), ForAll([c:children], birth_year(c) != 1995))) ::: (B)
is_unsat(And(ForAll([c:children], birth_year(c) != 1994), ForAll([c:children], birth_year(c) != 1996))) ::: (C)
is_unsat(And(Exists([c:children], birth_year(c) == 1990), Exists([c:children], birth_year(c) == 1993))) ::: (D)
is_unsat(And(Exists([c:children], birth_year(c) == 1993), Exists([c:children], birth_year(c) == 1995))) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
If exactly three cities are each connected with Philadelphia, then which one of the following could be a pair of connected cities?

# Options:
A) Honolulu and Montreal
B) Honolulu and Vancouver
C) Montreal and Toronto
D) Montreal and Vancouver
E) Philadelphia and Vancouver","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
Count([c:cities], connected(Philadelphia, c)) == 3 ::: Exactly three cities are each connected with Philadelphia
# Options
is_valid(And(connected(Honolulu, Montreal), connected(Montreal, Honolulu))) ::: (A)
is_valid(And(connected(Honolulu, Vancouver), connected(Vancouver, Honolulu))) ::: (B)
is_valid(And(connected(Montreal, Toronto), connected(Toronto, Montreal))) ::: (C)
is_valid(And(connected(Montreal, Vancouver), connected(Vancouver, Montreal))) ::: (D)
is_valid(And(connected(Philadelphia, Vancouver), connected(Vancouver, Philadelphia))) ::: (E)"
"# Context:
Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.

# Question:
Which one of the following foods CANNOT be added first?

# Options:
A) kale
B) lentils
C) mushrooms
D) onions
E) tomatoes","# Declarations
foods = EnumSort([kale, lentils, mushrooms, onions, tomatoes, zucchini])
order = Function([foods] -> [int])
# Constraints
ForAll([f1:foods, f2:foods], Implies(f1 != f2, order(f1) != order(f2))) ::: No food is added more than once
Implies(order(mushrooms) == 3, order(lentils) == 6) ::: If the mushrooms are added third, then the lentils are added last
Implies(order(zucchini) == 1, Exists([f:foods], And(order(lentils) < order(onions), order(lentils) < order(f)))) ::: If the zucchini is added first, then the lentils are added at some time before the onions
And(order(tomatoes) != 5, order(kale) != 5) ::: Neither the tomatoes nor the kale is added fifth
Exists([f:foods], And(order(mushrooms) < order(tomatoes), order(mushrooms) < order(kale), order(mushrooms) != 1)) ::: The mushrooms are added at some time before the tomatoes or the kale, but not before both
# Options
is_unsat(order(kale) == 1) ::: (A)
is_unsat(order(lentils) == 1) ::: (B)
is_unsat(order(mushrooms) == 1) ::: (C)
is_unsat(order(onions) == 1) ::: (D)
is_unsat(order(tomatoes) == 1) ::: (E)"
"# Context:
Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.

# Question:
What is the maximum number of sessions attended by at least one Capital employee?

# Options:
A) three
B) four
C) five
D) six
E) seven","# Declarations
employees = EnumSort([Maria, Suki, Tate])
days = EnumSort([Day1, Day2, Day3])
topics = EnumSort([Hiring, Investing, Regulations])
attends = Function([employees, days, topics] -> [bool])
# Constraints
ForAll([e:employees], Count([d:days, t:topics], attends(e, d, t)) == 2) ::: Each conference participant attends exactly two sessions
ForAll([e:employees, d:days], Count([t:topics], attends(e, d, t)) <= 1) ::: Each participant attends at most one session per day
ForAll([e:employees, t:topics], Count([d:days], attends(e, d, t)) <= 1) ::: Each participant attends at most one session per topic
ForAll([d:days, t:topics], Count([e:employees], attends(e, d, t)) <= 2) ::: At most two Capital employees attend any given session together
ForAll([d:days], Not(attends(Maria, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([d:days], Not(attends(Suki, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([t:topics], Not(attends(Tate, Day3, t))) ::: Tate does not attend any session on the third day
# Options
is_sat(Count([e:employees, d:days, t:topics], attends(e, d, t)) == 3) ::: (A)
is_sat(Count([e:employees, d:days, t:topics], attends(e, d, t)) == 4) ::: (B)
is_sat(Count([e:employees, d:days, t:topics], attends(e, d, t)) == 5) ::: (C)
is_sat(Count([e:employees, d:days, t:topics], attends(e, d, t)) == 6) ::: (D)
is_sat(Count([e:employees, d:days, t:topics], attends(e, d, t)) == 7) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
Which one of the following could be a complete and accurate list of Zephyr Airlines' connected cities?

# Options:
A) Honolulu and Vancouver; Montreal and Toronto; Philadelphia and Vancouver; Toronto and Vancouver
B) Honolulu and Vancouver; Montreal and Philadelphia; Montreal and Toronto; Philadelphia and Toronto; Toronto and Vancouver
C) Honolulu and Philadelphia; Honolulu and Montreal; Philadelphia and Toronto; Toronto and Vancouver
D) Honolulu and Philadelphia; Montreal and Toronto; Philadelphia and Toronto; Philadelphia and Vancouver; Toronto and Vancouver
E) Honolulu and Philadelphia; Honolulu and Toronto; Montreal and Philadelphia; Philadelphia and Vancouver","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
# Options
is_accurate_list([And(connected(Honolulu, Vancouver), connected(Montreal, Toronto), connected(Philadelphia, Vancouver), connected(Toronto, Vancouver))]) ::: (A)
is_accurate_list([And(connected(Honolulu, Vancouver), connected(Montreal, Philadelphia), connected(Montreal, Toronto), connected(Philadelphia, Toronto), connected(Toronto, Vancouver))]) ::: (B)
is_accurate_list([And(connected(Honolulu, Philadelphia), connected(Honolulu, Montreal), connected(Philadelphia, Toronto), connected(Toronto, Vancouver))]) ::: (C)
is_accurate_list([And(connected(Honolulu, Philadelphia), connected(Montreal, Toronto), connected(Philadelphia, Toronto), connected(Philadelphia, Vancouver), connected(Toronto, Vancouver))]) ::: (D)
is_accurate_list([And(connected(Honolulu, Philadelphia), connected(Honolulu, Toronto), connected(Montreal, Philadelphia), connected(Philadelphia, Vancouver))]) ::: (E)"
"# Context:
Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.

# Question:
Which one of the following could be the order in which the foods are added to the broth?

# Options:
A) kale, mushrooms, onions, lentils, tomatoes, zucchini
B) kale, zucchini, mushrooms, tomatoes, lentils, onions
C) lentils, mushrooms, zucchini, kale, onions, tomatoes
D) zucchini, lentils, kale, mushrooms, onions, tomatoes
E) zucchini, tomatoes, onions, mushrooms, lentils, kale","# Declarations
foods = EnumSort([kale, lentils, mushrooms, onions, tomatoes, zucchini])
order = Function([foods] -> [int])
# Constraints
ForAll([f:foods], Exists([f1:foods], order(f1) == order(f))) ::: No food is added more than once
Implies(order(mushrooms) == 3, order(lentils) == 6) ::: If the mushrooms are added third, then the lentils are added last
Implies(order(zucchini) == 1, Exists([f:foods], And(order(lentils) < order(onions), order(lentils) < order(f)))) ::: If the zucchini is added first, then the lentils are added at some time before the onions
And(order(tomatoes) != 5, order(kale) != 5) ::: Neither the tomatoes nor the kale is added fifth
Or(order(mushrooms) < order(tomatoes), order(mushrooms) < order(kale)) ::: The mushrooms are added at some time before the tomatoes or the kale, but not before both
# Options
is_valid(And(order(kale) == 1, order(mushrooms) == 2, order(onions) == 3, order(lentils) == 4, order(tomatoes) == 5, order(zucchini) == 6)) ::: (A)
is_valid(And(order(kale) == 1, order(zucchini) == 2, order(mushrooms) == 3, order(tomatoes) == 4, order(lentils) == 5, order(onions) == 6)) ::: (B)
is_valid(And(order(lentils) == 1, order(mushrooms) == 2, order(zucchini) == 3, order(kale) == 4, order(onions) == 5, order(tomatoes) == 6)) ::: (C)
is_valid(And(order(zucchini) == 1, order(lentils) == 2, order(kale) == 3, order(mushrooms) == 4, order(onions) == 5, order(tomatoes) == 6)) ::: (D)
is_valid(And(order(zucchini) == 1, order(tomatoes) == 2, order(onions) == 3, order(mushrooms) == 4, order(lentils) == 5, order(kale) == 6)) ::: (E)"
"# Context:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.

# Question:
If all three of the raccoons are selected, which one of the following must be true?

# Options:
A) K is selected.
B) L is selected.
C) Exactly one monkey is selected.
D) Exactly two pandas are selected.
E) All three of the monkeys are selected.","# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
# Constraints
Count([a:animals], selected(a)) == 6 ::: exactly six individual animals are selected
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected
ForAll([a:animals], Implies(Or(a == T, a == V, a == Z), selected(a))) ::: all three of the raccoons are selected
# Options
is_valid(selected(K)) ::: (A)
is_valid(selected(L)) ::: (B)
is_valid(Count([a:animals], And(a == F, selected(a))) + Count([a:animals], And(a == G, selected(a))) + Count([a:animals], And(a == H, selected(a))) == 1) ::: (C)
is_valid(Count([a:animals], And(a == K, selected(a))) + Count([a:animals], And(a == L, selected(a))) + Count([a:animals], And(a == N, selected(a))) == 2) ::: (D)
is_valid(ForAll([a:animals], Implies(Or(a == F, a == G, a == H), selected(a)))) ::: (E)"
"# Context:
A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.

# Question:
Which one of the following could be an accurate list of the swimmers of the last five laps, in order from lap 6 through lap 10?

# Options:
A) Jacobson, Miller, Kruger, Ortiz, Lu
B) Kruger, Lu, Miller, Ortiz, Jacobson
C) Lu, Kruger, Miller, Ortiz, Jacobson
D) Miller, Kruger, Ortiz, Jacobson, Lu
E) Ortiz, Jacobson, Kruger, Miller, Lu","# Declarations
members = EnumSort([Jacobson, Kruger, Lu, Miller, Ortiz])
laps = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
swims = Function([members, laps] -> [bool])
# Constraints
ForAll([m:members], Count([l:laps], swims(m, l)) == 2) ::: Each team member swims exactly two of the laps
ForAll([l:laps], Count([m:members], swims(m, l)) == 1) ::: Each lap is swum by exactly one member
swims(Jacobson, 1) == True ::: One swims laps 1 and 6
swims(Jacobson, 6) == True ::: One swims laps 1 and 6
swims(Kruger, 2) == True ::: One swims laps 2 and 7
swims(Kruger, 7) == True ::: One swims laps 2 and 7
swims(Lu, 3) == True ::: One swims laps 3 and 8
swims(Lu, 8) == True ::: One swims laps 3 and 8
swims(Miller, 4) == True ::: One swims laps 4 and 9
swims(Miller, 9) == True ::: One swims laps 4 and 9
swims(Ortiz, 5) == True ::: One swims laps 5 and 10
swims(Ortiz, 10) == True ::: One swims laps 5 and 10
ForAll([l:laps], Implies(And(swims(Kruger, l), l < 9), Not(swims(Lu, l + 1)))) ::: Neither of Kruger's laps is immediately before either of Lu's
Not(swims(Jacobson, 9)) ::: Jacobson does not swim lap 9
Exists([l:laps], And(swims(Miller, l), ForAll([l1:laps], Implies(swims(Ortiz, l1), l < l1)))) ::: Ortiz's first lap is after (but not necessarily immediately after) Miller's
Exists([l:laps], And(swims(Ortiz, l), swims(Jacobson, l + 1))) ::: At least one of Jacobson's laps is immediately after one of Ortiz's laps
# Options
is_accurate_list([swims(Jacobson, 6), swims(Miller, 7), swims(Kruger, 8), swims(Ortiz, 9), swims(Lu, 10)]) ::: (A)
is_accurate_list([swims(Kruger, 6), swims(Lu, 7), swims(Miller, 8), swims(Ortiz, 9), swims(Jacobson, 10)]) ::: (B)
is_accurate_list([swims(Lu, 6), swims(Kruger, 7), swims(Miller, 8), swims(Ortiz, 9), swims(Jacobson, 10)]) ::: (C)
is_accurate_list([swims(Miller, 6), swims(Kruger, 7), swims(Ortiz, 8), swims(Jacobson, 9), swims(Lu, 10)]) ::: (D)
is_accurate_list([swims(Ortiz, 6), swims(Jacobson, 7), swims(Kruger, 8), swims(Miller, 9), swims(Lu, 10)]) ::: (E)"
"# Context:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.

# Question:
If T is selected, which one of the following is a pair of animals that must be among the animals selected?

# Options:
A) F and G
B) G and H
C) K and L
D) K and Z
E) L and N","# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
# Constraints
Count([a:animals], selected(a)) == 6 ::: exactly six individual animals are selected
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected
selected(T) ::: T is selected
# Options
is_valid(And(selected(F), selected(G))) ::: (A)
is_valid(And(selected(G), selected(H))) ::: (B)
is_valid(And(selected(K), selected(L))) ::: (C)
is_valid(And(selected(K), selected(Z))) ::: (D)
is_valid(And(selected(L), selected(N))) ::: (E)"
"# Context:
Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.

# Question:
If Xavier is not hired for one of the production positions, then which one of the following could be true?

# Options:
A) Feng and Herrera are both hired for sales positions.
B) Herrera and Weiss are both hired for sales positions.
C) Feng and Yates are both hired for production positions.
D) Garcia and Weiss are both hired for production positions.
E) Herrera and Weiss are both hired for production positions.","# Declarations
applicants = EnumSort([Feng, Garcia, Herrera, Ilias, Weiss, Xavier, Yates])
departments = EnumSort([Management, Production, Sales])
hired = Function([applicants] -> [departments])
# Constraints
Count([a:applicants], hired(a) == Management) == 1 ::: One position is in the management department
Count([a:applicants], hired(a) == Production) == 3 ::: Three positions are in the production department
Count([a:applicants], hired(a) == Sales) == 3 ::: Three positions are in the sales department
hired(Herrera) == hired(Yates) ::: Herrera is hired for a position in the same department as Yates
hired(Feng) != hired(Garcia) ::: Feng is hired for a position in a different department from Garcia
Implies(hired(Xavier) == Sales, hired(Weiss) == Production) ::: If Xavier is hired for a sales position, then Weiss is hired for a production position
hired(Feng) == Production ::: Feng is hired for a production position
ForAll([a:applicants], Implies(a != Xavier, hired(a) != Production)) ::: If Xavier is not hired for one of the production positions
# Options
is_valid(And(hired(Feng) == Sales, hired(Herrera) == Sales)) ::: (A)
is_valid(And(hired(Herrera) == Sales, hired(Weiss) == Sales)) ::: (B)
is_valid(And(hired(Feng) == Production, hired(Yates) == Production)) ::: (C)
is_valid(And(hired(Garcia) == Production, hired(Weiss) == Production)) ::: (D)
is_valid(And(hired(Herrera) == Production, hired(Weiss) == Production)) ::: (E)"
"# Context:
Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.

# Question:
Which one of the following could be an accurate matching of each Pohl child with the year in which that child was born?

# Options:
A) Sara: 1990; Zoe: 1992; Uma: 1993; Will: 1994; and Theo: 1995
B) Sara: 1991; Uma: 1993; Theo: 1994; Zoe: 1995; and Will: 1996
C) Zoe: 1990; Sara: 1991; Uma: 1992; Theo: 1994; and Will: 1995
D) Zoe: 1990; Sara: 1991; Uma: 1993; Theo: 1994; and Will: 1995
E) Zoe: 1990; Sara: 1991; Uma: 1993; Theo: 1994; and Will: 1996","# Declarations
children = EnumSort([Sara, Theo, Uma, Will, Zoe])
years = EnumSort([1990, 1991, 1992, 1993, 1994, 1995, 1996])
handedness = EnumSort([left, right])
birth_year = Function([children] -> [years])
hand = Function([children] -> [handedness])
# Constraints
Count([c:children], hand(c) == left) == 3 ::: three are left-handed
Count([c:children], hand(c) == right) == 2 ::: two are right-handed
ForAll([c1:children, c2:children], Implies(And(hand(c1) == left, hand(c2) == left, c1 != c2), Abs(birth_year(c1) - birth_year(c2)) != 1)) ::: No two left-handed children were born in consecutive years
ForAll([c1:children, c2:children], Implies(And(hand(c1) == right, hand(c2) == right, c1 != c2), Abs(birth_year(c1) - birth_year(c2)) != 1)) ::: No two right-handed children were born in consecutive years
hand(Sara) == left ::: Sara is left-handed
birth_year(Sara) < birth_year(Uma) ::: Sara was born before Uma
birth_year(Zoe) < birth_year(Theo) ::: Zoe was born before Theo
birth_year(Zoe) < birth_year(Will) ::: Zoe was born before Will
Exists([c:children], And(hand(c) == left, birth_year(c) == 1991)) ::: A left-handed child was born in 1991
hand(Uma) == right ::: Uma is right-handed
birth_year(Uma) == 1993 ::: Uma was born in 1993
# Options
is_accurate_list([birth_year(Sara) == 1990, birth_year(Zoe) == 1992, birth_year(Uma) == 1993, birth_year(Will) == 1994, birth_year(Theo) == 1995]) ::: (A)
is_accurate_list([birth_year(Sara) == 1991, birth_year(Uma) == 1993, birth_year(Theo) == 1994, birth_year(Zoe) == 1995, birth_year(Will) == 1996]) ::: (B)
is_accurate_list([birth_year(Zoe) == 1990, birth_year(Sara) == 1991, birth_year(Uma) == 1992, birth_year(Theo) == 1994, birth_year(Will) == 1995]) ::: (C)
is_accurate_list([birth_year(Zoe) == 1990, birth_year(Sara) == 1991, birth_year(Uma) == 1993, birth_year(Theo) == 1994, birth_year(Will) == 1995]) ::: (D)
is_accurate_list([birth_year(Zoe) == 1990, birth_year(Sara) == 1991, birth_year(Uma) == 1993, birth_year(Theo) == 1994, birth_year(Will) == 1996]) ::: (E)"
"# Context:
Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.

# Question:
The largest possible number of files that can separate X from V is

# Options:
A) three
B) four
C) five
D) six
E) seven","# Declarations
files = EnumSort([H, M, O, P, V, X, T, Z])
categories = EnumSort([red, green, yellow])
position = Function([files] -> [int])
category = Function([files] -> [categories])
# Constraints
ForAll([f:files], And(position(f) >= 1, position(f) <= 8)) ::: Each file is ordered from first to eighth
ForAll([f:files], Exists([c:categories], category(f) == c)) ::: Each file falls into exactly one category
category(H) == red ::: H is a red file
category(M) == red ::: M is a red file
category(O) == red ::: O is a red file
category(P) == green ::: P is a green file
category(V) == green ::: V is a green file
category(X) == green ::: X is a green file
category(T) == yellow ::: T is a yellow file
category(Z) == yellow ::: Z is a yellow file
position(H) < position(O) ::: H must be placed into some position before O
position(H) != position(O) - 1 ::: H cannot immediately precede O
position(X) < position(V) ::: X must be placed into some position before V
position(V) - position(X) == position(O) - position(H) ::: X and V must be separated by the same number of files as separate H and O
position(Z) == position(M) - 1 ::: Z must immediately precede M
category(files[0]) != red ::: The first file cannot be a red file
# Options
is_valid(position(V) - position(X) == 3) ::: (A)
is_valid(position(V) - position(X) == 4) ::: (B)
is_valid(position(V) - position(X) == 5) ::: (C)
is_valid(position(V) - position(X) == 6) ::: (D)
is_valid(position(V) - position(X) == 7) ::: (E)"
"# Context:
Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.

# Question:
If Feng is hired for a position in the same department as Xavier, then each of the following could be true EXCEPT:

# Options:
A) Garcia is hired for a sales position.
B) Herrera is hired for a production position.
C) Ilias is hired for a sales position.
D) Weiss is hired for the management position.
E) Weiss is hired for a production position.","# Declarations
applicants = EnumSort([Feng, Garcia, Herrera, Ilias, Weiss, Xavier, Yates])
departments = EnumSort([Management, Production, Sales])
hired = Function([applicants] -> [departments])
# Constraints
hired(Herrera) == hired(Yates) ::: Herrera is hired for a position in the same department as Yates
hired(Feng) != hired(Garcia) ::: Feng is hired for a position in a different department from Garcia
Implies(hired(Xavier) == Sales, hired(Weiss) == Production) ::: If Xavier is hired for a sales position, then Weiss is hired for a production position
hired(Feng) == Production ::: Feng is hired for a production position
hired(Feng) == hired(Xavier) ::: Feng is hired for a position in the same department as Xavier
# Options
is_unsat(hired(Garcia) == Sales) ::: (A)
is_unsat(hired(Herrera) == Production) ::: (B)
is_unsat(hired(Ilias) == Sales) ::: (C)
is_unsat(hired(Weiss) == Management) ::: (D)
is_unsat(hired(Weiss) == Production) ::: (E)"
"# Context:
Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.

# Question:
If exactly one professor was hired in 1991, then which one of the following could be true?

# Options:
A) Madison and Paton share a specialty.
B) Robinson and Sarkis share a specialty.
C) Paton was hired exactly one year after Orozco.
D) Exactly one professor was hired in 1994.
E) Exactly two professors were hired in 1993.","# Declarations
professors = EnumSort([Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, Togo])
years = EnumSort([1989, 1990, 1991, 1992, 1993, 1994, 1995])
specialties = EnumSort([specialty1, specialty2, specialty3, specialty4, specialty5, specialty6, specialty7])
hired_in = Function([professors] -> [years])
has_specialty = Function([professors, specialties] -> [bool])
# Constraints
ForAll([p:professors], Exists([y:years], hired_in(p) == y)) ::: Each professor was hired in exactly one year
ForAll([p1:professors, p2:professors], Implies(And(hired_in(p1) == hired_in(p2), p1 != p2), ForAll([s:specialties], Not(And(has_specialty(p1, s), has_specialty(p2, s)))))) ::: Any two professors hired in the same year do not have a specialty in common
ForAll([p1:professors, p2:professors], Implies(And(Abs(hired_in(p1) - hired_in(p2)) == 1, p1 != p2), ForAll([s:specialties], Not(And(has_specialty(p1, s), has_specialty(p2, s)))))) ::: Any two professors hired in consecutive years do not have a specialty in common
hired_in(Madison) == 1993 ::: Madison was hired in 1993
hired_in(Robinson) == 1991 ::: Robinson was hired in 1991
Exists([s:specialties], And(has_specialty(Madison, s), has_specialty(Orozco, s), has_specialty(Togo, s))) ::: There is at least one specialty that Madison, Orozco, and Togo have in common
Exists([s:specialties], And(has_specialty(Nilsson, s), has_specialty(Robinson, s))) ::: Nilsson shares a specialty with Robinson
ForAll([p:professors], Implies(p == Paton, And(hired_in(p) < 1993, hired_in(p) > hired_in(Nilsson)))) ::: Paton was hired at least one year before Madison and at least one year after Nilsson
ForAll([p:professors], Implies(p == Sarkis, And(hired_in(p) < 1993, hired_in(p) > hired_in(Nilsson)))) ::: Sarkis was hired at least one year before Madison and at least one year after Nilsson
hired_in(Orozco) == 1990 ::: Orozco was hired in 1990
Exists([s:specialties], And(has_specialty(Orozco, s), has_specialty(Sarkis, s))) ::: Orozco shares a specialty with Sarkis
Count([p:professors], hired_in(p) == 1991) == 1 ::: Exactly one professor was hired in 1991
# Options
is_valid(Exists([s:specialties], And(has_specialty(Madison, s), has_specialty(Paton, s)))) ::: (A)
is_valid(Exists([s:specialties], And(has_specialty(Robinson, s), has_specialty(Sarkis, s)))) ::: (B)
is_valid(hired_in(Paton) == 1991) ::: (C)
is_valid(Count([p:professors], hired_in(p) == 1994) == 1) ::: (D)
is_valid(Count([p:professors], hired_in(p) == 1993) == 2) ::: (E)"
"# Context:
A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.

# Question:
If the condition that if the fruit stand does not carry tangerines then it does carry kiwis is suspended, and all other conditions remain in effect, then which one of the following CANNOT be a complete and accurate list of the kinds of fruit the stand carries?

# Options:
A) pears
B) figs, pears
C) oranges, pears, watermelons
D) figs, pears, watermelons
E) figs, oranges, pears, watermelons","# Declarations
fruits = EnumSort([figs, kiwis, oranges, pears, tangerines, watermelons])
carries = Function([fruits] -> [bool])
# Constraints
Exists([f:fruits], carries(f)) ::: The stand carries at least one kind of fruit
ForAll([f:fruits], Implies(carries(kiwis), Not(carries(pears)))) ::: If the stand carries kiwis, then it does not carry pears
Implies(carries(oranges), And(carries(pears), carries(watermelons))) ::: If the stand carries oranges, then it carries both pears and watermelons
Implies(carries(watermelons), Or(carries(figs), carries(tangerines))) ::: If the stand carries watermelons, then it carries figs or tangerines or both
# Options
is_unsat(And(carries(pears), Not(Exists([f:fruits], And(f != pears, carries(f)))))) ::: (A)
is_unsat(And(carries(figs), carries(pears), Not(Exists([f:fruits], And(f != figs, f != pears, carries(f)))))) ::: (B)
is_unsat(And(carries(oranges), carries(pears), carries(watermelons), Not(Exists([f:fruits], And(f != oranges, f != pears, f != watermelons, carries(f)))))) ::: (C)
is_unsat(And(carries(figs), carries(pears), carries(watermelons), Not(Exists([f:fruits], And(f != figs, f != pears, f != watermelons, carries(f)))))) ::: (D)
is_unsat(And(carries(figs), carries(oranges), carries(pears), carries(watermelons), Not(Exists([f:fruits], And(f != figs, f != oranges, f != pears, f != watermelons, carries(f)))))) ::: (E)"
"# Context:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.

# Question:
If H and L are among the animals selected, which one of the following could be true?

# Options:
A) F is selected.
B) T is selected.
C) Z is selected.
D) Exactly one panda is selected.
E) Exactly two pandas are selected.","# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
# Constraints
Count([a:animals], selected(a)) == 6 ::: exactly six individual animals are selected
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected
selected(H) ::: H is among the animals selected
selected(L) ::: L is among the animals selected
# Options
is_valid(selected(F)) ::: (A)
is_valid(selected(T)) ::: (B)
is_valid(selected(Z)) ::: (C)
is_valid(Count([a:animals], And(selected(a), Or(a == K, a == L, a == N))) == 1) ::: (D)
is_valid(Count([a:animals], And(selected(a), Or(a == K, a == L, a == N))) == 2) ::: (E)"
"# Context:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.

# Question:
Each of the following is a pair of animals that could be selected together EXCEPT

# Options:
A) F and G
B) H and K
C) K and T
D) L and N
E) T and V","# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
# Constraints
Count([a:animals], selected(a)) == 6 ::: exactly six individual animals are selected
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected
# Options
is_unsat(And(selected(F), selected(G))) ::: (A)
is_unsat(And(selected(H), selected(K))) ::: (B)
is_unsat(And(selected(K), selected(T))) ::: (C)
is_unsat(And(selected(L), selected(N))) ::: (D)
is_unsat(And(selected(T), selected(V))) ::: (E)"
"# Context:
Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.

# Question:
If Maria and Tate are the only Capital employees to attend a session on the first day, then each of the following could be true EXCEPT:

# Options:
A) Maria and Suki attend exactly two sessions together.
B) Maria and Tate attend exactly two sessions together.
C) Suki and Tate attend exactly one session together.
D) Maria attends a session on regulations on the second day.
E) Tate attends a session on hiring on the second day.","# Declarations
employees = EnumSort([Maria, Suki, Tate])
days = EnumSort([Day1, Day2, Day3])
topics = EnumSort([Hiring, Investing, Regulations])
attends = Function([employees, days, topics] -> [bool])
# Constraints
ForAll([e:employees], Count([d:days, t:topics], attends(e, d, t)) == 2) ::: Each conference participant attends exactly two sessions
ForAll([e:employees, d:days], Count([t:topics], attends(e, d, t)) <= 1) ::: Each participant attends sessions on different topics on different days
ForAll([d:days, t:topics], Count([e:employees], attends(e, d, t)) <= 2) ::: At most two Capital employees attend any given session together
ForAll([d:days], Not(attends(Maria, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([d:days], Not(attends(Suki, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([t:topics], Not(attends(Tate, Day3, t))) ::: Tate does not attend any session on the third day
ForAll([t:topics], And(attends(Maria, Day1, t), attends(Tate, Day1, t))) ::: Maria and Tate are the only Capital employees to attend a session on the first day
# Options
is_unsat(ForAll([d:days, t:topics], Implies(And(attends(Maria, d, t), attends(Suki, d, t)), Count([d1:days, t1:topics], And(attends(Maria, d1, t1), attends(Suki, d1, t1))) == 2))) ::: (A)
is_unsat(ForAll([d:days, t:topics], Implies(And(attends(Maria, d, t), attends(Tate, d, t)), Count([d1:days, t1:topics], And(attends(Maria, d1, t1), attends(Tate, d1, t1))) == 2))) ::: (B)
is_unsat(Count([d:days, t:topics], And(attends(Suki, d, t), attends(Tate, d, t))) == 1) ::: (C)
is_unsat(attends(Maria, Day2, Regulations)) ::: (D)
is_unsat(attends(Tate, Day2, Hiring)) ::: (E)"
"# Context:
A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.

# Question:
Which one of the following must be true?

# Options:
A) A linguistics monograph and a grammar are on the second shelf.
B) A novel and a grammar are on the second shelf.
C) At least one linguistics monograph and at least one grammar are on the third shelf.
D) At least one novel and at least one grammar are on the third shelf.
E) At least one novel and at least one linguistics monograph are on the third shelf.","# Declarations
shelves = EnumSort([Shelf1, Shelf2, Shelf3])
books = EnumSort([FarsiGrammar, HausaGrammar, PhonologyMonograph, SemanticsMonograph, VonnegutNovel, WoolfNovel])
located = Function([books] -> [shelves])
# Constraints
located(FarsiGrammar) != located(HausaGrammar) ::: Two of the books are grammars—one of Farsi, the other of Hausa
located(PhonologyMonograph) != located(SemanticsMonograph) ::: Two others are linguistics monographs—one on phonology, the other on semantics
located(VonnegutNovel) != located(PhonologyMonograph) ::: The Vonnegut novel is not on the same shelf as either monograph
located(VonnegutNovel) != located(SemanticsMonograph) ::: The Vonnegut novel is not on the same shelf as either monograph
Exists([b:books], And(b == VonnegutNovel or b == WoolfNovel, located(b) == located(FarsiGrammar))) ::: There is at least one novel on the same shelf as the Farsi grammar
Count([b:books], located(b) == Shelf1) == 1 ::: one book on the first shelf
Count([b:books], located(b) == Shelf2) == 2 ::: two books on the second shelf
Count([b:books], located(b) == Shelf3) == 3 ::: three books on the third shelf
# Options
is_valid(And(Exists([b:books], And(b == PhonologyMonograph or b == SemanticsMonograph, located(b) == Shelf2)), Exists([b:books], And(b == FarsiGrammar or b == HausaGrammar, located(b) == Shelf2)))) ::: (A)
is_valid(And(Exists([b:books], And(b == VonnegutNovel or b == WoolfNovel, located(b) == Shelf2)), Exists([b:books], And(b == FarsiGrammar or b == HausaGrammar, located(b) == Shelf2)))) ::: (B)
is_valid(And(Exists([b:books], And(b == PhonologyMonograph or b == SemanticsMonograph, located(b) == Shelf3)), Exists([b:books], And(b == FarsiGrammar or b == HausaGrammar, located(b) == Shelf3)))) ::: (C)
is_valid(And(Exists([b:books], And(b == VonnegutNovel or b == WoolfNovel, located(b) == Shelf3)), Exists([b:books], And(b == FarsiGrammar or b == HausaGrammar, located(b) == Shelf3)))) ::: (D)
is_valid(And(Exists([b:books], And(b == VonnegutNovel or b == WoolfNovel, located(b) == Shelf3)), Exists([b:books], And(b == PhonologyMonograph or b == SemanticsMonograph, located(b) == Shelf3)))) ::: (E)"
"# Context:
Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.

# Question:
If Barbara selects fish of as many species as possible, then she cannot select any fish of which one of the following species?

# Options:
A) K
B) L
C) M
D) N
E) P","# Declarations
species = EnumSort([J, K, L, M, N, O, P])
selected = Function([species] -> [bool])
# Constraints
Implies(selected(K), Not(selected(O))) ::: If she selects one or more K, then she does not select any O
Implies(selected(M), Not(selected(N))) ::: If she selects one or more M, then she does not select any N
Implies(selected(M), selected(O)) ::: If she selects one or more M, then she selects at least one O
Implies(selected(N), selected(O)) ::: If she selects one or more N, then she selects at least one O
Implies(selected(O), selected(P)) ::: If she selects one or more O, then she selects at least one P
Implies(selected(P), selected(O)) ::: If she selects one or more P, then she selects at least one O
Implies(selected(O), Count([s:species], And(s == O, selected(s))) >= 2) ::: If she selects any O at all, then she selects at least two O
# Options
is_unsat(selected(K)) ::: (A)
is_unsat(selected(L)) ::: (B)
is_unsat(selected(M)) ::: (C)
is_unsat(selected(N)) ::: (D)
is_unsat(selected(P)) ::: (E)"
"# Context:
Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.

# Question:
Each of the following could be an accurate partial list of the applicants hired for sales positions EXCEPT:

# Options:
A) Garcia, Ilias
B) Garcia, Xavier
C) Garcia, Yates
D) Herrera, Weiss
E) Herrera, Xavier","# Declarations
applicants = EnumSort([Feng, Garcia, Herrera, Ilias, Weiss, Xavier, Yates])
departments = EnumSort([management, production, sales])
hired = Function([applicants] -> [departments])
# Constraints
hired(Herrera) == hired(Yates) ::: Herrera is hired for a position in the same department as Yates
hired(Feng) != hired(Garcia) ::: Feng is hired for a position in a different department from Garcia
Implies(hired(Xavier) == sales, hired(Weiss) == production) ::: If Xavier is hired for a sales position, then Weiss is hired for a production position
hired(Feng) == production ::: Feng is hired for a production position
Count([a:applicants], hired(a) == management) == 1 ::: One position is in the management department
Count([a:applicants], hired(a) == production) == 3 ::: Three positions are in the production department
Count([a:applicants], hired(a) == sales) == 3 ::: Three positions are in the sales department
# Options
is_accurate_list([hired(Garcia) == sales, hired(Ilias) == sales]) ::: (A)
is_accurate_list([hired(Garcia) == sales, hired(Xavier) == sales]) ::: (B)
is_accurate_list([hired(Garcia) == sales, hired(Yates) == sales]) ::: (C)
is_accurate_list([hired(Herrera) == sales, hired(Weiss) == sales]) ::: (D)
is_accurate_list([hired(Herrera) == sales, hired(Xavier) == sales]) ::: (E)"
"# Context:
Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.

# Question:
The largest possible number of files that can separate Z from H is

# Options:
A) two
B) three
C) four
D) five
E) six","# Declarations
files = EnumSort([H, M, O, P, V, X, T, Z])
categories = EnumSort([red, green, yellow])
position = Function([files] -> [int])
category = Function([files] -> [categories])
# Constraints
ForAll([f:files], And(position(f) >= 1, position(f) <= 8)) ::: Each file is ordered from first to eighth
ForAll([f:files], Exists([c:categories], category(f) == c)) ::: Each file falls into exactly one category
category(H) == red ::: H is a red file
category(M) == red ::: M is a red file
category(O) == red ::: O is a red file
category(P) == green ::: P is a green file
category(V) == green ::: V is a green file
category(X) == green ::: X is a green file
category(T) == yellow ::: T is a yellow file
category(Z) == yellow ::: Z is a yellow file
position(H) < position(O) ::: H must be placed into some position before O
position(H) != position(O) - 1 ::: H cannot immediately precede O
position(X) < position(V) ::: X must be placed into some position before V
position(V) - position(X) == position(O) - position(H) ::: X and V must be separated by the same number of files as separate H and O
position(Z) == position(M) - 1 ::: Z must immediately precede M
ForAll([f:files], Implies(position(f) == 1, category(f) != red)) ::: The first file cannot be a red file
# Options
is_valid(position(H) - position(Z) == 3) ::: (A)
is_valid(position(H) - position(Z) == 4) ::: (B)
is_valid(position(H) - position(Z) == 5) ::: (C)
is_valid(position(H) - position(Z) == 6) ::: (D)
is_valid(position(H) - position(Z) == 7) ::: (E)"
"# Context:
For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.

# Question:
Which one of the following is an acceptable selection of animals for the study?

# Options:
A) F, G, K, N, T, V
B) F, H, K, N, V, Z
C) G, H, K, L, V, Z
D) G, H, K, N, V, Z
E) G, H, L, N, V, Z","# Declarations
animals = EnumSort([F, G, H, K, L, N, T, V, Z])
selected = Function([animals] -> [bool])
# Constraints
Count([a:animals], selected(a)) == 6 ::: exactly six individual animals are selected
Not(And(selected(F), selected(H))) ::: F and H are not both selected
Not(And(selected(N), selected(T))) ::: N and T are not both selected
Implies(selected(H), selected(K)) ::: If H is selected, K is also selected
Implies(selected(K), selected(N)) ::: If K is selected, N is also selected
# Options
is_sat(And(selected(F), selected(G), selected(K), selected(N), selected(T), selected(V))) ::: (A)
is_sat(And(selected(F), selected(H), selected(K), selected(N), selected(V), selected(Z))) ::: (B)
is_sat(And(selected(G), selected(H), selected(K), selected(L), selected(V), selected(Z))) ::: (C)
is_sat(And(selected(G), selected(H), selected(K), selected(N), selected(V), selected(Z))) ::: (D)
is_sat(And(selected(G), selected(H), selected(L), selected(N), selected(V), selected(Z))) ::: (E)"
"# Context:
A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.

# Question:
Which one of the following CANNOT be true?

# Options:
A) A grammar is on the first shelf.
B) A linguistics monograph is on the same shelf as the Hausa grammar.
C) A novel is on the first shelf.
D) The novels are on the same shelf as each other.
E) Neither linguistics monograph is on the first shelf.","# Declarations
shelves = EnumSort([first, second, third])
books = EnumSort([FarsiGrammar, HausaGrammar, PhonologyMonograph, SemanticsMonograph, VonnegutNovel, WoolfNovel])
located = Function([books] -> [shelves])
# Constraints
located(FarsiGrammar) != located(HausaGrammar) ::: Two of the books are grammars—one of Farsi, the other of Hausa
located(PhonologyMonograph) != located(SemanticsMonograph) ::: Two others are linguistics monographs—one on phonology, the other on semantics
located(VonnegutNovel) != located(PhonologyMonograph) ::: The Vonnegut novel is not on the same shelf as either monograph
located(VonnegutNovel) != located(SemanticsMonograph) ::: The Vonnegut novel is not on the same shelf as either monograph
Exists([b:books], And(b == VonnegutNovel or b == WoolfNovel, located(b) == located(FarsiGrammar))) ::: There is at least one novel on the same shelf as the Farsi grammar
Count([b:books], located(b) == first) == 1 ::: one book on the first shelf
Count([b:books], located(b) == second) == 2 ::: two books on the second shelf
Count([b:books], located(b) == third) == 3 ::: three books on the third shelf
# Options
is_unsat(located(FarsiGrammar) == first) ::: (A) A grammar is on the first shelf
is_unsat(located(PhonologyMonograph) == located(HausaGrammar)) ::: (B) A linguistics monograph is on the same shelf as the Hausa grammar
is_unsat(located(VonnegutNovel) == first) ::: (C) A novel is on the first shelf
is_unsat(And(located(VonnegutNovel) == located(WoolfNovel), located(VonnegutNovel) != located(FarsiGrammar))) ::: (D) The novels are on the same shelf as each other
is_unsat(And(located(PhonologyMonograph) != first, located(SemanticsMonograph) != first)) ::: (E) Neither linguistics monograph is on the first shelf"
"# Context:
Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.

# Question:
It can be determined in which department each of the seven applicants is hired if which one of the following statements is true?

# Options:
A) Feng and Weiss are both hired for production positions.
B) Garcia and Yates are both hired for sales positions.
C) Ilias and Weiss are both hired for sales positions.
D) Ilias and Weiss are both hired for production positions.
E) Ilias and Xavier are both hired for production positions.","# Declarations
applicants = EnumSort([Feng, Garcia, Herrera, Ilias, Weiss, Xavier, Yates])
departments = EnumSort([Management, Production, Sales])
hired = Function([applicants] -> [departments])
# Constraints
Count([a:applicants], hired(a) == Management) == 1 ::: One position is in the management department
Count([a:applicants], hired(a) == Production) == 3 ::: Three positions are in the production department
Count([a:applicants], hired(a) == Sales) == 3 ::: Three positions are in the sales department
hired(Herrera) == hired(Yates) ::: Herrera is hired for a position in the same department as Yates
hired(Feng) != hired(Garcia) ::: Feng is hired for a position in a different department from Garcia
Implies(hired(Xavier) == Sales, hired(Weiss) == Production) ::: If Xavier is hired for a sales position, then Weiss is hired for a production position
hired(Feng) == Production ::: Feng is hired for a production position
# Options
is_valid(And(hired(Feng) == Production, hired(Weiss) == Production)) ::: (A)
is_valid(And(hired(Garcia) == Sales, hired(Yates) == Sales)) ::: (B)
is_valid(And(hired(Ilias) == Sales, hired(Weiss) == Sales)) ::: (C)
is_valid(And(hired(Ilias) == Production, hired(Weiss) == Production)) ::: (D)
is_valid(And(hired(Ilias) == Production, hired(Xavier) == Production)) ::: (E)"
"# Context:
Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.

# Question:
Which one of the following is a complete and accurate list of the professors who could have been hired in the years 1989 through 1991?

# Options:
A) Nilsson, Orozco, Robinson
B) Orozco, Robinson, Sarkis
C) Nilsson, Orozco, Paton, Robinson
D) Nilsson, Orozco, Paton, Sarkis
E) Orozco, Paton, Robinson, Sarkis","# Declarations
professors = EnumSort([Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, Togo])
years = EnumSort([1989, 1990, 1991, 1992, 1993, 1994, 1995])
specialties = EnumSort([s1, s2, s3, s4, s5, s6, s7])
hired = Function([professors] -> [years])
specialty = Function([professors, specialties] -> [bool])
# Constraints
hired(Madison) == 1993 ::: Madison was hired in 1993
hired(Robinson) == 1991 ::: Robinson was hired in 1991
Exists([s:specialties], And(specialty(Madison, s), specialty(Orozco, s), specialty(Togo, s))) ::: There is at least one specialty that Madison, Orozco, and Togo have in common
Exists([s:specialties], And(specialty(Nilsson, s), specialty(Robinson, s))) ::: Nilsson shares a specialty with Robinson
ForAll([p:professors], Implies(Or(p == Paton, p == Sarkis), And(hired(p) < 1993, hired(p) > hired(Nilsson)))) ::: Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson
hired(Orozco) == 1990 ::: Orozco was hired in 1990
Exists([s:specialties], And(specialty(Orozco, s), specialty(Sarkis, s))) ::: Orozco shares a specialty with Sarkis
ForAll([p1:professors, p2:professors, y:years], Implies(And(hired(p1) == y, hired(p2) == y), ForAll([s:specialties], Not(And(specialty(p1, s), specialty(p2, s)))))) ::: Any two professors hired in the same year do not have a specialty in common
ForAll([p1:professors, p2:professors, y:years], Implies(And(hired(p1) == y, hired(p2) == y + 1), ForAll([s:specialties], Not(And(specialty(p1, s), specialty(p2, s)))))) ::: Any two professors hired in consecutive years do not have a specialty in common
# Options
is_accurate_list([hired(Nilsson) <= 1991, hired(Orozco) <= 1991, hired(Robinson) <= 1991]) ::: (A)
is_accurate_list([hired(Orozco) <= 1991, hired(Robinson) <= 1991, hired(Sarkis) <= 1991]) ::: (B)
is_accurate_list([hired(Nilsson) <= 1991, hired(Orozco) <= 1991, hired(Paton) <= 1991, hired(Robinson) <= 1991]) ::: (C)
is_accurate_list([hired(Nilsson) <= 1991, hired(Orozco) <= 1991, hired(Paton) <= 1991, hired(Sarkis) <= 1991]) ::: (D)
is_accurate_list([hired(Orozco) <= 1991, hired(Paton) <= 1991, hired(Robinson) <= 1991, hired(Sarkis) <= 1991]) ::: (E)"
"# Context:
Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.

# Question:
Which one of the following could be a complete and accurate list of the fish Barbara selects for her aquarium?

# Options:
A) three J, one K, two M
B) one J, one K, one M, three O
C) one J, one M, two O, one P
D) one J, one N, one O, two P
E) one M, one N, two O, one P","# Declarations
species = EnumSort([J, K, M, N, O, P])
selected = Function([species] -> [int])
# Constraints
Implies(selected(K) > 0, selected(O) == 0) ::: If she selects one or more K, then she does not select any O
Implies(selected(M) > 0, selected(N) == 0) ::: If she selects one or more M, then she does not select any N
Implies(selected(M) > 0, selected(O) > 0) ::: If she selects one or more M, then she selects at least one O
Implies(selected(N) > 0, selected(O) > 0) ::: If she selects one or more N, then she selects at least one O
Implies(selected(O) > 0, selected(P) > 0) ::: If she selects one or more O, then she selects at least one P
Implies(selected(P) > 0, selected(O) > 0) ::: If she selects one or more P, then she selects at least one O
Implies(selected(O) > 0, selected(O) >= 2) ::: If she selects any O at all, then she selects at least two O
# Options
is_accurate_list([selected(J) == 3, selected(K) == 1, selected(M) == 2]) ::: (A)
is_accurate_list([selected(J) == 1, selected(K) == 1, selected(M) == 1, selected(O) == 3]) ::: (B)
is_accurate_list([selected(J) == 1, selected(M) == 1, selected(O) == 2, selected(P) == 1]) ::: (C)
is_accurate_list([selected(J) == 1, selected(N) == 1, selected(O) == 1, selected(P) == 2]) ::: (D)
is_accurate_list([selected(M) == 1, selected(N) == 1, selected(O) == 2, selected(P) == 1]) ::: (E)"
"# Context:
Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.

# Question:
Which one of the following is a complete and accurate list of the applicants, each of whom CANNOT be hired for a production position?

# Options:
A) Feng, Ilias, Xavier
B) Garcia, Herrera, Yates
C) Herrera, Yates
D) Garcia
E) Ilias","# Declarations
applicants = EnumSort([Feng, Garcia, Herrera, Ilias, Weiss, Xavier, Yates])
departments = EnumSort([Management, Production, Sales])
hired = Function([applicants] -> [departments])
# Constraints
Count([a:applicants], hired(a) == Management) == 1 ::: One position is in the management department
Count([a:applicants], hired(a) == Production) == 3 ::: Three positions are in the production department
Count([a:applicants], hired(a) == Sales) == 3 ::: Three positions are in the sales department
hired(Herrera) == hired(Yates) ::: Herrera is hired for a position in the same department as Yates
hired(Feng) != hired(Garcia) ::: Feng is hired for a position in a different department from Garcia
Implies(hired(Xavier) == Sales, hired(Weiss) == Production) ::: If Xavier is hired for a sales position, then Weiss is hired for a production position
hired(Feng) == Production ::: Feng is hired for a production position
# Options
is_accurate_list([hired(Feng) != Production, hired(Ilias) != Production, hired(Xavier) != Production]) ::: (A)
is_accurate_list([hired(Garcia) != Production, hired(Herrera) != Production, hired(Yates) != Production]) ::: (B)
is_accurate_list([hired(Herrera) != Production, hired(Yates) != Production]) ::: (C)
is_accurate_list([hired(Garcia) != Production]) ::: (D)
is_accurate_list([hired(Ilias) != Production]) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
If four of the cities are each connected with the remaining city, then the cities in which one of the following pairs must be connected with each other?

# Options:
A) Honolulu and Montreal
B) Honolulu and Philadelphia
C) Honolulu and Vancouver
D) Montreal and Philadelphia
E) Montreal and Toronto","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
Count([c:cities], ForAll([c1:cities], Implies(c != c1, connected(c, c1)))) == 4 ::: If four of the cities are each connected with the remaining city
# Options
is_valid(connected(Honolulu, Montreal)) ::: (A)
is_valid(connected(Honolulu, Philadelphia)) ::: (B)
is_valid(connected(Honolulu, Vancouver)) ::: (C)
is_valid(connected(Montreal, Philadelphia)) ::: (D)
is_valid(connected(Montreal, Toronto)) ::: (E)"
"# Context:
A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.

# Question:
If Ortiz swims lap 4, then which one of the following could be true?

# Options:
A) Jacobson swims lap 1.
B) Jacobson swims lap 3.
C) Kruger swims lap 5.
D) Lu swims lap 3.
E) Miller swims lap 5.","# Declarations
members = EnumSort([Jacobson, Kruger, Lu, Miller, Ortiz])
laps = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
swims = Function([members, laps] -> [bool])
# Constraints
ForAll([m:members], Count([l:laps], swims(m, l)) == 2) ::: Each team member swims exactly two of the laps
ForAll([l:laps], Count([m:members], swims(m, l)) == 1) ::: Each lap is swum by exactly one member
swims(Jacobson, 1) == True ::: One swims laps 1 and 6
swims(Jacobson, 6) == True ::: One swims laps 1 and 6
swims(Kruger, 2) == True ::: One swims laps 2 and 7
swims(Kruger, 7) == True ::: One swims laps 2 and 7
swims(Lu, 3) == True ::: One swims laps 3 and 8
swims(Lu, 8) == True ::: One swims laps 3 and 8
swims(Miller, 4) == True ::: One swims laps 4 and 9
swims(Miller, 9) == True ::: One swims laps 4 and 9
swims(Ortiz, 5) == True ::: One swims laps 5 and 10
swims(Ortiz, 10) == True ::: One swims laps 5 and 10
ForAll([l:laps], Implies(swims(Kruger, l), And(Not(swims(Lu, l + 1)), Not(swims(Lu, l - 1))))) ::: Neither of Kruger's laps is immediately before either of Lu's
Not(swims(Jacobson, 9)) ::: Jacobson does not swim lap 9
Exists([l:laps], And(swims(Miller, l), ForAll([l2:laps], Implies(swims(Ortiz, l2), l < l2)))) ::: Ortiz's first lap is after (but not necessarily immediately after) Miller's
Exists([l:laps], And(swims(Ortiz, l), swims(Jacobson, l + 1))) ::: At least one of Jacobson's laps is immediately after one of Ortiz's laps
swims(Ortiz, 4) == True ::: If Ortiz swims lap 4
# Options
is_valid(swims(Jacobson, 1)) ::: (A)
is_valid(swims(Jacobson, 3)) ::: (B)
is_valid(swims(Kruger, 5)) ::: (C)
is_valid(swims(Lu, 3)) ::: (D)
is_valid(swims(Miller, 5)) ::: (E)"
"# Context:
A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.

# Question:
If the stand carries watermelons, then which one of the following must be false?

# Options:
A) The stand does not carry figs.
B) The stand does not carry tangerines.
C) The stand does not carry pears.
D) The stand carries pears but not oranges.
E) The stand carries pears but not tangerines.","# Declarations
fruits = EnumSort([figs, kiwis, oranges, pears, tangerines, watermelons])
carries = Function([fruits] -> [bool])
# Constraints
Exists([f:fruits], carries(f)) ::: The stand carries at least one kind of fruit
Implies(carries(kiwis), Not(carries(pears))) ::: If the stand carries kiwis, then it does not carry pears
Implies(Not(carries(tangerines)), carries(kiwis)) ::: If the stand does not carry tangerines, then it carries kiwis
Implies(carries(oranges), And(carries(pears), carries(watermelons))) ::: If the stand carries oranges, then it carries both pears and watermelons
Implies(carries(watermelons), Or(carries(figs), carries(tangerines))) ::: If the stand carries watermelons, then it carries figs or tangerines or both
# Options
is_unsat(Not(carries(figs))) ::: (A)
is_unsat(Not(carries(tangerines))) ::: (B)
is_unsat(Not(carries(pears))) ::: (C)
is_unsat(And(carries(pears), Not(carries(oranges)))) ::: (D)
is_unsat(And(carries(pears), Not(carries(tangerines)))) ::: (E)"
"# Context:
Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.

# Question:
Which one of the following is an acceptable ordering of the files from first to eighth?

# Options:
A) H X O V Z M P T
B) P M Z H X O V T
C) P Z M H O T X V
D) X Z M V H T P O
E) Z M H P O X V T","# Declarations
files = EnumSort([H, M, O, P, V, X, T, Z])
categories = EnumSort([red, green, yellow])
order = Function([files] -> [int])
category = Function([files] -> [categories])
# Constraints
ForAll([f:files], Exists([i:int], order(f) == i)) ::: Each file is ordered from first to eighth
ForAll([f:files], Exists([c:categories], category(f) == c)) ::: Each file falls into exactly one category
order(H) < order(O) ::: H must be placed into some position before O
order(H) != order(O) - 1 ::: H cannot immediately precede O
order(X) < order(V) ::: X must be placed into some position before V
Abs(order(X) - order(V)) == Abs(order(H) - order(O)) ::: X and V must be separated by the same number of files as separate H and O
order(Z) == order(M) - 1 ::: Z must immediately precede M
category(files[0]) != red ::: The first file cannot be a red file
# Options
is_valid(And(order(H) == 1, order(X) == 2, order(O) == 3, order(V) == 4, order(Z) == 5, order(M) == 6, order(P) == 7, order(T) == 8)) ::: (A)
is_valid(And(order(P) == 1, order(M) == 2, order(Z) == 3, order(H) == 4, order(X) == 5, order(O) == 6, order(V) == 7, order(T) == 8)) ::: (B)
is_valid(And(order(P) == 1, order(Z) == 2, order(M) == 3, order(H) == 4, order(O) == 5, order(T) == 6, order(X) == 7, order(V) == 8)) ::: (C)
is_valid(And(order(X) == 1, order(Z) == 2, order(M) == 3, order(V) == 4, order(H) == 5, order(T) == 6, order(P) == 7, order(O) == 8)) ::: (D)
is_valid(And(order(Z) == 1, order(M) == 2, order(H) == 3, order(P) == 4, order(O) == 5, order(X) == 6, order(V) == 7, order(T) == 8)) ::: (E)"
"# Context:
Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.

# Question:
If all three sessions on the first day are attended by one or more Capital employees, then which one of the following must be false?

# Options:
A) Maria and Suki attend a session together on the third day.
B) Suki and Tate attend a session together on the second day.
C) Maria attends a session on hiring on the second day.
D) Suki attends a session on regulations on the third day.
E) Tate attends a session on investing on the first day.","# Declarations
employees = EnumSort([Maria, Suki, Tate])
days = EnumSort([Day1, Day2, Day3])
topics = EnumSort([Hiring, Investing, Regulations])
attends = Function([employees, days, topics] -> [bool])
# Constraints
ForAll([e:employees], Count([d:days, t:topics], attends(e, d, t)) == 2) ::: Each conference participant attends exactly two sessions
ForAll([e:employees, d:days, t:topics], Implies(attends(e, d, t), And(Exists([d1:days], d1 != d), Exists([t1:topics], t1 != t)))) ::: Each session attended by a participant is on a different topic and a different day
ForAll([d:days, t:topics], Implies(t == Investing, And(Not(attends(Maria, d, t)), Not(attends(Suki, d, t))))) ::: Neither Maria nor Suki attends any session on investing
ForAll([t:topics], Not(attends(Tate, Day3, t))) ::: Tate does not attend any session on the third day
ForAll([d:days, t:topics], Count([e:employees], attends(e, d, t)) <= 2) ::: At most two Capital employees attend any given session together
ForAll([t:topics], Exists([e:employees], attends(e, Day1, t))) ::: All three sessions on the first day are attended by one or more Capital employees
# Options
is_unsat(And(attends(Maria, Day3, t), attends(Suki, Day3, t))) ::: (A)
is_unsat(And(attends(Suki, Day2, t), attends(Tate, Day2, t))) ::: (B)
is_unsat(attends(Maria, Day2, Hiring)) ::: (C)
is_unsat(attends(Suki, Day3, Regulations)) ::: (D)
is_unsat(attends(Tate, Day1, Investing)) ::: (E)"
"# Context:
Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.

# Question:
If Moore sits in row 1, then which one of the following must be true?

# Options:
A) Hoffman sits in row 2.
B) Imamura sits in row 2.
C) Imamura sits in row 3.
D) Kelly sits in row 1.
E) Lapas sits in row 3.","# Declarations
passengers = EnumSort([Gutierrez, Hoffman, Imamura, Kelly, Lapas, Moore])
rows = EnumSort([1, 2, 3])
seats = EnumSort([window, aisle])
occupies = Function([passengers] -> [rows])
seat_type = Function([passengers] -> [seats])
# Constraints
ForAll([p:passengers], Exists([r:rows, s:seats], And(occupies(p) == r, seat_type(p) == s))) ::: Each passenger occupies a different seat
ForAll([r:rows], And(Exists([p:passengers], And(occupies(p) == r, seat_type(p) == window)), Exists([p:passengers], And(occupies(p) == r, seat_type(p) == aisle)))) ::: Each row has exactly one window seat and one aisle seat
occupies(Hoffman) == occupies(Gutierrez) + 1 ::: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat
seat_type(Hoffman) == aisle ::: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat
Implies(seat_type(Moore) == aisle, occupies(Hoffman) == occupies(Lapas)) ::: If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas
Implies(occupies(Gutierrez) == occupies(Kelly), occupies(Moore) == occupies(Imamura) + 1) ::: If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat
Implies(seat_type(Kelly) == window, occupies(Moore) == 3) ::: If Kelly occupies a window seat, Moore sits in row 3
Implies(occupies(Kelly) == 3, occupies(Imamura) == 1) ::: If Kelly sits in row 3, Imamura sits in row 1
occupies(Moore) == 1 ::: If Moore sits in row 1
# Options
is_valid(occupies(Hoffman) == 2) ::: (A)
is_valid(occupies(Imamura) == 2) ::: (B)
is_valid(occupies(Imamura) == 3) ::: (C)
is_valid(occupies(Kelly) == 1) ::: (D)
is_valid(occupies(Lapas) == 3) ::: (E)"
"# Context:
A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.

# Question:
If males are assigned to Veblen South, which one of the following is a complete and accurate list of the wings that CANNOT be assigned males?

# Options:
A) Richards North, Tuscarora North
B) Richards North, Tuscarora North, Veblen North
C) Richards North, Tuscarora North, Wisteria South
D) Richards North, Tuscarora North, Veblen North, Wisteria South
E) Richards North, Richards South, Tuscarora North, Veblen North, Wisteria South","# Declarations
dormitories = EnumSort([Richards, Tuscarora, Veblen, Wisteria])
wings = EnumSort([North, South])
gender = EnumSort([Male, Female])
assigned = Function([dormitories, wings] -> [gender])
# Constraints
ForAll([d:dormitories], Or(assigned(d, North) == Male, assigned(d, South) == Male)) ::: Each wing is assigned only male students or only female students
Count([d:dormitories, w:wings], assigned(d, w) == Male) == 3 ::: Exactly three wings have males assigned to them
assigned(Richards, North) == Female ::: Richards North and Tuscarora North are assigned females
assigned(Tuscarora, North) == Female ::: Richards North and Tuscarora North are assigned females
ForAll([d:dormitories], Implies(Or(assigned(d, North) == Male, assigned(d, South) == Male), And(assigned(d, North) == Female, assigned(d, South) == Female))) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
Implies(assigned(Veblen, South) == Male, assigned(Wisteria, North) == Male) ::: If males are assigned to Veblen South, then Wisteria North is assigned males
assigned(Veblen, South) == Male ::: If males are assigned to Veblen South
# Options
is_accurate_list([assigned(Richards, North) != Male, assigned(Tuscarora, North) != Male]) ::: (A)
is_accurate_list([assigned(Richards, North) != Male, assigned(Tuscarora, North) != Male, assigned(Veblen, North) != Male]) ::: (B)
is_accurate_list([assigned(Richards, North) != Male, assigned(Tuscarora, North) != Male, assigned(Wisteria, South) != Male]) ::: (C)
is_accurate_list([assigned(Richards, North) != Male, assigned(Tuscarora, North) != Male, assigned(Veblen, North) != Male, assigned(Wisteria, South) != Male]) ::: (D)
is_accurate_list([assigned(Richards, North) != Male, assigned(Richards, South) != Male, assigned(Tuscarora, North) != Male, assigned(Veblen, North) != Male, assigned(Wisteria, South) != Male]) ::: (E)"
"# Context:
Each of six tasks—harvesting, milling, plowing, spinning, threshing, and weaving—will be demonstrated exactly once at a farm exhibition. No two tasks will be demonstrated concurrently. Three volunteers—Frank, Gladys, and Leslie—will each demonstrate exactly two of the tasks. The tasks must be demonstrated in accordance with the following conditions: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks. Frank performs neither the first nor the last demonstration. Gladys demonstrates neither harvesting nor milling. Leslie demonstrates neither harvesting nor threshing. Milling is the next task demonstrated after threshing is demonstrated.

# Question:
Which one of the following is an acceptable list of the volunteers and the tasks each demonstrates, in order from the first to the last demonstration?

# Options:
A) Frank: weaving; Gladys: threshing; Leslie: milling; Leslie: spinning; Frank: harvesting; Gladys: plowing
B) Leslie: plowing; Frank: harvesting; Frank: threshing; Leslie: milling; Gladys: spinning; Gladys: weaving
C) Leslie: plowing; Frank: spinning; Gladys: threshing; Leslie: milling; Frank: harvesting; Gladys: weaving
D) Leslie: spinning; Leslie: weaving; Frank: plowing; Gladys: harvesting; Frank: threshing; Gladys: milling
E) Leslie: weaving; Frank: threshing; Gladys: spinning; Leslie: milling; Frank: harvesting; Gladys: plowing","# Declarations
tasks = EnumSort([harvesting, milling, plowing, spinning, threshing, weaving])
volunteers = EnumSort([Frank, Gladys, Leslie])
demonstrated_by = Function([tasks] -> [volunteers])
demonstration_order = Function([tasks] -> [int])
# Constraints
ForAll([t:tasks], Exists([v:volunteers], demonstrated_by(t) == v)) ::: Each task is demonstrated by exactly one volunteer
ForAll([v:volunteers], Count([t:tasks], demonstrated_by(t) == v) == 2) ::: Each volunteer demonstrates exactly two tasks
ForAll([t1:tasks, t2:tasks], Implies(demonstration_order(t1) < demonstration_order(t2), demonstration_order(t1) != demonstration_order(t2))) ::: No two tasks are demonstrated concurrently
Exists([t:tasks], And(demonstrated_by(t) == Frank, ForAll([t2:tasks], Implies(demonstrated_by(t2) == Gladys, demonstration_order(t) < demonstration_order(t2))))) ::: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks
ForAll([t:tasks], Not(And(demonstrated_by(t) == Frank, Or(demonstration_order(t) == 1, demonstration_order(t) == 6)))) ::: Frank performs neither the first nor the last demonstration
ForAll([t:tasks], Not(And(demonstrated_by(t) == Gladys, Or(t == harvesting, t == milling)))) ::: Gladys demonstrates neither harvesting nor milling
ForAll([t:tasks], Not(And(demonstrated_by(t) == Leslie, Or(t == harvesting, t == threshing)))) ::: Leslie demonstrates neither harvesting nor threshing
Exists([t:tasks], And(t == threshing, Exists([t2:tasks], And(t2 == milling, demonstration_order(t2) == demonstration_order(t) + 1)))) ::: Milling is the next task demonstrated after threshing is demonstrated
# Options
is_accurate_list([demonstrated_by(weaving) == Frank, demonstrated_by(threshing) == Gladys, demonstrated_by(milling) == Leslie, demonstrated_by(spinning) == Leslie, demonstrated_by(harvesting) == Frank, demonstrated_by(plowing) == Gladys]) ::: (A)
is_accurate_list([demonstrated_by(plowing) == Leslie, demonstrated_by(harvesting) == Frank, demonstrated_by(threshing) == Frank, demonstrated_by(milling) == Leslie, demonstrated_by(spinning) == Gladys, demonstrated_by(weaving) == Gladys]) ::: (B)
is_accurate_list([demonstrated_by(plowing) == Leslie, demonstrated_by(spinning) == Frank, demonstrated_by(threshing) == Gladys, demonstrated_by(milling) == Leslie, demonstrated_by(harvesting) == Frank, demonstrated_by(weaving) == Gladys]) ::: (C)
is_accurate_list([demonstrated_by(spinning) == Leslie, demonstrated_by(weaving) == Leslie, demonstrated_by(plowing) == Frank, demonstrated_by(harvesting) == Gladys, demonstrated_by(threshing) == Frank, demonstrated_by(milling) == Gladys]) ::: (D)
is_accurate_list([demonstrated_by(weaving) == Leslie, demonstrated_by(threshing) == Frank, demonstrated_by(spinning) == Gladys, demonstrated_by(milling) == Leslie, demonstrated_by(harvesting) == Frank, demonstrated_by(plowing) == Gladys]) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
At most how many pairs of cities could be connected?

# Options:
A) four
B) five
C) six
D) seven
E) eight","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
# Options
is_valid(Count([c1:cities, c2:cities], And(c1 != c2, connected(c1, c2))) == 4) ::: (A)
is_valid(Count([c1:cities, c2:cities], And(c1 != c2, connected(c1, c2))) == 5) ::: (B)
is_valid(Count([c1:cities, c2:cities], And(c1 != c2, connected(c1, c2))) == 6) ::: (C)
is_valid(Count([c1:cities, c2:cities], And(c1 != c2, connected(c1, c2))) == 7) ::: (D)
is_valid(Count([c1:cities, c2:cities], And(c1 != c2, connected(c1, c2))) == 8) ::: (E)"
"# Context:
A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.

# Question:
If the stand carries no watermelons, then which one of the following must be true?

# Options:
A) The stand carries kiwis.
B) The stand carries at least two kinds of fruit.
C) The stand carries at most three kinds of fruit.
D) The stand carries neither oranges nor pears.
E) The stand carries neither oranges nor kiwis.","# Declarations
fruits = EnumSort([figs, kiwis, oranges, pears, tangerines, watermelons])
carries = Function([fruits] -> [bool])
# Constraints
Exists([f:fruits], carries(f)) ::: The stand carries at least one kind of fruit
Implies(carries(kiwis), Not(carries(pears))) ::: If the stand carries kiwis, then it does not carry pears
Implies(Not(carries(tangerines)), carries(kiwis)) ::: If the stand does not carry tangerines, then it carries kiwis
Implies(carries(oranges), And(carries(pears), carries(watermelons))) ::: If the stand carries oranges, then it carries both pears and watermelons
Implies(carries(watermelons), Or(carries(figs), carries(tangerines))) ::: If the stand carries watermelons, then it carries figs or tangerines or both
Not(carries(watermelons)) ::: The stand carries no watermelons
# Options
is_valid(carries(kiwis)) ::: (A)
is_valid(Count([f:fruits], carries(f)) >= 2) ::: (B)
is_valid(Count([f:fruits], carries(f)) <= 3) ::: (C)
is_valid(And(Not(carries(oranges)), Not(carries(pears)))) ::: (D)
is_valid(And(Not(carries(oranges)), Not(carries(kiwis)))) ::: (E)"
"# Context:
A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.

# Question:
Which one of the following could be an accurate matching of the bookshelves to the books on each of them?

# Options:
A) first shelf: Hausa grammar second shelf: semantics monograph, Vonnegut novel third shelf: Farsi grammar, phonology monograph, Woolf novel
B) first shelf: semantics monograph second shelf: Farsi grammar, Vonnegut novel third shelf: Hausa grammar, phonology monograph, Woolf novel
C) first shelf: Vonnegut novel second shelf: phonology monograph, Farsi grammar third shelf: Hausa grammar, semantics monograph, Woolf novel
D) first shelf: Woolf novel second shelf: phonology and semantics monographs third shelf: Farsi and Hausa grammars, Vonnegut novel
E) first shelf: Woolf novel second shelf: Farsi grammar, Vonnegut novel third shelf: Hausa grammar, phonology and semantics monographs","# Declarations
books = EnumSort([Farsi_grammar, Hausa_grammar, phonology_monograph, semantics_monograph, Vonnegut_novel, Woolf_novel])
shelves = EnumSort([first_shelf, second_shelf, third_shelf])
placed = Function([books] -> [shelves])
# Constraints
Count([b:books], placed(b) == first_shelf) == 1 ::: one book on the first shelf
Count([b:books], placed(b) == second_shelf) == 2 ::: two books on the second shelf
Count([b:books], placed(b) == third_shelf) == 3 ::: three books on the third shelf
Exists([b:books], And(b == Vonnegut_novel, placed(b) == placed(Farsi_grammar))) ::: There is at least one novel on the same shelf as the Farsi grammar
placed(phonology_monograph) != placed(semantics_monograph) ::: The monographs are not both on the same shelf
placed(Vonnegut_novel) != placed(phonology_monograph) ::: The Vonnegut novel is not on the same shelf as the phonology monograph
placed(Vonnegut_novel) != placed(semantics_monograph) ::: The Vonnegut novel is not on the same shelf as the semantics monograph
# Options
is_accurate_list([placed(Hausa_grammar) == first_shelf, placed(semantics_monograph) == second_shelf, placed(Vonnegut_novel) == second_shelf, placed(Farsi_grammar) == third_shelf, placed(phonology_monograph) == third_shelf, placed(Woolf_novel) == third_shelf]) ::: (A)
is_accurate_list([placed(semantics_monograph) == first_shelf, placed(Farsi_grammar) == second_shelf, placed(Vonnegut_novel) == second_shelf, placed(Hausa_grammar) == third_shelf, placed(phonology_monograph) == third_shelf, placed(Woolf_novel) == third_shelf]) ::: (B)
is_accurate_list([placed(Vonnegut_novel) == first_shelf, placed(phonology_monograph) == second_shelf, placed(Farsi_grammar) == second_shelf, placed(Hausa_grammar) == third_shelf, placed(semantics_monograph) == third_shelf, placed(Woolf_novel) == third_shelf]) ::: (C)
is_accurate_list([placed(Woolf_novel) == first_shelf, placed(phonology_monograph) == second_shelf, placed(semantics_monograph) == second_shelf, placed(Farsi_grammar) == third_shelf, placed(Hausa_grammar) == third_shelf, placed(Vonnegut_novel) == third_shelf]) ::: (D)
is_accurate_list([placed(Woolf_novel) == first_shelf, placed(Farsi_grammar) == second_shelf, placed(Vonnegut_novel) == second_shelf, placed(Hausa_grammar) == third_shelf, placed(phonology_monograph) == third_shelf, placed(semantics_monograph) == third_shelf]) ::: (E)"
"# Context:
Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.

# Question:
If Zoe was born before Uma was born, then which one of the following statements must be false?

# Options:
A) No child was born in 1992.
B) No child was born in 1995.
C) Theo is left-handed.
D) Zoe is left-handed.
E) Will is left-handed.","# Declarations
children = EnumSort([Sara, Theo, Uma, Will, Zoe])
handedness = EnumSort([left, right])
years = EnumSort([1990, 1991, 1992, 1993, 1994, 1995, 1996])
handed = Function([children] -> [handedness])
born_in = Function([children] -> [years])
# Constraints
Count([c:children], handed(c) == left) == 3 ::: three are left-handed
Count([c:children], handed(c) == right) == 2 ::: two are right-handed
ForAll([c1:children, c2:children], Implies(And(handed(c1) == left, handed(c2) == left, c1 != c2), Abs(born_in(c1) - born_in(c2)) > 1)) ::: No two left-handed children were born in consecutive years
ForAll([c1:children, c2:children], Implies(And(handed(c1) == right, handed(c2) == right, c1 != c2), Abs(born_in(c1) - born_in(c2)) > 1)) ::: No two right-handed children were born in consecutive years
born_in(Sara) < born_in(Uma) ::: Sara, who is left-handed, was born before Uma
born_in(Zoe) < born_in(Theo) ::: Zoe was born before both Theo and Will
born_in(Zoe) < born_in(Will) ::: Zoe was born before both Theo and Will
Exists([c:children], And(handed(c) == left, born_in(c) == 1991)) ::: A left-handed child was born in 1991
born_in(Uma) == 1993 ::: Uma, who is right-handed, was born in 1993
handed(Uma) == right ::: Uma, who is right-handed, was born in 1993
born_in(Zoe) < born_in(Uma) ::: If Zoe was born before Uma was born
# Options
is_unsat(ForAll([c:children], born_in(c) != 1992)) ::: (A)
is_unsat(ForAll([c:children], born_in(c) != 1995)) ::: (B)
is_unsat(handed(Theo) == left) ::: (C)
is_unsat(handed(Zoe) == left) ::: (D)
is_unsat(handed(Will) == left) ::: (E)"
"# Context:
Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.

# Question:
Which one of the following could be a complete and accurate matching of the applicants with the departments in which they were hired?

# Options:
A) management: Weiss; production: Feng, Herrera, Yates; sales: Garcia, Ilias, Xavier
B) management: Weiss; production: Garcia, Ilias, Xavier; sales: Feng, Herrera, Yates
C) management: Xavier; production: Feng, Garcia, Herrera; sales: Ilias, Yates, Weiss
D) management: Xavier; production: Feng, Herrera, Ilias; sales: Garcia, Weiss, Yates
E) management: Xavier; production: Feng, Ilias, Weiss; sales: Garcia, Herrera, Yates","# Declarations
applicants = EnumSort([Feng, Garcia, Herrera, Ilias, Weiss, Xavier, Yates])
departments = EnumSort([management, production, sales])
hired = Function([applicants] -> [departments])
# Constraints
Count([a:applicants], hired(a) == management) == 1 ::: One position is in the management department
Count([a:applicants], hired(a) == production) == 3 ::: Three positions are in the production department
Count([a:applicants], hired(a) == sales) == 3 ::: Three positions are in the sales department
hired(Herrera) == hired(Yates) ::: Herrera is hired for a position in the same department as Yates
hired(Feng) != hired(Garcia) ::: Feng is hired for a position in a different department from Garcia
Implies(hired(Xavier) == sales, hired(Weiss) == production) ::: If Xavier is hired for a sales position, then Weiss is hired for a production position
hired(Feng) == production ::: Feng is hired for a production position
# Options
is_accurate_list([hired(Weiss) == management, hired(Feng) == production, hired(Herrera) == production, hired(Yates) == production, hired(Garcia) == sales, hired(Ilias) == sales, hired(Xavier) == sales]) ::: (A)
is_accurate_list([hired(Weiss) == management, hired(Garcia) == production, hired(Ilias) == production, hired(Xavier) == production, hired(Feng) == sales, hired(Herrera) == sales, hired(Yates) == sales]) ::: (B)
is_accurate_list([hired(Xavier) == management, hired(Feng) == production, hired(Garcia) == production, hired(Herrera) == production, hired(Ilias) == sales, hired(Yates) == sales, hired(Weiss) == sales]) ::: (C)
is_accurate_list([hired(Xavier) == management, hired(Feng) == production, hired(Herrera) == production, hired(Ilias) == production, hired(Garcia) == sales, hired(Weiss) == sales, hired(Yates) == sales]) ::: (D)
is_accurate_list([hired(Xavier) == management, hired(Feng) == production, hired(Ilias) == production, hired(Weiss) == production, hired(Garcia) == sales, hired(Herrera) == sales, hired(Yates) == sales]) ::: (E)"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
Which one of the following could be true?

# Options:
A) Both Hilltop and Island have a garden.
B) Both Hilltop and Island have a playground.
C) Both Hilltop and Island have a theater.
D) Both Island and Jessup have a fountain.
E) Both Island and Jessup have a garden.","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks, attractions] -> [bool])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p, a))) ::: Each park has at least one attraction
ForAll([a:attractions], Exists([p:parks], has_attraction(p, a))) ::: At least one of each type of attraction is included
ForAll([p:parks, a:attractions], Implies(has_attraction(p, a), ForAll([p2:parks], Implies(p2 != p, Not(has_attraction(p2, a)))))) ::: No two attractions of the same type are included in any park
Count([p:parks], Exists([a:attractions], And(a == garden, has_attraction(p, a)))) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup, museum) ::: Jessup has a museum
Not(has_attraction(Jessup, theater)) ::: Jessup does not have a theater
Count([a:attractions], has_attraction(Island, a)) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(Or(has_attraction(p, playground), has_attraction(p, fountain)), Not(And(has_attraction(p, playground), has_attraction(p, fountain))))) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p, theater), has_attraction(p, garden))) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p, museum), has_attraction(p, playground))) ::: Each park that has a museum also has a playground
# Options
is_sat(And(has_attraction(Hilltop, garden), has_attraction(Island, garden))) ::: (A)
is_sat(And(has_attraction(Hilltop, playground), has_attraction(Island, playground))) ::: (B)
is_sat(And(has_attraction(Hilltop, theater), has_attraction(Island, theater))) ::: (C)
is_sat(And(has_attraction(Island, fountain), has_attraction(Jessup, fountain))) ::: (D)
is_sat(And(has_attraction(Island, garden), has_attraction(Jessup, garden))) ::: (E)"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
If V gets out of the car at some time before Z does, then which one of the following could be true?

# Options:
A) R is the second clown to get out of the car.
B) T is the fourth clown to get out of the car.
C) Q is the fourth clown to get out of the car.
D) V is the fifth clown to get out of the car.
E) Z is the sixth clown to get out of the car.","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
order(V) < order(Z) ::: If V gets out of the car at some time before Z does
# Options
is_valid(order(R) == 2) ::: (A)
is_valid(order(T) == 4) ::: (B)
is_valid(order(Q) == 4) ::: (C)
is_valid(order(V) == 5) ::: (D)
is_valid(order(Z) == 6) ::: (E)"
"# Context:
A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.

# Question:
If Jacobson swims lap 8, then for exactly how many of the ten laps can one determine which team member swims the lap?

# Options:
A) ten
B) eight
C) six
D) four
E) two","# Declarations
members = EnumSort([Jacobson, Kruger, Lu, Miller, Ortiz])
laps = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
swims = Function([members] -> [laps])
# Constraints
ForAll([m:members], Count([l:laps], swims(m) == l) == 2) ::: Each team member swims exactly two laps
ForAll([m:members], Or(And(swims(m) == 1, swims(m) == 6), And(swims(m) == 2, swims(m) == 7), And(swims(m) == 3, swims(m) == 8), And(swims(m) == 4, swims(m) == 9), And(swims(m) == 5, swims(m) == 10))) ::: Each team member swims specific laps
ForAll([l:laps], Count([m:members], swims(m) == l) == 1) ::: Each lap is swum by exactly one member
ForAll([l:laps], Implies(swims(Kruger) == l, And(swims(Lu) != l - 1, swims(Lu) != l + 1))) ::: Neither of Kruger's laps is immediately before either of Lu's
swims(Jacobson) != 9 ::: Jacobson does not swim lap 9
Exists([l:laps], And(swims(Miller) == l, swims(Ortiz) > l)) ::: Ortiz's first lap is after (but not necessarily immediately after) Miller's
Exists([l:laps], And(swims(Ortiz) == l, swims(Jacobson) == l + 1)) ::: At least one of Jacobson's laps is immediately after one of Ortiz's laps
swims(Jacobson) == 8 ::: Jacobson swims lap 8
# Options
is_accurate_list([swims(Jacobson) == 8, swims(Kruger) == 1, swims(Kruger) == 6, swims(Lu) == 2, swims(Lu) == 7, swims(Miller) == 3, swims(Miller) == 8, swims(Ortiz) == 4, swims(Ortiz) == 9]) ::: (A)
is_accurate_list([swims(Jacobson) == 8, swims(Kruger) == 1, swims(Kruger) == 6, swims(Lu) == 2, swims(Lu) == 7, swims(Miller) == 3, swims(Miller) == 8, swims(Ortiz) == 4, swims(Ortiz) == 9]) ::: (B)
is_accurate_list([swims(Jacobson) == 8, swims(Kruger) == 1, swims(Kruger) == 6, swims(Lu) == 2, swims(Lu) == 7, swims(Miller) == 3, swims(Miller) == 8, swims(Ortiz) == 4, swims(Ortiz) == 9]) ::: (C)
is_accurate_list([swims(Jacobson) == 8, swims(Kruger) == 1, swims(Kruger) == 6, swims(Lu) == 2, swims(Lu) == 7, swims(Miller) == 3, swims(Miller) == 8, swims(Ortiz) == 4, swims(Ortiz) == 9]) ::: (D)
is_accurate_list([swims(Jacobson) == 8, swims(Kruger) == 1, swims(Kruger) == 6, swims(Lu) == 2, swims(Lu) == 7, swims(Miller) == 3, swims(Miller) == 8, swims(Ortiz) == 4, swims(Ortiz) == 9]) ::: (E)"
"# Context:
Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.

# Question:
Which one of the following is a complete and accurate list of aisles, any one of which could be one of the aisles Manny stocks?

# Options:
A) 1, 3, 4, 5
B) 3, 5, 7, 9
C) 3, 4, 5, 6
D) 3, 4, 5, 6, 7
E) 3, 5, 7","# Declarations
clerks = EnumSort([Jill, Kurt, Larisa, Manny, Olga])
aisles = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
stocks = Function([clerks] -> [aisles])
# Constraints
ForAll([c:clerks], Count([a:aisles], stocks(c) == a) <= 2) ::: no clerk stocks more than two aisles
Count([a:aisles], stocks(Olga) == a) == 1 ::: Olga stocks exactly one aisle
stocks(Kurt) == 2 ::: Kurt stocks aisle 2
stocks(Manny) != 1 ::: Manny does not stock aisle 1
ForAll([a:aisles], Implies(stocks(Jill) == a, And(a != 1, a != 9, stocks(Jill) != a + 1, stocks(Jill) != a - 1))) ::: Jill does not stock consecutive aisles
Exists([a:aisles], And(stocks(Manny) == a, stocks(Kurt) == a + 1, stocks(Manny) == a + 2)) ::: Kurt stocks the only aisle between the two aisles Manny stocks
Exists([a:aisles], And(stocks(Larisa) == a, Or(a == 1, a == 9))) ::: Exactly one of Larisa's aisles is an end aisle
ForAll([a:aisles], Implies(stocks(Olga) == a, And(a > 2, Exists([b:aisles], And(stocks(Larisa) == b, a < b))))) ::: Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's
# Options
is_accurate_list([stocks(Manny) == 1, stocks(Manny) == 3, stocks(Manny) == 4, stocks(Manny) == 5]) ::: (A)
is_accurate_list([stocks(Manny) == 3, stocks(Manny) == 5, stocks(Manny) == 7, stocks(Manny) == 9]) ::: (B)
is_accurate_list([stocks(Manny) == 3, stocks(Manny) == 4, stocks(Manny) == 5, stocks(Manny) == 6]) ::: (C)
is_accurate_list([stocks(Manny) == 3, stocks(Manny) == 4, stocks(Manny) == 5, stocks(Manny) == 6, stocks(Manny) == 7]) ::: (D)
is_accurate_list([stocks(Manny) == 3, stocks(Manny) == 5, stocks(Manny) == 7]) ::: (E)"
"# Context:
A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.

# Question:
If Wisteria North is assigned females, then females must also be assigned to which one of the following?

# Options:
A) Richards South
B) Wisteria South
C) Tuscarora South
D) Veblen South
E) Veblen North","# Declarations
dormitories = EnumSort([Richards, Tuscarora, Veblen, Wisteria])
wings = EnumSort([North, South])
gender = EnumSort([Male, Female])
assigned = Function([dormitories, wings] -> [gender])
# Constraints
ForAll([d:dormitories, w:wings], Or(assigned(d, w) == Male, assigned(d, w) == Female)) ::: Each wing is assigned only male students or only female students
Count([d:dormitories, w:wings], assigned(d, w) == Male) == 3 ::: Exactly three wings have males assigned to them
assigned(Richards, North) == Female ::: Richards North and Tuscarora North are assigned females
assigned(Tuscarora, North) == Female ::: Richards North and Tuscarora North are assigned females
ForAll([d:dormitories], Implies(assigned(d, North) == Male, assigned(d, South) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
ForAll([d:dormitories], Implies(assigned(d, South) == Male, assigned(d, North) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
Implies(assigned(Veblen, South) == Male, assigned(Wisteria, North) == Male) ::: If males are assigned to Veblen South, then Wisteria North is assigned males
assigned(Wisteria, North) == Female ::: If Wisteria North is assigned females
# Options
is_valid(assigned(Richards, South) == Female) ::: (A)
is_valid(assigned(Wisteria, South) == Female) ::: (B)
is_valid(assigned(Tuscarora, South) == Female) ::: (C)
is_valid(assigned(Veblen, South) == Female) ::: (D)
is_valid(assigned(Veblen, North) == Female) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
If Toronto is the only city that is connected with Philadelphia, then which one of the following could be true?

# Options:
A) Exactly one city is connected with Toronto.
B) Exactly one city is connected with Vancouver.
C) Exactly two cities are each connected with Honolulu.
D) Exactly two cities are each connected with Toronto.
E) Exactly four cities are each connected with Toronto.","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
ForAll([c:cities], Implies(c != Toronto, Not(connected(Philadelphia, c)))) ::: Toronto is the only city that is connected with Philadelphia
# Options
is_valid(Count([c:cities], connected(Toronto, c)) == 1) ::: (A)
is_valid(Count([c:cities], connected(Vancouver, c)) == 1) ::: (B)
is_valid(Count([c:cities], connected(Honolulu, c)) == 2) ::: (C)
is_valid(Count([c:cities], connected(Toronto, c)) == 2) ::: (D)
is_valid(Count([c:cities], connected(Toronto, c)) == 4) ::: (E)"
"# Context:
A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.

# Question:
Which one of the following CANNOT be a complete and accurate list of the kinds of fruit the stand carries?

# Options:
A) kiwis, tangerines
B) tangerines, watermelons
C) figs, kiwis, watermelons
D) oranges, pears, tangerines, watermelons
E) figs, kiwis, oranges, pears, watermelons","# Declarations
fruits = EnumSort([figs, kiwis, oranges, pears, tangerines, watermelons])
carries = Function([fruits] -> [bool])
# Constraints
Exists([f:fruits], carries(f)) ::: The stand carries at least one kind of fruit
ForAll([f:fruits], Implies(carries(kiwis), Not(carries(pears)))) ::: If the stand carries kiwis, then it does not carry pears
ForAll([f:fruits], Implies(Not(carries(tangerines)), carries(kiwis))) ::: If the stand does not carry tangerines, then it carries kiwis
ForAll([f:fruits], Implies(carries(oranges), And(carries(pears), carries(watermelons)))) ::: If the stand carries oranges, then it carries both pears and watermelons
ForAll([f:fruits], Implies(carries(watermelons), Or(carries(figs), carries(tangerines)))) ::: If the stand carries watermelons, then it carries figs or tangerines or both
# Options
is_unsat(And(carries(kiwis), carries(tangerines))) ::: (A)
is_unsat(And(carries(tangerines), carries(watermelons))) ::: (B)
is_unsat(And(carries(figs), carries(kiwis), carries(watermelons))) ::: (C)
is_unsat(And(carries(oranges), carries(pears), carries(tangerines), carries(watermelons))) ::: (D)
is_unsat(And(carries(figs), carries(kiwis), carries(oranges), carries(pears), carries(watermelons))) ::: (E)"
"# Context:
Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.

# Question:
If the zucchini is added first, then which one of the following CANNOT be true?

# Options:
A) The kale is added second.
B) The tomatoes are added second.
C) The lentils are added third.
D) The lentils are added fourth.
E) The onions are added fourth.","# Declarations
foods = EnumSort([kale, lentils, mushrooms, onions, tomatoes, zucchini])
order = Function([foods] -> [int])
# Constraints
ForAll([f:foods], Exists([f1:foods], order(f1) == order(f))) ::: No food is added more than once
Implies(order(mushrooms) == 3, order(lentils) == 6) ::: If the mushrooms are added third, then the lentils are added last
Implies(order(zucchini) == 1, Exists([f:foods], And(order(lentils) < order(onions), order(lentils) != 6))) ::: If the zucchini is added first, then the lentils are added at some time before the onions
And(order(tomatoes) != 5, order(kale) != 5) ::: Neither the tomatoes nor the kale is added fifth
Exists([f:foods], And(order(mushrooms) < order(tomatoes), order(mushrooms) < order(kale), order(mushrooms) != 1)) ::: The mushrooms are added at some time before the tomatoes or the kale, but not before both
order(zucchini) == 1 ::: If the zucchini is added first
# Options
is_unsat(order(kale) == 2) ::: (A)
is_unsat(order(tomatoes) == 2) ::: (B)
is_unsat(order(lentils) == 3) ::: (C)
is_unsat(order(lentils) == 4) ::: (D)
is_unsat(order(onions) == 4) ::: (E)"
"# Context:
A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.

# Question:
Which one of the following could be the only kind of fruit the stand carries?

# Options:
A) figs
B) oranges
C) pears
D) tangerines
E) watermelons","# Declarations
fruits = EnumSort([figs, kiwis, oranges, pears, tangerines, watermelons])
carries = Function([fruits] -> [bool])
# Constraints
Exists([f:fruits], carries(f)) ::: The stand carries at least one kind of fruit
ForAll([f:fruits], Implies(carries(kiwis), Not(carries(pears)))) ::: If the stand carries kiwis, then it does not carry pears
ForAll([f:fruits], Implies(Not(carries(tangerines)), carries(kiwis))) ::: If the stand does not carry tangerines, then it carries kiwis
ForAll([f:fruits], Implies(carries(oranges), And(carries(pears), carries(watermelons)))) ::: If the stand carries oranges, then it carries both pears and watermelons
ForAll([f:fruits], Implies(carries(watermelons), Or(carries(figs), carries(tangerines)))) ::: If the stand carries watermelons, then it carries figs or tangerines or both
# Options
is_sat(ForAll([f:fruits], Implies(f != figs, Not(carries(f))))) ::: (A)
is_sat(ForAll([f:fruits], Implies(f != oranges, Not(carries(f))))) ::: (B)
is_sat(ForAll([f:fruits], Implies(f != pears, Not(carries(f))))) ::: (C)
is_sat(ForAll([f:fruits], Implies(f != tangerines, Not(carries(f))))) ::: (D)
is_sat(ForAll([f:fruits], Implies(f != watermelons, Not(carries(f))))) ::: (E)"
"# Context:
In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.

# Question:
Which one of the following pairs of trucks CANNOT arrive consecutively at the warehouse?

# Options:
A) U and Y
B) X and Y
C) Y and T
D) Y and W
E) Y and Z","# Declarations
trucks = EnumSort([S, T, U, W, X, Y, Z])
colors = EnumSort([green, red])
arrival_order = Function([trucks] -> [int])
truck_color = Function([trucks] -> [colors])
# Constraints
ForAll([t:trucks], arrival_order(t) >= 1) ::: Each truck arrives at some time
ForAll([t:trucks], arrival_order(t) <= 7) ::: Each truck arrives at some time
ForAll([t1:trucks, t2:trucks], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: No truck arrives at the same time as any other truck
ForAll([t:trucks], Or(truck_color(t) == green, truck_color(t) == red)) ::: Each truck is either green or red
ForAll([t1:trucks, t2:trucks], Implies(And(arrival_order(t1) + 1 == arrival_order(t2), truck_color(t1) == red), truck_color(t2) != red)) ::: No two consecutive arrivals are red
arrival_order(Y) < arrival_order(T) ::: Y arrives at some time before T
arrival_order(Y) < arrival_order(W) ::: Y arrives at some time before W
Count([t:trucks], And(arrival_order(t) < arrival_order(Y), truck_color(t) == red)) == 2 ::: Exactly two of the trucks that arrive before Y are red
arrival_order(S) == 6 ::: S is the sixth arrival
arrival_order(Z) < arrival_order(U) ::: Z arrives at some time before U
# Options
is_unsat(And(arrival_order(U) + 1 == arrival_order(Y), arrival_order(Y) + 1 == arrival_order(U))) ::: (A)
is_unsat(And(arrival_order(X) + 1 == arrival_order(Y), arrival_order(Y) + 1 == arrival_order(X))) ::: (B)
is_unsat(And(arrival_order(Y) + 1 == arrival_order(T), arrival_order(T) + 1 == arrival_order(Y))) ::: (C)
is_unsat(And(arrival_order(Y) + 1 == arrival_order(W), arrival_order(W) + 1 == arrival_order(Y))) ::: (D)
is_unsat(And(arrival_order(Y) + 1 == arrival_order(Z), arrival_order(Z) + 1 == arrival_order(Y))) ::: (E)"
"# Context:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.

# Question:
Which one of the following could be the order in which the trains arrive, from first to last?

# Options:
A) Rockville, Tilbury, Victoria, Wooster, Sunnydale, York, Quigley
B) Rockville, Wooster, Quigley, York, Tilbury, Sunnydale, Victoria
C) Rockville, Tilbury, Quigley, Wooster, Sunnydale, York, Victoria
D) Quigley, Rockville, Wooster, Sunnydale, Victoria, York, Tilbury
E) Tilbury, Rockville, Quigley, Wooster, Sunnydale, York, Victoria","# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrival_order = Function([trains] -> [int])
# Constraints
ForAll([t1:trains, t2:trains], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: The trains arrive one at a time
Or(arrival_order(York) == 4, arrival_order(Wooster) == 4) ::: Either the York or the Wooster arrives fourth
arrival_order(Sunnydale) > arrival_order(Wooster) ::: The Sunnydale arrives at some time after the Wooster
arrival_order(Sunnydale) < arrival_order(York) ::: The Sunnydale arrives at some time before the York
arrival_order(Tilbury) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
arrival_order(Victoria) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
Not(arrival_order(Tilbury) == arrival_order(Victoria) + 1) ::: The Tilbury does not arrive next after the Victoria
Not(arrival_order(Victoria) == arrival_order(Tilbury) + 1) ::: The Victoria does not arrive next after the Tilbury
# Options
is_sat(And(arrival_order(Rockville) == 1, arrival_order(Tilbury) == 2, arrival_order(Victoria) == 3, arrival_order(Wooster) == 4, arrival_order(Sunnydale) == 5, arrival_order(York) == 6, arrival_order(Quigley) == 7)) ::: (A)
is_sat(And(arrival_order(Rockville) == 1, arrival_order(Wooster) == 2, arrival_order(Quigley) == 3, arrival_order(York) == 4, arrival_order(Tilbury) == 5, arrival_order(Sunnydale) == 6, arrival_order(Victoria) == 7)) ::: (B)
is_sat(And(arrival_order(Rockville) == 1, arrival_order(Tilbury) == 2, arrival_order(Quigley) == 3, arrival_order(Wooster) == 4, arrival_order(Sunnydale) == 5, arrival_order(York) == 6, arrival_order(Victoria) == 7)) ::: (C)
is_sat(And(arrival_order(Quigley) == 1, arrival_order(Rockville) == 2, arrival_order(Wooster) == 3, arrival_order(Sunnydale) == 4, arrival_order(Victoria) == 5, arrival_order(York) == 6, arrival_order(Tilbury) == 7)) ::: (D)
is_sat(And(arrival_order(Tilbury) == 1, arrival_order(Rockville) == 2, arrival_order(Quigley) == 3, arrival_order(Wooster) == 4, arrival_order(Sunnydale) == 5, arrival_order(York) == 6, arrival_order(Victoria) == 7)) ::: (E)"
"# Context:
Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.

# Question:
If Theo is right-handed, then each of the following statements must be false EXCEPT:

# Options:
A) Theo was born in 1996.
B) Will was born in 1995.
C) Uma was born exactly three years before Theo was born.
D) Zoe was born exactly one year before Theo was born.
E) Will is right-handed.","# Declarations
children = EnumSort([Sara, Theo, Uma, Will, Zoe])
hand_types = EnumSort([left_handed, right_handed])
years = EnumSort([1990, 1991, 1992, 1993, 1994, 1995, 1996])
handedness = Function([children] -> [hand_types])
birth_year = Function([children] -> [years])
# Constraints
Count([c:children], handedness(c) == left_handed) == 3 ::: three are left-handed
Count([c:children], handedness(c) == right_handed) == 2 ::: two are right-handed
ForAll([c1:children, c2:children], Implies(And(handedness(c1) == left_handed, handedness(c2) == left_handed, c1 != c2), Abs(birth_year(c1) - birth_year(c2)) != 1)) ::: No two left-handed children were born in consecutive years
ForAll([c1:children, c2:children], Implies(And(handedness(c1) == right_handed, handedness(c2) == right_handed, c1 != c2), Abs(birth_year(c1) - birth_year(c2)) != 1)) ::: No two right-handed children were born in consecutive years
handedness(Sara) == left_handed ::: Sara, who is left-handed
birth_year(Sara) < birth_year(Uma) ::: Sara was born before Uma
birth_year(Zoe) < birth_year(Theo) ::: Zoe was born before both Theo and Will
birth_year(Zoe) < birth_year(Will) ::: Zoe was born before both Theo and Will
Exists([c:children], And(handedness(c) == left_handed, birth_year(c) == 1991)) ::: A left-handed child was born in 1991
handedness(Uma) == right_handed ::: Uma, who is right-handed
birth_year(Uma) == 1993 ::: Uma was born in 1993
handedness(Theo) == right_handed ::: If Theo is right-handed
# Options
is_valid(birth_year(Theo) == 1996) ::: (A)
is_valid(birth_year(Will) == 1995) ::: (B)
is_valid(birth_year(Uma) == birth_year(Theo) - 3) ::: (C)
is_valid(birth_year(Zoe) == birth_year(Theo) - 1) ::: (D)
is_valid(handedness(Will) == right_handed) ::: (E)"
"# Context:
Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.

# Question:
Each of the following is possible EXCEPT:

# Options:
A) Every session attended by at least one Capital employee is attended by exactly one Capital employee.
B) Every session attended by at least one Capital employee is attended by exactly two Capital employees.
C) Every session attended by Maria is also attended by Suki.
D) Every session attended by Suki is also attended by Tate.
E) Every session attended by Tate is also attended by Maria.","# Declarations
employees = EnumSort([Maria, Suki, Tate])
days = EnumSort([Day1, Day2, Day3])
topics = EnumSort([Hiring, Investing, Regulations])
attends = Function([employees, days, topics] -> [bool])
# Constraints
ForAll([e:employees], Count([d:days, t:topics], attends(e, d, t)) == 2) ::: Each conference participant attends exactly two sessions
ForAll([e:employees, d:days, t:topics], Implies(attends(e, d, t), And(Exists([d1:days], d1 != d), Exists([t1:topics], t1 != t)))) ::: Each session attended by a participant is on different topics and different days
ForAll([d:days, t:topics], Implies(t == Investing, And(Not(attends(Maria, d, t)), Not(attends(Suki, d, t))))) ::: Neither Maria nor Suki attends any session on investing
ForAll([t:topics], Not(attends(Tate, Day3, t))) ::: Tate does not attend any session on the third day
ForAll([d:days, t:topics], Count([e:employees], attends(e, d, t)) <= 2) ::: At most two Capital employees attend any given session together
# Options
is_unsat(ForAll([d:days, t:topics], Implies(Exists([e:employees], attends(e, d, t)), Count([e:employees], attends(e, d, t)) == 1))) ::: (A)
is_unsat(ForAll([d:days, t:topics], Implies(Exists([e:employees], attends(e, d, t)), Count([e:employees], attends(e, d, t)) == 2))) ::: (B)
is_unsat(ForAll([d:days, t:topics], Implies(attends(Maria, d, t), attends(Suki, d, t)))) ::: (C)
is_unsat(ForAll([d:days, t:topics], Implies(attends(Suki, d, t), attends(Tate, d, t)))) ::: (D)
is_unsat(ForAll([d:days, t:topics], Implies(attends(Tate, d, t), attends(Maria, d, t)))) ::: (E)"
"# Context:
Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.

# Question:
Which one of the following could be true?

# Options:
A) Montreal and Philadelphia are connected with each other, but neither is connected with any other city.
B) Montreal and Toronto are connected with each other, but neither is connected with any other city.
C) Philadelphia and Toronto are connected with each other, but neither is connected with any other city.
D) Philadelphia and Vancouver are connected with each other, but neither is connected with any other city.
E) Toronto and Vancouver are connected with each other, but neither is connected with any other city.","# Declarations
cities = EnumSort([Honolulu, Montreal, Philadelphia, Toronto, Vancouver])
connected = Function([cities, cities] -> [bool])
# Constraints
ForAll([c:cities], Exists([c1:cities], And(c != c1, connected(c, c1)))) ::: Each city is connected with at least one other city
Count([c:cities], connected(Montreal, c)) == 1 ::: Montreal is connected with exactly one other city
Not(connected(Honolulu, Toronto)) ::: Honolulu is not connected with Toronto
ForAll([c:cities], Implies(connected(c, Honolulu), connected(c, Toronto))) ::: Any city that is connected with Honolulu is also connected with Toronto
Implies(connected(Philadelphia, Toronto), Not(connected(Philadelphia, Vancouver))) ::: If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver
# Options
is_sat(And(connected(Montreal, Philadelphia), ForAll([c:cities], Implies(c != Montreal, c != Philadelphia, Not(connected(Montreal, c)))), ForAll([c:cities], Implies(c != Montreal, c != Philadelphia, Not(connected(Philadelphia, c)))))) ::: (A)
is_sat(And(connected(Montreal, Toronto), ForAll([c:cities], Implies(c != Montreal, c != Toronto, Not(connected(Montreal, c)))), ForAll([c:cities], Implies(c != Montreal, c != Toronto, Not(connected(Toronto, c)))))) ::: (B)
is_sat(And(connected(Philadelphia, Toronto), ForAll([c:cities], Implies(c != Philadelphia, c != Toronto, Not(connected(Philadelphia, c)))), ForAll([c:cities], Implies(c != Philadelphia, c != Toronto, Not(connected(Toronto, c)))))) ::: (C)
is_sat(And(connected(Philadelphia, Vancouver), ForAll([c:cities], Implies(c != Philadelphia, c != Vancouver, Not(connected(Philadelphia, c)))), ForAll([c:cities], Implies(c != Philadelphia, c != Vancouver, Not(connected(Vancouver, c)))))) ::: (D)
is_sat(And(connected(Toronto, Vancouver), ForAll([c:cities], Implies(c != Toronto, c != Vancouver, Not(connected(Toronto, c)))), ForAll([c:cities], Implies(c != Toronto, c != Vancouver, Not(connected(Vancouver, c)))))) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
Which one of the following CANNOT be true?

# Options:
A) Pastilla ranks second highest.
B) Vistula ranks third highest.
C) Lautrec ranks third highest.
D) Robusto ranks fifth highest.
E) Scheherazade's ranks sixth highest.","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazades, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
ForAll([r1:restaurants, r2:restaurants], Implies(r1 != r2, rank(r1) != rank(r2))) ::: There are no ties
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazades) > rank(Pastilla), rank(Medici) > rank(Scheherazades)) ::: If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's
Implies(rank(Medici) > rank(Scheherazades), rank(Scheherazades) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla
# Options
is_unsat(rank(Pastilla) == 2) ::: (A)
is_unsat(rank(Vistula) == 3) ::: (B)
is_unsat(rank(Lautrec) == 3) ::: (C)
is_unsat(rank(Robusto) == 5) ::: (D)
is_unsat(rank(Scheherazades) == 6) ::: (E)"
"# Context:
Each of six tasks—harvesting, milling, plowing, spinning, threshing, and weaving—will be demonstrated exactly once at a farm exhibition. No two tasks will be demonstrated concurrently. Three volunteers—Frank, Gladys, and Leslie—will each demonstrate exactly two of the tasks. The tasks must be demonstrated in accordance with the following conditions: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks. Frank performs neither the first nor the last demonstration. Gladys demonstrates neither harvesting nor milling. Leslie demonstrates neither harvesting nor threshing. Milling is the next task demonstrated after threshing is demonstrated.

# Question:
Which one of the following could be true?

# Options:
A) Harvesting is demonstrated first.
B) Milling is demonstrated second.
C) Threshing is demonstrated first.
D) Threshing is demonstrated last.
E) Weaving is demonstrated first.","# Declarations
tasks = EnumSort([harvesting, milling, plowing, spinning, threshing, weaving])
volunteers = EnumSort([Frank, Gladys, Leslie])
demonstrated_by = Function([tasks] -> [volunteers])
demonstration_order = Function([tasks] -> [int])
# Constraints
ForAll([t:tasks], Exists([v:volunteers], demonstrated_by(t) == v)) ::: Each task is demonstrated by exactly one volunteer
ForAll([v:volunteers], Count([t:tasks], demonstrated_by(t) == v) == 2) ::: Each volunteer demonstrates exactly two tasks
ForAll([t1:tasks, t2:tasks], Implies(demonstration_order(t1) < demonstration_order(t2), demonstration_order(t1) != demonstration_order(t2))) ::: No two tasks are demonstrated concurrently
Exists([t:tasks], And(demonstrated_by(t) == Frank, ForAll([t2:tasks], Implies(demonstrated_by(t2) == Gladys, demonstration_order(t) < demonstration_order(t2))))) ::: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks
ForAll([t:tasks], Not(And(demonstrated_by(t) == Frank, Or(demonstration_order(t) == 1, demonstration_order(t) == 6)))) ::: Frank performs neither the first nor the last demonstration
ForAll([t:tasks], Not(And(demonstrated_by(t) == Gladys, Or(t == harvesting, t == milling)))) ::: Gladys demonstrates neither harvesting nor milling
ForAll([t:tasks], Not(And(demonstrated_by(t) == Leslie, Or(t == harvesting, t == threshing)))) ::: Leslie demonstrates neither harvesting nor threshing
Exists([t:tasks], And(t == threshing, Exists([t2:tasks], And(t2 == milling, demonstration_order(t2) == demonstration_order(t) + 1)))) ::: Milling is the next task demonstrated after threshing is demonstrated
# Options
is_sat(demonstration_order(harvesting) == 1) ::: (A)
is_sat(demonstration_order(milling) == 2) ::: (B)
is_sat(demonstration_order(threshing) == 1) ::: (C)
is_sat(demonstration_order(threshing) == 6) ::: (D)
is_sat(demonstration_order(weaving) == 1) ::: (E)"
"# Context:
A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.

# Question:
It CANNOT be true that females are assigned to both

# Options:
A) Richards South and Wisteria South
B) Richards South and Tuscarora South
C) Richards South and Veblen North
D) Tuscarora South and Wisteria South
E) Veblen North and Wisteria South","# Declarations
dormitories = EnumSort([Richards, Tuscarora, Veblen, Wisteria])
wings = EnumSort([North, South])
gender = EnumSort([Male, Female])
assigned = Function([dormitories, wings] -> [gender])
# Constraints
ForAll([d:dormitories, w:wings], Or(assigned(d, w) == Male, assigned(d, w) == Female)) ::: Each wing is assigned only male students or only female students
Count([d:dormitories, w:wings], assigned(d, w) == Male) == 3 ::: Exactly three wings have males assigned to them
assigned(Richards, North) == Female ::: Richards North and Tuscarora North are assigned females
assigned(Tuscarora, North) == Female ::: Richards North and Tuscarora North are assigned females
ForAll([d:dormitories], Implies(assigned(d, North) == Male, assigned(d, South) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
ForAll([d:dormitories], Implies(assigned(d, South) == Male, assigned(d, North) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
Implies(assigned(Veblen, South) == Male, assigned(Wisteria, North) == Male) ::: If males are assigned to Veblen South, then Wisteria North is assigned males
# Options
is_unsat(And(assigned(Richards, South) == Female, assigned(Wisteria, South) == Female)) ::: (A)
is_unsat(And(assigned(Richards, South) == Female, assigned(Tuscarora, South) == Female)) ::: (B)
is_unsat(And(assigned(Richards, South) == Female, assigned(Veblen, North) == Female)) ::: (C)
is_unsat(And(assigned(Tuscarora, South) == Female, assigned(Wisteria, South) == Female)) ::: (D)
is_unsat(And(assigned(Veblen, North) == Female, assigned(Wisteria, South) == Female)) ::: (E)"
"# Context:
Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.

# Question:
Which one of the following could be true?

# Options:
A) Imamura sits in row 2, whereas Kelly sits in row 3.
B) Gutierrez sits in the same row as Kelly, immediately and directly behind Moore.
C) Gutierrez occupies a window seat in the same row as Lapas.
D) Moore occupies an aisle seat in the same row as Lapas.
E) Kelly and Moore both sit in row 3.","# Declarations
passengers = EnumSort([Gutierrez, Hoffman, Imamura, Kelly, Lapas, Moore])
rows = EnumSort([1, 2, 3])
seats = EnumSort([window, aisle])
occupies = Function([passengers] -> [rows])
seat_type = Function([passengers] -> [seats])
# Constraints
seat_type(Hoffman) == aisle ::: Hoffman occupies the aisle seat
occupies(Hoffman) == occupies(Gutierrez) + 1 ::: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat
Implies(seat_type(Moore) == aisle, occupies(Hoffman) == occupies(Lapas)) ::: If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas
Implies(occupies(Gutierrez) == occupies(Kelly), occupies(Moore) == occupies(Imamura) + 1) ::: If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat
Implies(seat_type(Kelly) == window, occupies(Moore) == 3) ::: If Kelly occupies a window seat, Moore sits in row 3
Implies(occupies(Kelly) == 3, occupies(Imamura) == 1) ::: If Kelly sits in row 3, Imamura sits in row 1
# Options
is_sat(And(occupies(Imamura) == 2, occupies(Kelly) == 3)) ::: (A)
is_sat(And(occupies(Gutierrez) == occupies(Kelly), occupies(Gutierrez) == occupies(Moore) + 1)) ::: (B)
is_sat(And(seat_type(Gutierrez) == window, occupies(Gutierrez) == occupies(Lapas))) ::: (C)
is_sat(And(seat_type(Moore) == aisle, occupies(Moore) == occupies(Lapas))) ::: (D)
is_sat(And(occupies(Kelly) == 3, occupies(Moore) == 3)) ::: (E)"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
If R is the second clown to get out of the car, which one of the following must be true?

# Options:
A) S gets out of the car at some time before T does.
B) T gets out of the car at some time before W does.
C) W gets out of the car at some time before V does.
D) Y gets out of the car at some time before Q does.
E) Z gets out of the car at some time before W does.","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
order(R) == 2 ::: R is the second clown to get out of the car
# Options
is_valid(order(S) < order(T)) ::: (A)
is_valid(order(T) < order(W)) ::: (B)
is_valid(order(W) < order(V)) ::: (C)
is_valid(order(Y) < order(Q)) ::: (D)
is_valid(order(Z) < order(W)) ::: (E)"
"# Context:
Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.

# Question:
If exactly two sessions on the third day are attended by one or more Capital employees, then which one of the following must be true?

# Options:
A) Exactly two sessions on the first day are attended by one or more Capital employees.
B) Exactly two sessions on the second day are attended by one or more Capital employees.
C) Maria and Suki do not attend any session together.
D) Maria and Tate do not attend any session together.
E) Tate attends a session on investing.","# Declarations
employees = EnumSort([Maria, Suki, Tate])
days = EnumSort([Day1, Day2, Day3])
topics = EnumSort([Hiring, Investing, Regulations])
attends = Function([employees, days, topics] -> [bool])
# Constraints
ForAll([e:employees], Count([d:days, t:topics], attends(e, d, t)) == 2) ::: Each conference participant attends exactly two sessions
ForAll([e:employees, d:days, t:topics], Implies(attends(e, d, t), And(Exists([d1:days], d1 != d), Exists([t1:topics], t1 != t)))) ::: Each session attended by a participant is on a different topic and a different day
ForAll([d:days, t:topics], Count([e:employees], attends(e, d, t)) <= 2) ::: At most two Capital employees attend any given session together
ForAll([d:days], Not(attends(Maria, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([d:days], Not(attends(Suki, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([t:topics], Not(attends(Tate, Day3, t))) ::: Tate does not attend any session on the third day
Count([d:days, t:topics], Exists([e:employees], attends(e, Day3, t))) == 2 ::: Exactly two sessions on the third day are attended by one or more Capital employees
# Options
is_valid(Count([d:days, t:topics], Exists([e:employees], attends(e, Day1, t))) == 2) ::: (A)
is_valid(Count([d:days, t:topics], Exists([e:employees], attends(e, Day2, t))) == 2) ::: (B)
is_valid(ForAll([d:days, t:topics], Not(And(attends(Maria, d, t), attends(Suki, d, t))))) ::: (C)
is_valid(ForAll([d:days, t:topics], Not(And(attends(Maria, d, t), attends(Tate, d, t))))) ::: (D)
is_valid(Exists([d:days], attends(Tate, d, Investing))) ::: (E)"
"# Context:
A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.

# Question:
Which one of the following could be an accurate list of the swimmers of the first five laps, in order from lap 1 through lap 5?

# Options:
A) Jacobson, Kruger, Miller, Lu, Ortiz
B) Kruger, Miller, Ortiz, Jacobson, Lu
C) Lu, Miller, Jacobson, Kruger, Ortiz
D) Ortiz, Kruger, Miller, Lu, Jacobson
E) Miller, Ortiz, Jacobson, Kruger, Lu","# Declarations
members = EnumSort([Jacobson, Kruger, Miller, Ortiz])
laps = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
swims = Function([members, laps] -> [bool])
# Constraints
ForAll([m:members], Count([l:laps], swims(m, l)) == 2) ::: Each team member swims exactly two of the laps
ForAll([l:laps], Exists([m:members], swims(m, l))) ::: Each lap is swum by exactly one member
swims(Jacobson, 1) == True ::: One swims laps 1 and 6
swims(Jacobson, 6) == True
swims(Kruger, 2) == True ::: One swims laps 2 and 7
swims(Kruger, 7) == True
swims(Miller, 3) == True ::: One swims laps 3 and 8
swims(Miller, 8) == True
swims(Ortiz, 4) == True ::: One swims laps 4 and 9
swims(Ortiz, 9) == True
swims(Ortiz, 5) == True ::: One swims laps 5 and 10
swims(Ortiz, 10) == True
ForAll([l:laps], Implies(swims(Kruger, l), And(Not(swims(Ortiz, l + 1)), Not(swims(Ortiz, l - 1))))) ::: Neither of Kruger's laps is immediately before either of Lu's
Not(swims(Jacobson, 9)) ::: Jacobson does not swim lap 9
Exists([l:laps], And(swims(Miller, l), ForAll([l1:laps], Implies(swims(Ortiz, l1), l < l1)))) ::: Ortiz's first lap is after (but not necessarily immediately after) Miller's
Exists([l:laps], And(swims(Ortiz, l), swims(Jacobson, l + 1))) ::: At least one of Jacobson's laps is immediately after one of Ortiz's laps
# Options
is_accurate_list([swims(Jacobson, 1), swims(Kruger, 2), swims(Miller, 3), swims(Ortiz, 4), swims(Ortiz, 5)]) ::: (A)
is_accurate_list([swims(Kruger, 1), swims(Miller, 2), swims(Ortiz, 3), swims(Jacobson, 4), swims(Ortiz, 5)]) ::: (B)
is_accurate_list([swims(Ortiz, 1), swims(Miller, 2), swims(Jacobson, 3), swims(Kruger, 4), swims(Ortiz, 5)]) ::: (C)
is_accurate_list([swims(Ortiz, 1), swims(Kruger, 2), swims(Miller, 3), swims(Ortiz, 4), swims(Jacobson, 5)]) ::: (D)
is_accurate_list([swims(Miller, 1), swims(Ortiz, 2), swims(Jacobson, 3), swims(Kruger, 4), swims(Ortiz, 5)]) ::: (E)"
"# Context:
A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.

# Question:
Which one of the following could be a complete and accurate list of the kinds of fruit the stand carries?

# Options:
A) oranges, pears
B) pears, tangerines
C) oranges, pears, watermelons
D) oranges, tangerines, watermelons
E) kiwis, oranges, pears, watermelons","# Declarations
fruits = EnumSort([figs, kiwis, oranges, pears, tangerines, watermelons])
carries = Function([fruits] -> [bool])
# Constraints
Exists([f:fruits], carries(f)) ::: The stand carries at least one kind of fruit
ForAll([f:fruits], Implies(carries(kiwis), Not(carries(pears)))) ::: If the stand carries kiwis, then it does not carry pears
ForAll([f:fruits], Implies(Not(carries(tangerines)), carries(kiwis))) ::: If the stand does not carry tangerines, then it carries kiwis
ForAll([f:fruits], Implies(carries(oranges), And(carries(pears), carries(watermelons)))) ::: If the stand carries oranges, then it carries both pears and watermelons
ForAll([f:fruits], Implies(carries(watermelons), Or(carries(figs), carries(tangerines)))) ::: If the stand carries watermelons, then it carries figs or tangerines or both
# Options
is_accurate_list([carries(oranges), carries(pears)]) ::: (A)
is_accurate_list([carries(pears), carries(tangerines)]) ::: (B)
is_accurate_list([carries(oranges), carries(pears), carries(watermelons)]) ::: (C)
is_accurate_list([carries(oranges), carries(tangerines), carries(watermelons)]) ::: (D)
is_accurate_list([carries(kiwis), carries(oranges), carries(pears), carries(watermelons)]) ::: (E)"
"# Context:
Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.

# Question:
Which one of the following is a complete and accurate list of clerks, any one of whom could stock aisle 3?

# Options:
A) Jill, Kurt, Larisa
B) Jill, Larisa, Manny
C) Jill, Larisa, Olga
D) Jill, Kurt, Larisa, Manny
E) Jill, Kurt, Larisa, Olga","# Declarations
clerks = EnumSort([Jill, Kurt, Larisa, Manny, Olga])
aisles = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
stocks = Function([clerks] -> [aisles])
# Constraints
ForAll([a:aisles], Exists([c:clerks], stocks(c) == a)) ::: Each aisle is stocked by exactly one clerk
Count([a:aisles], stocks(Olga) == a) == 1 ::: Olga stocks exactly one aisle
stocks(Kurt) == 2 ::: Kurt stocks aisle 2
ForAll([a:aisles], stocks(Manny) != 1) ::: Manny does not stock aisle 1
ForAll([a:aisles], Implies(stocks(Jill) == a, stocks(Jill) != a + 1)) ::: Jill does not stock consecutive aisles
Exists([a:aisles], And(stocks(Manny) == a, stocks(Kurt) == a + 1)) ::: Kurt stocks the only aisle between the two aisles Manny stocks
Exists([a:aisles], And(stocks(Larisa) == a, Or(a == 1, a == 9))) ::: Exactly one of Larisa's aisles is an end aisle
ForAll([a:aisles], Implies(stocks(Olga) == a, And(a > 2, Exists([b:aisles], And(stocks(Larisa) == b, a < b))))) ::: Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's
# Options
is_accurate_list([Exists([a:aisles], And(stocks(Jill) == a, a == 3)), Exists([a:aisles], And(stocks(Kurt) == a, a == 3)), Exists([a:aisles], And(stocks(Larisa) == a, a == 3))]) ::: (A)
is_accurate_list([Exists([a:aisles], And(stocks(Jill) == a, a == 3)), Exists([a:aisles], And(stocks(Larisa) == a, a == 3)), Exists([a:aisles], And(stocks(Manny) == a, a == 3))]) ::: (B)
is_accurate_list([Exists([a:aisles], And(stocks(Jill) == a, a == 3)), Exists([a:aisles], And(stocks(Larisa) == a, a == 3)), Exists([a:aisles], And(stocks(Olga) == a, a == 3))]) ::: (C)
is_accurate_list([Exists([a:aisles], And(stocks(Jill) == a, a == 3)), Exists([a:aisles], And(stocks(Kurt) == a, a == 3)), Exists([a:aisles], And(stocks(Larisa) == a, a == 3)), Exists([a:aisles], And(stocks(Manny) == a, a == 3))]) ::: (D)
is_accurate_list([Exists([a:aisles], And(stocks(Jill) == a, a == 3)), Exists([a:aisles], And(stocks(Kurt) == a, a == 3)), Exists([a:aisles], And(stocks(Larisa) == a, a == 3)), Exists([a:aisles], And(stocks(Olga) == a, a == 3))]) ::: (E)"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
If Q is the fifth clown to get out of the car, then each of the following could be true EXCEPT:

# Options:
A) Z is the first clown to get out of the car.
B) T is the second clown to get out of the car.
C) V is the third clown to get out of the car.
D) W is the fourth clown to get out of the car.
E) Y is the sixth clown to get out of the car.","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
order(Q) == 5 ::: If Q is the fifth clown to get out of the car
# Options
is_unsat(order(Z) == 1) ::: (A)
is_unsat(order(T) == 2) ::: (B)
is_unsat(order(V) == 3) ::: (C)
is_unsat(order(W) == 4) ::: (D)
is_unsat(order(Y) == 6) ::: (E)"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
Which one of the following could be a complete and accurate list of the birds NOT in the forest?

# Options:
A) jays, shrikes
B) harriers, grosbeaks
C) grosbeaks, jays, martins
D) grosbeaks, martins, shrikes, wrens
E) martins, shrikes","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
# Options
is_accurate_list([Not(in_forest(jay)), Not(in_forest(shrike))]) ::: (A)
is_accurate_list([Not(in_forest(harrier)), Not(in_forest(grosbeak))]) ::: (B)
is_accurate_list([Not(in_forest(grosbeak)), Not(in_forest(jay)), Not(in_forest(martin))]) ::: (C)
is_accurate_list([Not(in_forest(grosbeak)), Not(in_forest(martin)), Not(in_forest(shrike)), Not(in_forest(wren))]) ::: (D)
is_accurate_list([Not(in_forest(martin)), Not(in_forest(shrike))]) ::: (E)"
"# Context:
Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.

# Question:
If Kudrow is at Souderton, then which one of the following must be true?

# Options:
A) Juarez is at Souderton.
B) Nance is at Souderton.
C) Onawa is at Randsborough.
D) Palermo is at Souderton.
E) Palermo is at Randsborough.","# Declarations
doctors = EnumSort([Juarez, Kudrow, Longtree, Nance, Onawa, Palermo])
clinics = EnumSort([Souderton, Randsborough])
assigned = Function([doctors] -> [clinics])
# Constraints
Implies(assigned(Juarez) == Souderton, assigned(Kudrow) == Randsborough) ::: Kudrow is at Randsborough if Juarez is at Souderton
Implies(assigned(Juarez) == Randsborough, assigned(Onawa) == Souderton) ::: Onawa is at Souderton if Juarez is at Randsborough
Implies(assigned(Longtree) == Souderton, And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: If Longtree is at Souderton, then both Nance and Palermo are at Randsborough
Implies(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough) ::: If Nance is at Randsborough, then so is Onawa
Implies(assigned(Palermo) == Randsborough, And(assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton)) ::: If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton
assigned(Kudrow) == Souderton ::: If Kudrow is at Souderton
# Options
is_valid(assigned(Juarez) == Souderton) ::: (A)
is_valid(assigned(Nance) == Souderton) ::: (B)
is_valid(assigned(Onawa) == Randsborough) ::: (C)
is_valid(assigned(Palermo) == Souderton) ::: (D)
is_valid(assigned(Palermo) == Randsborough) ::: (E)"
"# Context:
Each of six tasks—harvesting, milling, plowing, spinning, threshing, and weaving—will be demonstrated exactly once at a farm exhibition. No two tasks will be demonstrated concurrently. Three volunteers—Frank, Gladys, and Leslie—will each demonstrate exactly two of the tasks. The tasks must be demonstrated in accordance with the following conditions: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks. Frank performs neither the first nor the last demonstration. Gladys demonstrates neither harvesting nor milling. Leslie demonstrates neither harvesting nor threshing. Milling is the next task demonstrated after threshing is demonstrated.

# Question:
Which one of the following must be true?

# Options:
A) Frank performs the second demonstration.
B) Gladys performs the fourth demonstration.
C) Gladys performs the sixth demonstration.
D) Leslie performs the first demonstration.
E) Leslie performs the second demonstration.","# Declarations
tasks = EnumSort([harvesting, milling, plowing, spinning, threshing, weaving])
volunteers = EnumSort([Frank, Gladys, Leslie])
demonstrated = Function([tasks] -> [volunteers])
order = Function([tasks] -> [int])
# Constraints
ForAll([v:volunteers], Count([t:tasks], demonstrated(t) == v) == 2) ::: Each volunteer demonstrates exactly two tasks
ForAll([t1:tasks, t2:tasks], Implies(t1 != t2, order(t1) != order(t2))) ::: No two tasks are demonstrated concurrently
Exists([t:tasks], And(demonstrated(t) == Frank, ForAll([t2:tasks], Implies(demonstrated(t2) == Gladys, order(t) < order(t2))))) ::: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks
ForAll([t:tasks], Implies(demonstrated(t) == Frank, And(order(t) != 1, order(t) != 6))) ::: Frank performs neither the first nor the last demonstration
ForAll([t:tasks], Implies(demonstrated(t) == Gladys, And(t != harvesting, t != milling))) ::: Gladys demonstrates neither harvesting nor milling
ForAll([t:tasks], Implies(demonstrated(t) == Leslie, And(t != harvesting, t != threshing))) ::: Leslie demonstrates neither harvesting nor threshing
Exists([t:tasks], And(t == threshing, Exists([t2:tasks], And(t2 == milling, order(t2) == order(t) + 1)))) ::: Milling is the next task demonstrated after threshing is demonstrated
# Options
is_valid(Exists([t:tasks], And(demonstrated(t) == Frank, order(t) == 2))) ::: (A)
is_valid(Exists([t:tasks], And(demonstrated(t) == Gladys, order(t) == 4))) ::: (B)
is_valid(Exists([t:tasks], And(demonstrated(t) == Gladys, order(t) == 6))) ::: (C)
is_valid(Exists([t:tasks], And(demonstrated(t) == Leslie, order(t) == 1))) ::: (D)
is_valid(Exists([t:tasks], And(demonstrated(t) == Leslie, order(t) == 2))) ::: (E)"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
If T is the fourth clown to get out of the car, then which one of the following must be true?

# Options:
A) R is the first clown to get out of the car.
B) Z is the second clown to get out of the car.
C) W is the third clown to get out of the car.
D) V is the fifth clown to get out of the car.
E) Y is the seventh clown to get out of the car.","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
order(T) == 4 ::: T is the fourth clown to get out of the car
# Options
is_valid(order(R) == 1) ::: (A)
is_valid(order(Z) == 2) ::: (B)
is_valid(order(W) == 3) ::: (C)
is_valid(order(V) == 5) ::: (D)
is_valid(order(Y) == 7) ::: (E)"
"# Context:
Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.

# Question:
Which one of the following must be false?

# Options:
A) Maria attends sessions only on the first two days.
B) Suki attends sessions only on the last two days.
C) Exactly two Capital employees attend a session together on the second day.
D) Exactly one session is attended by one or more Capital employees on the second day.
E) Exactly three sessions are attended by one or more Capital employees on the third day.","# Declarations
employees = EnumSort([Maria, Suki, Tate])
days = EnumSort([Day1, Day2, Day3])
topics = EnumSort([Hiring, Investing, Regulations])
attends = Function([employees, days, topics] -> [bool])
# Constraints
ForAll([e:employees], Count([d:days, t:topics], attends(e, d, t)) == 2) ::: Each conference participant attends exactly two sessions
ForAll([e:employees, d:days], Count([t:topics], attends(e, d, t)) <= 1) ::: Each conference participant attends exactly one session per day
ForAll([e:employees, t:topics], Count([d:days], attends(e, d, t)) <= 1) ::: Each conference participant attends sessions on different topics
ForAll([d:days, t:topics], Count([e:employees], attends(e, d, t)) <= 2) ::: At most two Capital employees attend any given session together
ForAll([d:days], Not(attends(Maria, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([d:days], Not(attends(Suki, d, Investing))) ::: Neither Maria nor Suki attends any session on investing
ForAll([t:topics], Not(attends(Tate, Day3, t))) ::: Tate does not attend any session on the third day
# Options
is_unsat(ForAll([d:days, t:topics], Implies(d != Day3, attends(Maria, d, t)))) ::: (A)
is_unsat(ForAll([d:days, t:topics], Implies(d != Day1, attends(Suki, d, t)))) ::: (B)
is_unsat(Exists([t:topics], Count([e:employees], attends(e, Day2, t)) == 2)) ::: (C)
is_unsat(Exists([t:topics], Count([e:employees], attends(e, Day2, t)) == 1)) ::: (D)
is_unsat(Count([t:topics], Exists([e:employees], attends(e, Day3, t))) == 3) ::: (E)"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
If both martins and harriers are in the forest, then which one of the following must be true?

# Options:
A) Shrikes are the only other birds in the forest.
B) Jays are the only other birds in the forest.
C) The forest contains neither jays nor shrikes.
D) There are at least two other kinds of birds in the forest.
E) There are at most two other kinds of birds in the forest.","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
in_forest(martin) ::: martins are in the forest
in_forest(harrier) ::: harriers are in the forest
# Options
is_valid(ForAll([b:birds], Implies(And(b != harrier, b != martin), in_forest(b) == in_forest(shrike)))) ::: (A)
is_valid(ForAll([b:birds], Implies(And(b != harrier, b != martin), in_forest(b) == in_forest(jay)))) ::: (B)
is_valid(And(Not(in_forest(jay)), Not(in_forest(shrike)))) ::: (C)
is_valid(Count([b:birds], And(b != harrier, b != martin, in_forest(b))) >= 2) ::: (D)
is_valid(Count([b:birds], And(b != harrier, b != martin, in_forest(b))) <= 2) ::: (E)"
"# Context:
A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.

# Question:
If females are assigned to Veblen South and Veblen North, then which one of the following could be two other wings that are also assigned females?

# Options:
A) Richards North and Tuscarora South
B) Richards South and Wisteria South
C) Richards South and Tuscarora North
D) Tuscarora North and Wisteria South
E) Tuscarora South and Wisteria South","# Declarations
dormitories = EnumSort([Richards, Tuscarora, Veblen, Wisteria])
wings = EnumSort([North, South])
gender = EnumSort([Male, Female])
assigned = Function([dormitories, wings] -> [gender])
# Constraints
ForAll([d:dormitories, w:wings], Or(assigned(d, w) == Male, assigned(d, w) == Female)) ::: Each wing is assigned only male students or only female students
Count([d:dormitories, w:wings], assigned(d, w) == Male) == 3 ::: Exactly three wings have males assigned to them
assigned(Richards, North) == Female ::: Richards North and Tuscarora North are assigned females
assigned(Tuscarora, North) == Female ::: Richards North and Tuscarora North are assigned females
ForAll([d:dormitories], Implies(assigned(d, North) == Male, assigned(d, South) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
ForAll([d:dormitories], Implies(assigned(d, South) == Male, assigned(d, North) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
Implies(assigned(Veblen, South) == Male, assigned(Wisteria, North) == Male) ::: If males are assigned to Veblen South, then Wisteria North is assigned males
assigned(Veblen, South) == Female ::: females are assigned to Veblen South
assigned(Veblen, North) == Female ::: females are assigned to Veblen North
# Options
is_accurate_list([assigned(Richards, North) == Female, assigned(Tuscarora, South) == Female]) ::: (A)
is_accurate_list([assigned(Richards, South) == Female, assigned(Wisteria, South) == Female]) ::: (B)
is_accurate_list([assigned(Richards, South) == Female, assigned(Tuscarora, North) == Female]) ::: (C)
is_accurate_list([assigned(Tuscarora, North) == Female, assigned(Wisteria, South) == Female]) ::: (D)
is_accurate_list([assigned(Tuscarora, South) == Female, assigned(Wisteria, South) == Female]) ::: (E)"
"# Context:
Musicians perform each of exactly five pieces—Nexus, Onyx, Synchrony, Tailwind, and Virtual—once, and one at a time; the pieces are performed successively (though not necessarily in that order). Each piece is performed with exactly two instruments: Nexus with fiddle and lute, Onyx with harp and mandolin, Synchrony with guitar and harp, Tailwind with fiddle and guitar, and Virtual with lute and mandolin. The following conditions must apply: Each piece shares one instrument with the piece performed immediately before it or after it (or both). Either Nexus or Tailwind is performed second.

# Question:
Which one of the following instruments CANNOT be shared by the third and fourth pieces performed?

# Options:
A) fiddle
B) guitar
C) harp
D) lute
E) mandolin","# Declarations
pieces = EnumSort([Nexus, Onyx, Synchrony, Tailwind, Virtual])
instruments = EnumSort([fiddle, lute, harp, mandolin, guitar])
performed_with = Function([pieces, instruments] -> [bool])
order = Function([pieces] -> [int])
# Constraints
ForAll([p:pieces], Exists([i:instruments], performed_with(p, i))) ::: Each piece is performed with exactly two instruments
ForAll([p:pieces], Count([i:instruments], performed_with(p, i)) == 2) ::: Each piece is performed with exactly two instruments
ForAll([i:instruments], Count([p:pieces], performed_with(p, i)) == 2) ::: Each instrument is used in exactly two pieces
ForAll([p:pieces], Exists([p1:pieces], And(p1 != p, Or(order(p1) == order(p) + 1, order(p1) == order(p) - 1)))) ::: Each piece shares one instrument with the piece performed immediately before it or after it (or both)
Or(order(Nexus) == 2, order(Tailwind) == 2) ::: Either Nexus or Tailwind is performed second
# Options
is_unsat(Exists([p3:pieces, p4:pieces], And(order(p3) == 3, order(p4) == 4, Exists([i:instruments], And(performed_with(p3, i), performed_with(p4, i), i == fiddle))))) ::: (A)
is_unsat(Exists([p3:pieces, p4:pieces], And(order(p3) == 3, order(p4) == 4, Exists([i:instruments], And(performed_with(p3, i), performed_with(p4, i), i == guitar))))) ::: (B)
is_unsat(Exists([p3:pieces, p4:pieces], And(order(p3) == 3, order(p4) == 4, Exists([i:instruments], And(performed_with(p3, i), performed_with(p4, i), i == harp))))) ::: (C)
is_unsat(Exists([p3:pieces, p4:pieces], And(order(p3) == 3, order(p4) == 4, Exists([i:instruments], And(performed_with(p3, i), performed_with(p4, i), i == lute))))) ::: (D)
is_unsat(Exists([p3:pieces, p4:pieces], And(order(p3) == 3, order(p4) == 4, Exists([i:instruments], And(performed_with(p3, i), performed_with(p4, i), i == mandolin))))) ::: (E)"
"# Context:
A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.

# Question:
Suppose the third speaker were a specialist not only in Mill and Nietzsche, but also in Sartre. If all of the other conditions remained the same, then each of the following could be true EXCEPT:

# Options:
A) Mill is lectured on in the first lecture and Nietzsche in the fourth.
B) Mill is lectured on in the second lecture and Nietzsche in the third.
C) Mill is lectured on in the second lecture and Nietzsche in the fourth.
D) Mill is lectured on in the fourth lecture and Nietzsche in the fifth.
E) Nietzsche is lectured on in the second lecture and Mill in the fourth.","# Declarations
weeks = EnumSort([first, second, third, fourth, fifth])
philosophers = EnumSort([Kant, Locke, Mill, Nietzsche, Ockham, Plato, Sartre])
speakers = EnumSort([speaker1, speaker2, speaker3, speaker4, speaker5])
lectures = Function([weeks] -> [philosophers])
specializes = Function([speakers] -> [philosophers])
# Constraints
ForAll([w:weeks], ForAll([w1:weeks], Implies(w != w1, lectures(w) != lectures(w1)))) ::: No lecture is given more than once
ForAll([s:speakers], ForAll([s1:speakers], Implies(s != s1, specializes(s) != specializes(s1)))) ::: No two speakers lecture on the same philosopher
specializes(speaker1) == Kant or specializes(speaker1) == Locke or specializes(speaker1) == Mill ::: The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers
specializes(speaker2) == Kant or specializes(speaker2) == Locke or specializes(speaker2) == Mill or specializes(speaker2) == Nietzsche ::: The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers
specializes(speaker3) == Mill or specializes(speaker3) == Nietzsche or specializes(speaker3) == Sartre ::: The third week's speaker specializes in Mill, Nietzsche, and Sartre
specializes(speaker4) == Mill or specializes(speaker4) == Nietzsche ::: The fourth week's speaker specializes in Mill and Nietzsche, and no other philosophers
specializes(speaker5) == Nietzsche or specializes(speaker5) == Ockham or specializes(speaker5) == Plato ::: The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers
# Options
is_unsat(And(lectures(first) == Mill, lectures(fourth) == Nietzsche)) ::: (A)
is_unsat(And(lectures(second) == Mill, lectures(third) == Nietzsche)) ::: (B)
is_unsat(And(lectures(second) == Mill, lectures(fourth) == Nietzsche)) ::: (C)
is_unsat(And(lectures(fourth) == Mill, lectures(fifth) == Nietzsche)) ::: (D)
is_unsat(And(lectures(second) == Nietzsche, lectures(fourth) == Mill)) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
If Vistula ranks higher than Robusto, then which one of the following restaurants could be ranked fifth highest?

# Options:
A) Tantoko
B) Medici
C) Scheherazade's
D) Vistula
E) Pastilla","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazade, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazade) > rank(Pastilla), rank(Medici) > rank(Scheherazade)) ::: If Scheherazade ranks higher than Pastilla, Medici ranks higher than Scheherazade
Implies(rank(Medici) > rank(Scheherazade), rank(Scheherazade) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazade, Scheherazade ranks higher than Pastilla
rank(Vistula) > rank(Robusto) ::: Vistula ranks higher than Robusto
# Options
is_valid(rank(Tantoko) == 5) ::: (A)
is_valid(rank(Medici) == 5) ::: (B)
is_valid(rank(Scheherazade) == 5) ::: (C)
is_valid(rank(Vistula) == 5) ::: (D)
is_valid(rank(Pastilla) == 5) ::: (E)"
"# Context:
In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.

# Question:
If exactly three of the trucks are green, then which one of the following trucks must be green?

# Options:
A) S
B) T
C) U
D) W
E) Z","# Declarations
trucks = EnumSort([S, T, U, W, X, Y, Z])
colors = EnumSort([green, red])
arrival_order = Function([trucks] -> [int])
truck_color = Function([trucks] -> [colors])
# Constraints
ForAll([t:trucks], arrival_order(t) >= 1) ::: Each truck arrives at some time
ForAll([t:trucks], arrival_order(t) <= 7) ::: Each truck arrives at some time
ForAll([t1:trucks, t2:trucks], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: No truck arrives at the same time as any other truck
ForAll([t:trucks], Or(truck_color(t) == green, truck_color(t) == red)) ::: Each truck is either green or red
ForAll([t1:trucks, t2:trucks], Implies(And(arrival_order(t1) + 1 == arrival_order(t2), truck_color(t1) == red), truck_color(t2) != red)) ::: No two consecutive arrivals are red
ForAll([t:trucks], Implies(arrival_order(t) == 6, t == S)) ::: S is the sixth arrival
ForAll([t:trucks], Implies(t == Y, And(arrival_order(Y) < arrival_order(T), arrival_order(Y) < arrival_order(W)))) ::: Y arrives at some time before both T and W
Count([t:trucks], And(arrival_order(t) < arrival_order(Y), truck_color(t) == red)) == 2 ::: Exactly two of the trucks that arrive before Y are red
ForAll([t:trucks], Implies(t == Z, arrival_order(Z) < arrival_order(U))) ::: Z arrives at some time before U
Count([t:trucks], truck_color(t) == green) == 3 ::: Exactly three of the trucks are green
# Options
is_valid(truck_color(S) == green) ::: (A)
is_valid(truck_color(T) == green) ::: (B)
is_valid(truck_color(U) == green) ::: (C)
is_valid(truck_color(W) == green) ::: (D)
is_valid(truck_color(Z) == green) ::: (E)"
"# Context:
Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.

# Question:
Which one of the following CANNOT be a pair of the doctors at Randsborough?

# Options:
A) Juarez and Kudrow
B) Juarez and Palermo
C) Kudrow and Onawa
D) Nance and Onawa
E) Nance and Palermo","# Declarations
doctors = EnumSort([Juarez, Kudrow, Longtree, Nance, Onawa, Palermo])
clinics = EnumSort([Souderton, Randsborough])
assigned = Function([doctors] -> [clinics])
# Constraints
Implies(assigned(Juarez) == Souderton, assigned(Kudrow) == Randsborough) ::: Kudrow is at Randsborough if Juarez is at Souderton
Implies(assigned(Juarez) == Randsborough, assigned(Onawa) == Souderton) ::: Onawa is at Souderton if Juarez is at Randsborough
Implies(assigned(Longtree) == Souderton, And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: If Longtree is at Souderton, then both Nance and Palermo are at Randsborough
Implies(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough) ::: If Nance is at Randsborough, then so is Onawa
Implies(assigned(Palermo) == Randsborough, And(assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton)) ::: If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton
# Options
is_unsat(And(assigned(Juarez) == Randsborough, assigned(Kudrow) == Randsborough)) ::: (A)
is_unsat(And(assigned(Juarez) == Randsborough, assigned(Palermo) == Randsborough)) ::: (B)
is_unsat(And(assigned(Kudrow) == Randsborough, assigned(Onawa) == Randsborough)) ::: (C)
is_unsat(And(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough)) ::: (D)
is_unsat(And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: (E)"
"# Context:
A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.

# Question:
Assume that, of the six philosophers, Kant and Nietzsche are the only German philosophers, and Locke, Mill, and Ockham are the only British philosophers. Each of the following statements could be true EXCEPT:

# Options:
A) The first and fourth speakers lecture on British philosophers.
B) The first and fourth speakers lecture on German philosophers.
C) The second and third speakers lecture on British philosophers.
D) The third and fourth speakers lecture on German philosophers.
E) The fourth and fifth speakers lecture on British philosophers.","# Declarations
weeks = EnumSort([week1, week2, week3, week4, week5])
philosophers = EnumSort([Kant, Locke, Mill, Nietzsche, Ockham, Plato])
speakers = EnumSort([speaker1, speaker2, speaker3, speaker4, speaker5])
lectures = Function([weeks] -> [philosophers])
specializes = Function([speakers] -> [philosophers])
# Constraints
ForAll([w:weeks], Exists([p:philosophers], lectures(w) == p)) ::: No lecture is given more than once
ForAll([w:weeks], Exists([s:speakers], specializes(s) == lectures(w))) ::: Each lecture is delivered by a different speaker
ForAll([p:philosophers], Count([w:weeks], lectures(w) == p) == 1) ::: No two speakers lecture on the same philosopher
specializes(speaker1) == Kant or specializes(speaker1) == Locke or specializes(speaker1) == Mill ::: The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers
specializes(speaker2) == Kant or specializes(speaker2) == Locke or specializes(speaker2) == Mill or specializes(speaker2) == Nietzsche ::: The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers
specializes(speaker3) == Mill or specializes(speaker3) == Nietzsche ::: The third week's speaker specializes in Mill and Nietzsche, and no other philosophers
specializes(speaker4) == Mill or specializes(speaker4) == Nietzsche ::: The fourth week's speaker specializes in Mill and Nietzsche, and no other philosophers
specializes(speaker5) == Nietzsche or specializes(speaker5) == Ockham or specializes(speaker5) == Plato ::: The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers
# Options
is_unsat(And(lectures(week1) == Kant or lectures(week1) == Locke or lectures(week1) == Mill, lectures(week4) == Kant or lectures(week4) == Locke or lectures(week4) == Mill)) ::: (A) The first and fourth speakers lecture on British philosophers
is_unsat(And(lectures(week1) == Kant or lectures(week1) == Nietzsche, lectures(week4) == Kant or lectures(week4) == Nietzsche)) ::: (B) The first and fourth speakers lecture on German philosophers
is_unsat(And(lectures(week2) == Locke or lectures(week2) == Mill, lectures(week3) == Locke or lectures(week3) == Mill)) ::: (C) The second and third speakers lecture on British philosophers
is_unsat(And(lectures(week3) == Nietzsche, lectures(week4) == Nietzsche)) ::: (D) The third and fourth speakers lecture on German philosophers
is_unsat(And(lectures(week4) == Locke or lectures(week4) == Mill or lectures(week4) == Ockham, lectures(week5) == Locke or lectures(week5) == Mill or lectures(week5) == Ockham)) ::: (E) The fourth and fifth speakers lecture on British philosophers"
"# Context:
Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.

# Question:
Which one of the following is a pair of clerks, neither of whom could stock aisle 5?

# Options:
A) Jill and Manny
B) Kurt and Olga
C) Larisa and Manny
D) Kurt and Manny
E) Larisa and Olga","# Declarations
clerks = EnumSort([Jill, Kurt, Larisa, Manny, Olga])
aisles = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
stocks = Function([clerks] -> [aisles])
# Constraints
Count([a:aisles], stocks(Olga) == a) == 1 ::: Olga stocks exactly one aisle
stocks(Kurt) == 2 ::: Kurt stocks aisle 2
ForAll([a:aisles], stocks(Manny) != 1) ::: Manny does not stock aisle 1
ForAll([a:aisles], Implies(stocks(Jill) == a, And(a != 1, a != 9, stocks(Jill) != a + 1, stocks(Jill) != a - 1))) ::: Jill does not stock consecutive aisles
Exists([a:aisles], And(stocks(Manny) == a, a != 2, stocks(Kurt) == a + 1 or stocks(Kurt) == a - 1)) ::: Kurt stocks the only aisle between the two aisles Manny stocks
Exists([a:aisles], Or(stocks(Larisa) == 1, stocks(Larisa) == 9)) ::: Exactly one of Larisa's aisles is an end aisle
ForAll([a:aisles], Implies(stocks(Olga) == a, And(a > 2, Exists([b:aisles], And(stocks(Larisa) == b, a < b))))) ::: Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's
# Options
is_valid(And(ForAll([a:aisles], stocks(Jill) != 5), ForAll([a:aisles], stocks(Manny) != 5))) ::: (A)
is_valid(And(ForAll([a:aisles], stocks(Kurt) != 5), ForAll([a:aisles], stocks(Olga) != 5))) ::: (B)
is_valid(And(ForAll([a:aisles], stocks(Larisa) != 5), ForAll([a:aisles], stocks(Manny) != 5))) ::: (C)
is_valid(And(ForAll([a:aisles], stocks(Kurt) != 5), ForAll([a:aisles], stocks(Manny) != 5))) ::: (D)
is_valid(And(ForAll([a:aisles], stocks(Larisa) != 5), ForAll([a:aisles], stocks(Olga) != 5))) ::: (E)"
"# Context:
Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.

# Question:
If Paton and Madison have a specialty in common, then which one of the following must be true?

# Options:
A) Nilsson does not share a specialty with Paton.
B) Exactly one professor was hired in 1990.
C) Exactly one professor was hired in 1991.
D) Exactly two professors were hired in each of two years.
E) Paton was hired at least one year before Sarkis.","# Declarations
professors = EnumSort([Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, Togo])
years = EnumSort([1989, 1990, 1991, 1992, 1993, 1994, 1995])
specialties = EnumSort([specialty1, specialty2, specialty3, specialty4, specialty5, specialty6, specialty7])
hired = Function([professors] -> [years])
has_specialty = Function([professors, specialties] -> [bool])
# Constraints
ForAll([p:professors], Exists([y:years], hired(p) == y)) ::: Each professor was hired in one of the years 1989 through 1995
ForAll([p1:professors, p2:professors], Implies(And(p1 != p2, Or(hired(p1) == hired(p2), Abs(hired(p1) - hired(p2)) == 1)), ForAll([s:specialties], Not(And(has_specialty(p1, s), has_specialty(p2, s)))))) ::: Any two professors hired in the same year or in consecutive years do not have a specialty in common
hired(Madison) == 1993 ::: Madison was hired in 1993
hired(Robinson) == 1991 ::: Robinson was hired in 1991
Exists([s:specialties], And(has_specialty(Madison, s), has_specialty(Orozco, s), has_specialty(Togo, s))) ::: There is at least one specialty that Madison, Orozco, and Togo have in common
Exists([s:specialties], And(has_specialty(Nilsson, s), has_specialty(Robinson, s))) ::: Nilsson shares a specialty with Robinson
And(hired(Paton) < 1993, hired(Paton) > hired(Nilsson)) ::: Paton was hired at least one year before Madison and at least one year after Nilsson
And(hired(Sarkis) < 1993, hired(Sarkis) > hired(Nilsson)) ::: Sarkis was hired at least one year before Madison and at least one year after Nilsson
hired(Orozco) == 1990 ::: Orozco was hired in 1990
Exists([s:specialties], And(has_specialty(Orozco, s), has_specialty(Sarkis, s))) ::: Orozco shares a specialty with Sarkis
Exists([s:specialties], And(has_specialty(Paton, s), has_specialty(Madison, s))) ::: Paton and Madison have a specialty in common
# Options
is_valid(ForAll([s:specialties], Not(And(has_specialty(Nilsson, s), has_specialty(Paton, s))))) ::: (A)
is_valid(Count([p:professors], hired(p) == 1990) == 1) ::: (B)
is_valid(Count([p:professors], hired(p) == 1991) == 1) ::: (C)
is_valid(Exists([y1:years, y2:years], And(y1 != y2, Count([p:professors], hired(p) == y1) == 2, Count([p:professors], hired(p) == y2) == 2))) ::: (D)
is_valid(hired(Paton) < hired(Sarkis)) ::: (E)"
"# Context:
Each of six tasks—harvesting, milling, plowing, spinning, threshing, and weaving—will be demonstrated exactly once at a farm exhibition. No two tasks will be demonstrated concurrently. Three volunteers—Frank, Gladys, and Leslie—will each demonstrate exactly two of the tasks. The tasks must be demonstrated in accordance with the following conditions: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks. Frank performs neither the first nor the last demonstration. Gladys demonstrates neither harvesting nor milling. Leslie demonstrates neither harvesting nor threshing. Milling is the next task demonstrated after threshing is demonstrated.

# Question:
If Gladys demonstrates plowing immediately before Frank demonstrates threshing, which one of the following must be true?

# Options:
A) Frank demonstrates harvesting for the second demonstration.
B) Gladys demonstrates spinning for the fifth demonstration.
C) Leslie demonstrates weaving for the first demonstration.
D) Gladys performs the fourth demonstration.
E) Leslie performs the sixth demonstration.","# Declarations
tasks = EnumSort([harvesting, milling, plowing, spinning, threshing, weaving])
volunteers = EnumSort([Frank, Gladys, Leslie])
demonstrates = Function([volunteers, tasks] -> [bool])
demonstration_order = Function([tasks] -> [int])
# Constraints
ForAll([t:tasks], Exists([v:volunteers], demonstrates(v, t))) ::: Each task is demonstrated exactly once
ForAll([v:volunteers], Count([t:tasks], demonstrates(v, t)) == 2) ::: Each volunteer demonstrates exactly two tasks
Exists([t1:tasks, t2:tasks], And(demonstrates(Frank, t1), demonstrates(Gladys, t2), demonstration_order(t1) < demonstration_order(t2))) ::: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks
Exists([t:tasks], And(demonstrates(Frank, t), demonstration_order(t) != 1, demonstration_order(t) != 6)) ::: Frank performs neither the first nor the last demonstration
ForAll([t:tasks], Not(And(demonstrates(Gladys, t), Or(t == harvesting, t == milling)))) ::: Gladys demonstrates neither harvesting nor milling
ForAll([t:tasks], Not(And(demonstrates(Leslie, t), Or(t == harvesting, t == threshing)))) ::: Leslie demonstrates neither harvesting nor threshing
Exists([t1:tasks, t2:tasks], And(t1 == threshing, t2 == milling, demonstration_order(t1) + 1 == demonstration_order(t2))) ::: Milling is the next task demonstrated after threshing is demonstrated
Exists([t1:tasks, t2:tasks], And(demonstrates(Gladys, t1), demonstrates(Frank, t2), t1 == plowing, t2 == threshing, demonstration_order(t1) + 1 == demonstration_order(t2))) ::: Gladys demonstrates plowing immediately before Frank demonstrates threshing
# Options
is_valid(And(demonstrates(Frank, harvesting), demonstration_order(harvesting) == 2)) ::: (A)
is_valid(And(demonstrates(Gladys, spinning), demonstration_order(spinning) == 5)) ::: (B)
is_valid(And(demonstrates(Leslie, weaving), demonstration_order(weaving) == 1)) ::: (C)
is_valid(Exists([t:tasks], And(demonstrates(Gladys, t), demonstration_order(t) == 4))) ::: (D)
is_valid(Exists([t:tasks], And(demonstrates(Leslie, t), demonstration_order(t) == 6))) ::: (E)"
"# Context:
There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.

# Question:
Which one of the following statements must be true?

# Options:
A) Green lights decorate store 10.
B) Red lights decorate store 1.
C) Red lights decorate store 8.
D) Yellow lights decorate store 8.
E) Yellow lights decorate store 10.","# Declarations
stores = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
colors = EnumSort([green, red, yellow])
decorated = Function([stores] -> [colors])
# Constraints
ForAll([s:stores], Exists([c:colors], decorated(s) == c)) ::: Each store is decorated with lights in exactly one color
ForAll([s:stores], Implies(s % 2 == 1, decorated(s) != decorated(s + 1))) ::: No store is decorated with lights of the same color as those of any store adjacent to it (north side)
ForAll([s:stores], Implies(s % 2 == 0, decorated(s) != decorated(s - 1))) ::: No store is decorated with lights of the same color as those of any store adjacent to it (south side)
ForAll([s:stores], Implies(s % 2 == 1, decorated(s) != decorated(s + 1))) ::: No store is decorated with lights of the same color as those of the store directly across the street from it (north side)
ForAll([s:stores], Implies(s % 2 == 0, decorated(s) != decorated(s - 1))) ::: No store is decorated with lights of the same color as those of the store directly across the street from it (south side)
Count([s:stores], And(s % 2 == 1, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the north side of the street
Count([s:stores], And(s % 2 == 0, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the south side of the street
decorated(4) == red ::: Red lights decorate store 4
decorated(5) == yellow ::: Yellow lights decorate store 5
# Options
is_valid(decorated(10) == green) ::: (A)
is_valid(decorated(1) == red) ::: (B)
is_valid(decorated(8) == red) ::: (C)
is_valid(decorated(8) == yellow) ::: (D)
is_valid(decorated(10) == yellow) ::: (E)"
"# Context:
Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.

# Question:
Which one of the following statements could be true?

# Options:
A) Robert sits in row H.
B) Shiro sits in row H.
C) Quentin sits in the same row as, and in a seat adjacent to, Shiro.
D) Robert sits in the same row as, and in a seat adjacent to, Tony.
E) Robert sits in the same row as, and in a seat adjacent to, Umeko.","# Declarations
members = EnumSort([Quentin, Robert, Shiro, Tony, Umeko])
rows = EnumSort([G, H])
seats = EnumSort([1, 2, 3])
sits_in_row = Function([members] -> [rows])
sits_in_seat = Function([members] -> [seats])
# Constraints
ForAll([m:members], Exists([m1:members], And(m != m1, sits_in_row(m) == sits_in_row(m1), Abs(sits_in_seat(m) - sits_in_seat(m1)) == 1))) ::: Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family
sits_in_row(Tony) == H ::: Tony and Umeko sit in row H
sits_in_row(Umeko) == H ::: Tony and Umeko sit in row H
sits_in_seat(Shiro) < sits_in_seat(Tony) ::: Shiro and Umeko sit in lower numbered seats than does Tony
sits_in_seat(Umeko) < sits_in_seat(Tony) ::: Shiro and Umeko sit in lower numbered seats than does Tony
Or(sits_in_row(Robert) == sits_in_row(Quentin), sits_in_row(Robert) == sits_in_row(Shiro), And(sits_in_row(Robert) == sits_in_row(Quentin), sits_in_row(Robert) == sits_in_row(Shiro))) ::: Robert sits in the same row as Quentin or Shiro or both
sits_in_seat(Robert) == 2 ::: Robert sits in a seat numbered 2
# Options
is_valid(sits_in_row(Robert) == H) ::: (A)
is_valid(sits_in_row(Shiro) == H) ::: (B)
is_valid(And(sits_in_row(Quentin) == sits_in_row(Shiro), Abs(sits_in_seat(Quentin) - sits_in_seat(Shiro)) == 1)) ::: (C)
is_valid(And(sits_in_row(Robert) == sits_in_row(Tony), Abs(sits_in_seat(Robert) - sits_in_seat(Tony)) == 1)) ::: (D)
is_valid(And(sits_in_row(Robert) == sits_in_row(Umeko), Abs(sits_in_seat(Robert) - sits_in_seat(Umeko)) == 1)) ::: (E)"
"# Context:
A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.

# Question:
Which one of the following must be true?

# Options:
A) A linguistics monograph is on the first shelf.
B) No more than one novel is on each shelf.
C) The Farsi grammar is not on the same shelf as the Hausa grammar.
D) The semantics monograph is not on the same shelf as the Woolf novel.
E) The Woolf novel is not on the first shelf.","# Declarations
shelves = EnumSort([first, second, third])
books = EnumSort([FarsiGrammar, HausaGrammar, PhonologyMonograph, SemanticsMonograph, VonnegutNovel, WoolfNovel])
located = Function([books] -> [shelves])
# Constraints
Count([b:books], located(b) == first) == 1 ::: one book on the first shelf
Count([b:books], located(b) == second) == 2 ::: two books on the second shelf
Count([b:books], located(b) == third) == 3 ::: three books on the third shelf
Exists([b:books], And(b == VonnegutNovel, located(b) == located(FarsiGrammar))) ::: There is at least one novel on the same shelf as the Farsi grammar
located(PhonologyMonograph) != located(SemanticsMonograph) ::: The monographs are not both on the same shelf
located(VonnegutNovel) != located(PhonologyMonograph) ::: The Vonnegut novel is not on the same shelf as the phonology monograph
located(VonnegutNovel) != located(SemanticsMonograph) ::: The Vonnegut novel is not on the same shelf as the semantics monograph
# Options
is_valid(Exists([b:books], And(b == PhonologyMonograph, located(b) == first))) ::: (A)
is_valid(ForAll([s:shelves], Count([b:books], And(b == VonnegutNovel, located(b) == s)) <= 1)) ::: (B)
is_valid(located(FarsiGrammar) != located(HausaGrammar)) ::: (C)
is_valid(located(SemanticsMonograph) != located(WoolfNovel)) ::: (D)
is_valid(located(WoolfNovel) != first) ::: (E)"
"# Context:
A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.

# Question:
What is the maximum possible number of different schedules for the five lectures in which those philosophers who are discussed are discussed in alphabetical order?

# Options:
A) 2
B) 3
C) 4
D) 5
E) 6","# Declarations
weeks = EnumSort([week1, week2, week3, week4, week5])
philosophers = EnumSort([Kant, Locke, Mill, Nietzsche, Ockham, Plato])
speakers = EnumSort([speaker1, speaker2, speaker3, speaker4, speaker5])
specializes = Function([speakers] -> [philosophers])
lectures = Function([weeks] -> [philosophers])
# Constraints
ForAll([w:weeks], Exists([s:speakers], specializes(s) == lectures(w))) ::: Each lecture is delivered by a different speaker
ForAll([w1:weeks, w2:weeks], Implies(w1 != w2, lectures(w1) != lectures(w2))) ::: No lecture is given more than once
ForAll([s1:speakers, s2:speakers], Implies(s1 != s2, specializes(s1) != specializes(s2))) ::: No two speakers lecture on the same philosopher
Or(specializes(speaker1) == Kant, specializes(speaker1) == Locke, specializes(speaker1) == Mill) ::: The first week's speaker specializes in Kant, Locke, and Mill
Or(specializes(speaker2) == Kant, specializes(speaker2) == Locke, specializes(speaker2) == Mill, specializes(speaker2) == Nietzsche) ::: The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche
Or(specializes(speaker3) == Mill, specializes(speaker3) == Nietzsche) ::: The third week's speaker specializes in Mill and Nietzsche
Or(specializes(speaker4) == Mill, specializes(speaker4) == Nietzsche) ::: The fourth week's speaker specializes in Mill and Nietzsche
Or(specializes(speaker5) == Nietzsche, specializes(speaker5) == Ockham, specializes(speaker5) == Plato) ::: The fifth week's speaker specializes in Nietzsche, Ockham, and Plato
# Options
is_sat(Count([p:philosophers], ForAll([w:weeks], Implies(lectures(w) == p, Or(p == Kant, p == Locke, p == Mill, p == Nietzsche, p == Ockham, p == Plato)))) == 2) ::: (A)
is_sat(Count([p:philosophers], ForAll([w:weeks], Implies(lectures(w) == p, Or(p == Kant, p == Locke, p == Mill, p == Nietzsche, p == Ockham, p == Plato)))) == 3) ::: (B)
is_sat(Count([p:philosophers], ForAll([w:weeks], Implies(lectures(w) == p, Or(p == Kant, p == Locke, p == Mill, p == Nietzsche, p == Ockham, p == Plato)))) == 4) ::: (C)
is_sat(Count([p:philosophers], ForAll([w:weeks], Implies(lectures(w) == p, Or(p == Kant, p == Locke, p == Mill, p == Nietzsche, p == Ockham, p == Plato)))) == 5) ::: (D)
is_sat(Count([p:philosophers], ForAll([w:weeks], Implies(lectures(w) == p, Or(p == Kant, p == Locke, p == Mill, p == Nietzsche, p == Ockham, p == Plato)))) == 6) ::: (E)"
"# Context:
In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.

# Question:
Which one of the following could be the order, from first to last, in which the trucks arrive?

# Options:
A) X, Z, U, Y, W, S, T
B) X, Y, Z, U, W, S, T
C) Z, W, U, T, Y, S, X
D) Z, U, T, Y, W, S, X
E) U, Z, Y, T, S, W, X","# Declarations
trucks = EnumSort([S, T, U, W, X, Y, Z])
colors = EnumSort([green, red])
arrival_order = Function([trucks] -> [int])
truck_color = Function([trucks] -> [colors])
# Constraints
ForAll([t1:trucks, t2:trucks], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: No truck arrives at the same time as any other truck
ForAll([t:trucks], Or(truck_color(t) == green, truck_color(t) == red)) ::: Each truck is either green or red
ForAll([t1:trucks, t2:trucks], Implies(And(arrival_order(t1) + 1 == arrival_order(t2), truck_color(t1) == red), truck_color(t2) != red)) ::: No two consecutive arrivals are red
arrival_order(Y) < arrival_order(T) ::: Y arrives at some time before T
arrival_order(Y) < arrival_order(W) ::: Y arrives at some time before W
Count([t:trucks], And(arrival_order(t) < arrival_order(Y), truck_color(t) == red)) == 2 ::: Exactly two of the trucks that arrive before Y are red
arrival_order(S) == 6 ::: S is the sixth arrival
arrival_order(Z) < arrival_order(U) ::: Z arrives at some time before U
# Options
is_valid(And(arrival_order(X) == 1, arrival_order(Z) == 2, arrival_order(U) == 3, arrival_order(Y) == 4, arrival_order(W) == 5, arrival_order(S) == 6, arrival_order(T) == 7)) ::: (A)
is_valid(And(arrival_order(X) == 1, arrival_order(Y) == 2, arrival_order(Z) == 3, arrival_order(U) == 4, arrival_order(W) == 5, arrival_order(S) == 6, arrival_order(T) == 7)) ::: (B)
is_valid(And(arrival_order(Z) == 1, arrival_order(W) == 2, arrival_order(U) == 3, arrival_order(T) == 4, arrival_order(Y) == 5, arrival_order(S) == 6, arrival_order(X) == 7)) ::: (C)
is_valid(And(arrival_order(Z) == 1, arrival_order(U) == 2, arrival_order(T) == 3, arrival_order(Y) == 4, arrival_order(W) == 5, arrival_order(S) == 6, arrival_order(X) == 7)) ::: (D)
is_valid(And(arrival_order(U) == 1, arrival_order(Z) == 2, arrival_order(Y) == 3, arrival_order(T) == 4, arrival_order(S) == 5, arrival_order(W) == 6, arrival_order(X) == 7)) ::: (E)"
"# Context:
Exactly five cars—Frank's, Marquitta's, Orlando's, Taishah's, and Vinquetta's—are washed, each exactly once. The cars are washed one at a time, with each receiving exactly one kind of wash: regular, super, or premium. The following conditions must apply: The first car washed does not receive a super wash, though at least one car does. Exactly one car receives a premium wash. The second and third cars washed receive the same kind of wash as each other. Neither Orlando's nor Taishah's is washed before Vinquetta's. Marquitta's is washed before Frank's, but after Orlando's. Marquitta's and the car washed immediately before Marquitta's receive regular washes.

# Question:
If Vinquetta's car does not receive a premium wash, which one of the following must be true?

# Options:
A) Orlando's and Vinquetta's cars receive the same kind of wash as each other.
B) Marquitta's and Taishah's cars receive the same kind of wash as each other.
C) The fourth car washed receives a premium wash.
D) Orlando's car is washed third.
E) Marquitta's car is washed fourth.","# Declarations
cars = EnumSort([Frank, Marquitta, Orlando, Taishah, Vinquetta])
washes = EnumSort([regular, super, premium])
wash_order = Function([cars] -> [int])
wash_type = Function([cars] -> [washes])
# Constraints
ForAll([c:cars], Exists([c1:cars], wash_order(c1) == wash_order(c) + 1)) ::: The cars are washed one at a time
ForAll([c:cars], Exists([w:washes], wash_type(c) == w)) ::: Each car receives exactly one kind of wash
wash_type(Frank) != super ::: The first car washed does not receive a super wash
Exists([c:cars], wash_type(c) == super) ::: At least one car receives a super wash
Count([c:cars], wash_type(c) == premium) == 1 ::: Exactly one car receives a premium wash
wash_type(Frank) == wash_type(Marquitta) ::: The second and third cars washed receive the same kind of wash as each other
wash_order(Orlando) > wash_order(Vinquetta) ::: Neither Orlando's nor Taishah's is washed before Vinquetta's
wash_order(Taishah) > wash_order(Vinquetta) ::: Neither Orlando's nor Taishah's is washed before Vinquetta's
wash_order(Marquitta) > wash_order(Orlando) ::: Marquitta's is washed after Orlando's
wash_order(Marquitta) < wash_order(Frank) ::: Marquitta's is washed before Frank's
wash_type(Marquitta) == regular ::: Marquitta's and the car washed immediately before Marquitta's receive regular washes
Exists([c:cars], And(wash_order(c) == wash_order(Marquitta) - 1, wash_type(c) == regular)) ::: Marquitta's and the car washed immediately before Marquitta's receive regular washes
wash_type(Vinquetta) != premium ::: Vinquetta's car does not receive a premium wash
# Options
is_valid(wash_type(Orlando) == wash_type(Vinquetta)) ::: (A)
is_valid(wash_type(Marquitta) == wash_type(Taishah)) ::: (B)
is_valid(Exists([c:cars], And(wash_order(c) == 4, wash_type(c) == premium))) ::: (C)
is_valid(wash_order(Orlando) == 3) ::: (D)
is_valid(wash_order(Marquitta) == 4) ::: (E)"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
If the attraction included in Island is of the same type as an attraction included in Jessup, then which one of the following must be true?

# Options:
A) Hilltop has a playground.
B) Island has a museum.
C) Island has a fountain.
D) Island has a garden.
E) Jessup has a garden.","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks] -> [attractions])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p) == a)) ::: Each park has at least one attraction
ForAll([a:attractions], Exists([p:parks], has_attraction(p) == a)) ::: At least one of each type of attraction is included
ForAll([p:parks], ForAll([a:attractions], ForAll([a1:attractions], Implies(And(has_attraction(p) == a, has_attraction(p) == a1), a == a1)))) ::: No two attractions of the same type are included in any park
Count([p:parks], has_attraction(p) == garden) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup) == museum ::: Jessup has a museum but not a theater
Not(has_attraction(Jessup) == theater) ::: Jessup has a museum but not a theater
Count([a:attractions], has_attraction(Island) == a) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(Or(has_attraction(p) == playground, has_attraction(p) == fountain), Not(And(has_attraction(p) == playground, has_attraction(p) == fountain)))) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p) == theater, has_attraction(p) == garden)) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p) == museum, has_attraction(p) == playground)) ::: Each park that has a museum also has a playground
Implies(has_attraction(Island) == has_attraction(Jessup), True) ::: If the attraction included in Island is of the same type as an attraction included in Jessup
# Options
is_valid(has_attraction(Hilltop) == playground) ::: (A)
is_valid(has_attraction(Island) == museum) ::: (B)
is_valid(has_attraction(Island) == fountain) ::: (C)
is_valid(has_attraction(Island) == garden) ::: (D)
is_valid(has_attraction(Jessup) == garden) ::: (E)"
"# Context:
Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.

# Question:
Which one of the following must be true?

# Options:
A) Orozco was hired before Paton.
B) Paton was hired before Sarkis.
C) Sarkis was hired before Robinson.
D) Robinson was hired before Sarkis.
E) Madison was hired before Sarkis.","# Declarations
professors = EnumSort([Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, Togo])
years = EnumSort([1989, 1990, 1991, 1992, 1993, 1994, 1995])
specialties = EnumSort([s1, s2, s3, s4, s5, s6, s7])
hired = Function([professors] -> [years])
specialty = Function([professors, specialties] -> [bool])
# Constraints
hired(Madison) == 1993 ::: Madison was hired in 1993
hired(Robinson) == 1991 ::: Robinson was hired in 1991
Exists([s:specialties], And(specialty(Madison, s), specialty(Orozco, s), specialty(Togo, s))) ::: There is at least one specialty that Madison, Orozco, and Togo have in common
Exists([s:specialties], And(specialty(Nilsson, s), specialty(Robinson, s))) ::: Nilsson shares a specialty with Robinson
ForAll([p:professors], Implies(p == Paton, And(hired(p) < 1993, hired(p) > hired(Nilsson)))) ::: Paton was hired at least one year before Madison and at least one year after Nilsson
ForAll([p:professors], Implies(p == Sarkis, And(hired(p) < 1993, hired(p) > hired(Nilsson)))) ::: Sarkis was hired at least one year before Madison and at least one year after Nilsson
hired(Orozco) == 1990 ::: Orozco was hired in 1990
Exists([s:specialties], And(specialty(Orozco, s), specialty(Sarkis, s))) ::: Orozco shares a specialty with Sarkis
ForAll([p1:professors, p2:professors], Implies(And(p1 != p2, Or(hired(p1) == hired(p2), Abs(hired(p1) - hired(p2)) == 1)), ForAll([s:specialties], Not(And(specialty(p1, s), specialty(p2, s)))))) ::: Any two professors hired in the same year or in consecutive years do not have a specialty in common
# Options
is_valid(hired(Orozco) < hired(Paton)) ::: (A)
is_valid(hired(Paton) < hired(Sarkis)) ::: (B)
is_valid(hired(Sarkis) < hired(Robinson)) ::: (C)
is_valid(hired(Robinson) < hired(Sarkis)) ::: (D)
is_valid(hired(Madison) < hired(Sarkis)) ::: (E)"
"# Context:
From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.

# Question:
If exactly two rubies are selected, which one of the following must be true?

# Options:
A) H is selected.
B) J is selected.
C) Z is selected.
D) Exactly one sapphire is selected.
E) Exactly two topazes are selected.","# Declarations
stones = EnumSort([F, G, H, J, K, M, W, X, Y, Z])
rings = EnumSort([ring1, ring2, ring3, ring4, ring5, ring6])
selected = Function([stones] -> [bool])
# Constraints
Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) >= 2 ::: At least two of the topazes are selected
Implies(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 2, Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1) ::: If exactly two of the sapphires are selected, exactly one of the rubies is selected
Implies(selected(W), And(Not(selected(H)), Not(selected(Z)))) ::: If W is selected, neither H nor Z is selected
Implies(selected(M), selected(W)) ::: If M is selected, W is also selected
Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 2 ::: If exactly two rubies are selected
# Options
is_valid(selected(H)) ::: (A)
is_valid(selected(J)) ::: (B)
is_valid(selected(Z)) ::: (C)
is_valid(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 1) ::: (D)
is_valid(Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) == 2) ::: (E)"
"# Context:
Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.

# Question:
Which one of the following statements could be true?

# Options:
A) Seat G3 is empty.
B) Seat H2 is empty.
C) Shiro sits in a seat numbered 3.
D) Tony sits in a seat numbered 1.
E) Umeko sits in a seat numbered 3.","# Declarations
members = EnumSort([Quentin, Robert, Shiro, Tony, Umeko])
rows = EnumSort([G, H])
seats = EnumSort([1, 2, 3])
sits_in_row = Function([members] -> [rows])
sits_in_seat = Function([members] -> [seats])
# Constraints
ForAll([m:members], Exists([m1:members], And(m != m1, sits_in_row(m) == sits_in_row(m1), Abs(sits_in_seat(m) - sits_in_seat(m1)) == 1))) ::: Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family
sits_in_row(Tony) == H ::: Tony and Umeko sit in row H
sits_in_row(Umeko) == H ::: Tony and Umeko sit in row H
sits_in_seat(Shiro) < sits_in_seat(Tony) ::: Shiro and Umeko sit in lower numbered seats than does Tony
sits_in_seat(Umeko) < sits_in_seat(Tony) ::: Shiro and Umeko sit in lower numbered seats than does Tony
Or(sits_in_row(Robert) == sits_in_row(Quentin), sits_in_row(Robert) == sits_in_row(Shiro), And(sits_in_row(Robert) == sits_in_row(Quentin), sits_in_row(Robert) == sits_in_row(Shiro))) ::: Robert sits in the same row as Quentin or Shiro or both
sits_in_seat(Robert) == 2 ::: Robert sits in a seat numbered 2
# Options
is_sat(ForAll([m:members], sits_in_seat(m) != 3)) ::: (A) Seat G3 is empty
is_sat(ForAll([m:members], sits_in_seat(m) != 2)) ::: (B) Seat H2 is empty
is_sat(sits_in_seat(Shiro) == 3) ::: (C) Shiro sits in a seat numbered 3
is_sat(sits_in_seat(Tony) == 1) ::: (D) Tony sits in a seat numbered 1
is_sat(sits_in_seat(Umeko) == 3) ::: (E) Umeko sits in a seat numbered 3"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
If Z is the seventh clown to get out of the car, then which one of the following could be true?

# Options:
A) R is the second clown to get out of the car.
B) T is the fourth clown to get out of the car.
C) W is the fifth clown to get out of the car.
D) V is the sixth clown to get out of the car.
E) Y is the eighth clown to get out of the car.","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
order(Z) == 7 ::: Z is the seventh clown to get out of the car
# Options
is_valid(order(R) == 2) ::: (A)
is_valid(order(T) == 4) ::: (B)
is_valid(order(W) == 5) ::: (C)
is_valid(order(V) == 6) ::: (D)
is_valid(order(Y) == 8) ::: (E)"
"# Context:
Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.

# Question:
If Nance and Onawa are at different clinics, which one of the following must be true?

# Options:
A) Juarez is at Souderton.
B) Kudrow is at Souderton.
C) Palermo is at Randsborough.
D) Four doctors are at Souderton.
E) Four doctors are at Randsborough.","# Declarations
doctors = EnumSort([Juarez, Kudrow, Longtree, Nance, Onawa, Palermo])
clinics = EnumSort([Souderton, Randsborough])
assigned = Function([doctors] -> [clinics])
# Constraints
Implies(assigned(Juarez) == Souderton, assigned(Kudrow) == Randsborough) ::: Kudrow is at Randsborough if Juarez is at Souderton
Implies(assigned(Juarez) == Randsborough, assigned(Onawa) == Souderton) ::: Onawa is at Souderton if Juarez is at Randsborough
Implies(assigned(Longtree) == Souderton, And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: If Longtree is at Souderton, then both Nance and Palermo are at Randsborough
Implies(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough) ::: If Nance is at Randsborough, then so is Onawa
Implies(assigned(Palermo) == Randsborough, And(assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton)) ::: If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton
assigned(Nance) != assigned(Onawa) ::: Nance and Onawa are at different clinics
# Options
is_valid(assigned(Juarez) == Souderton) ::: (A)
is_valid(assigned(Kudrow) == Souderton) ::: (B)
is_valid(assigned(Palermo) == Randsborough) ::: (C)
is_valid(Count([d:doctors], assigned(d) == Souderton) == 4) ::: (D)
is_valid(Count([d:doctors], assigned(d) == Randsborough) == 4) ::: (E)"
"# Context:
An airline has four flights from New York to Sarasota—flights 1, 2, 3, and 4. On each flight there is exactly one pilot and exactly one co-pilot. The pilots are Fazio, Germond, Kyle, and Lopez; the co-pilots are Reich, Simon, Taylor, and Umlas. Each pilot and co-pilot is assigned to exactly one flight. The flights take off in numerical order. Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights. Kyle is assigned to flight 2. Lopez is assigned to the same flight as Umlas.

# Question:
What is the maximum possible number of different pilot and co-pilot teams, any one of which could be assigned to flight 4?

# Options:
A) 2
B) 3
C) 4
D) 5
E) 6","# Declarations
flights = EnumSort([flight1, flight2, flight3, flight4])
pilots = EnumSort([Fazio, Germond, Kyle, Lopez])
co_pilots = EnumSort([Reich, Simon, Taylor, Umlas])
assigned_pilot = Function([flights] -> [pilots])
assigned_co_pilot = Function([flights] -> [co_pilots])
# Constraints
ForAll([f:flights], Exists([p:pilots], assigned_pilot(f) == p)) ::: Each flight has exactly one pilot
ForAll([f:flights], Exists([cp:co_pilots], assigned_co_pilot(f) == cp)) ::: Each flight has exactly one co-pilot
assigned_pilot(flight2) == Kyle ::: Kyle is assigned to flight 2
assigned_pilot(flight1) == Fazio ::: Fazio's flight takes off before Germond's
assigned_pilot(flight3) == Germond ::: at least one other flight takes off between their flights
assigned_pilot(flight4) == Lopez ::: Lopez is assigned to the same flight as Umlas
assigned_co_pilot(flight4) == Umlas ::: Lopez is assigned to the same flight as Umlas
# Options
is_valid(Count([p:pilots, cp:co_pilots], And(assigned_pilot(flight4) == p, assigned_co_pilot(flight4) == cp)) == 2) ::: (A)
is_valid(Count([p:pilots, cp:co_pilots], And(assigned_pilot(flight4) == p, assigned_co_pilot(flight4) == cp)) == 3) ::: (B)
is_valid(Count([p:pilots, cp:co_pilots], And(assigned_pilot(flight4) == p, assigned_co_pilot(flight4) == cp)) == 4) ::: (C)
is_valid(Count([p:pilots, cp:co_pilots], And(assigned_pilot(flight4) == p, assigned_co_pilot(flight4) == cp)) == 5) ::: (D)
is_valid(Count([p:pilots, cp:co_pilots], And(assigned_pilot(flight4) == p, assigned_co_pilot(flight4) == cp)) == 6) ::: (E)"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
Which one of the following could be true?

# Options:
A) Y is the second clown to get out of the car.
B) R is the third clown to get out of the car.
C) Q is the fourth clown to get out of the car.
D) S is the fifth clown to get out of the car.
E) V is the sixth clown to get out of the car.","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
# Options
is_sat(order(Y) == 2) ::: (A)
is_sat(order(R) == 3) ::: (B)
is_sat(order(Q) == 4) ::: (C)
is_sat(order(S) == 5) ::: (D)
is_sat(order(V) == 6) ::: (E)"
"# Context:
Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.

# Question:
If Tony sits in a seat numbered 2, then which one of the following statements could be false?

# Options:
A) Quentin sits in a seat numbered 3.
B) Umeko sits in a seat numbered 1.
C) Quentin sits in the same row as, and in a seat adjacent to, Robert.
D) Robert sits in the same row as, and in a seat adjacent to, Shiro.
E) Tony sits in the same row as, and in a seat adjacent to, Umeko.","# Declarations
members = EnumSort([Quentin, Robert, Shiro, Tony, Umeko])
rows = EnumSort([G, H])
seats = EnumSort([1, 2, 3])
sits_in_row = Function([members] -> [rows])
sits_in_seat = Function([members] -> [seats])
# Constraints
ForAll([m:members], Exists([m1:members], And(m != m1, sits_in_row(m) == sits_in_row(m1), Or(sits_in_seat(m) == sits_in_seat(m1) + 1, sits_in_seat(m) == sits_in_seat(m1) - 1)))) ::: Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family
sits_in_row(Tony) == H ::: Tony and Umeko sit in row H
sits_in_row(Umeko) == H ::: Tony and Umeko sit in row H
sits_in_seat(Shiro) < sits_in_seat(Tony) ::: Shiro and Umeko sit in lower numbered seats than does Tony
sits_in_seat(Umeko) < sits_in_seat(Tony) ::: Shiro and Umeko sit in lower numbered seats than does Tony
Or(sits_in_row(Robert) == sits_in_row(Quentin), sits_in_row(Robert) == sits_in_row(Shiro), And(sits_in_row(Robert) == sits_in_row(Quentin), sits_in_row(Robert) == sits_in_row(Shiro))) ::: Robert sits in the same row as Quentin or Shiro or both
sits_in_seat(Robert) == 2 ::: Robert sits in a seat numbered 2
sits_in_seat(Tony) == 2 ::: If Tony sits in a seat numbered 2
# Options
is_valid(sits_in_seat(Quentin) == 3) ::: (A)
is_valid(sits_in_seat(Umeko) == 1) ::: (B)
is_valid(And(sits_in_row(Quentin) == sits_in_row(Robert), Or(sits_in_seat(Quentin) == sits_in_seat(Robert) + 1, sits_in_seat(Quentin) == sits_in_seat(Robert) - 1))) ::: (C)
is_valid(And(sits_in_row(Robert) == sits_in_row(Shiro), Or(sits_in_seat(Robert) == sits_in_seat(Shiro) + 1, sits_in_seat(Robert) == sits_in_seat(Shiro) - 1))) ::: (D)
is_valid(And(sits_in_row(Tony) == sits_in_row(Umeko), Or(sits_in_seat(Tony) == sits_in_seat(Umeko) + 1, sits_in_seat(Tony) == sits_in_seat(Umeko) - 1))) ::: (E)"
"# Context:
A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.

# Question:
If the Hausa grammar and the phonology monograph are on the same shelf, which one of the following must be true?

# Options:
A) The phonology monograph is on the third shelf.
B) The Vonnegut novel is on the second shelf.
C) The semantics monograph is on the second shelf.
D) The semantics monograph is on the first shelf.
E) The Woolf novel is on the third shelf.","# Declarations
shelves = EnumSort([first, second, third])
books = EnumSort([FarsiGrammar, HausaGrammar, PhonologyMonograph, SemanticsMonograph, VonnegutNovel, WoolfNovel])
located = Function([books] -> [shelves])
# Constraints
located(FarsiGrammar) != located(HausaGrammar) ::: Two of the books are grammars—one of Farsi, the other of Hausa
located(PhonologyMonograph) != located(SemanticsMonograph) ::: Two others are linguistics monographs—one on phonology, the other on semantics
located(VonnegutNovel) != located(PhonologyMonograph) ::: The Vonnegut novel is not on the same shelf as either monograph
located(VonnegutNovel) != located(SemanticsMonograph) ::: The Vonnegut novel is not on the same shelf as either monograph
Exists([b:books], And(b == VonnegutNovel or b == WoolfNovel, located(b) == located(FarsiGrammar))) ::: There is at least one novel on the same shelf as the Farsi grammar
located(HausaGrammar) == located(PhonologyMonograph) ::: If the Hausa grammar and the phonology monograph are on the same shelf
# Options
is_valid(located(PhonologyMonograph) == third) ::: (A)
is_valid(located(VonnegutNovel) == second) ::: (B)
is_valid(located(SemanticsMonograph) == second) ::: (C)
is_valid(located(SemanticsMonograph) == first) ::: (D)
is_valid(located(WoolfNovel) == third) ::: (E)"
"# Context:
Each of seven television programs—H, J, L, P, Q, S, V—is assigned a different rank: from first through seventh (from most popular to least popular). The ranking is consistent with the following conditions: J and L are each less popular than H. J is more popular than Q. S and V are each less popular than L. P and S are each less popular than Q. S is not seventh.

# Question:
If V is more popular than Q and J is less popular than L, then which one of the following could be true of the ranking?

# Options:
A) P is more popular than S.
B) S is more popular than V.
C) P is more popular than L.
D) J is more popular than V.
E) Q is more popular than V.","# Declarations
programs = EnumSort([H, J, L, P, Q, S, V])
rank = Function([programs] -> [int])
# Constraints
ForAll([p1:programs, p2:programs], Implies(p1 != p2, rank(p1) != rank(p2))) ::: Each program is assigned a different rank
rank(J) < rank(H) ::: J is less popular than H
rank(L) < rank(H) ::: L is less popular than H
rank(J) > rank(Q) ::: J is more popular than Q
rank(S) < rank(L) ::: S is less popular than L
rank(V) < rank(L) ::: V is less popular than L
rank(P) < rank(Q) ::: P is less popular than Q
rank(S) < rank(Q) ::: S is less popular than Q
rank(S) != 7 ::: S is not seventh
rank(V) > rank(Q) ::: V is more popular than Q
rank(J) < rank(L) ::: J is less popular than L
# Options
is_valid(rank(P) > rank(S)) ::: (A)
is_valid(rank(S) > rank(V)) ::: (B)
is_valid(rank(P) > rank(L)) ::: (C)
is_valid(rank(J) > rank(V)) ::: (D)
is_valid(rank(Q) > rank(V)) ::: (E)"
"# Context:
Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.

# Question:
Which one of the following clerks could stock two consecutive aisles?

# Options:
A) Jill
B) Kurt
C) Larisa
D) Manny
E) Olga","# Declarations
clerks = EnumSort([Jill, Kurt, Larisa, Manny, Olga])
aisles = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
stocks = Function([clerks] -> [aisles])
# Constraints
ForAll([a:aisles], Exists([c:clerks], stocks(c) == a)) ::: Each aisle is stocked by exactly one clerk
Count([a:aisles], stocks(Olga) == a) == 1 ::: Olga stocks exactly one aisle
stocks(Kurt) == 2 ::: Kurt stocks aisle 2
ForAll([a:aisles], stocks(Manny) != 1) ::: Manny does not stock aisle 1
ForAll([a:aisles], Implies(stocks(Jill) == a, Not(Exists([a1:aisles], And(a1 == a + 1, stocks(Jill) == a1))))) ::: Jill does not stock consecutive aisles
Exists([a:aisles], And(stocks(Manny) == a, stocks(Kurt) == a + 1)) ::: Kurt stocks the only aisle between the two aisles Manny stocks
Exists([a:aisles], And(stocks(Larisa) == a, Or(a == 1, a == 9))) ::: Exactly one of Larisa's aisles is an end aisle
ForAll([a:aisles], Implies(stocks(Olga) == a, And(a > 2, Exists([a1:aisles], And(stocks(Larisa) == a1, a < a1))))) ::: Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's
# Options
is_valid(Exists([a:aisles], And(stocks(Jill) == a, stocks(Jill) == a + 1))) ::: (A)
is_valid(Exists([a:aisles], And(stocks(Kurt) == a, stocks(Kurt) == a + 1))) ::: (B)
is_valid(Exists([a:aisles], And(stocks(Larisa) == a, stocks(Larisa) == a + 1))) ::: (C)
is_valid(Exists([a:aisles], And(stocks(Manny) == a, stocks(Manny) == a + 1))) ::: (D)
is_valid(Exists([a:aisles], And(stocks(Olga) == a, stocks(Olga) == a + 1))) ::: (E)"
"# Context:
A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.

# Question:
Which one of the following, if known, would allow one to determine the entire lecture schedule and identify for each week the philosopher who is lectured on that week?

# Options:
A) the weeks that Kant, Locke, and Mill are lectured on
B) the weeks that Kant, Mill, and Nietzsche are lectured on
C) the weeks that Kant, Mill, and Ockham are lectured on
D) the weeks that Mill, Nietzsche, and Ockham are lectured on
E) the weeks that Mill, Nietzsche, and Plato are lectured on","# Declarations
weeks = EnumSort([week1, week2, week3, week4, week5])
philosophers = EnumSort([Kant, Locke, Mill, Nietzsche, Ockham, Plato])
speakers = EnumSort([speaker1, speaker2, speaker3, speaker4, speaker5])
lectures = Function([weeks] -> [philosophers])
specializes = Function([speakers] -> [philosophers])
# Constraints
ForAll([w:weeks], Exists([p:philosophers], lectures(w) == p)) ::: Each week has exactly one lecture
ForAll([p:philosophers], Exists([w:weeks], lectures(w) == p)) ::: Each philosopher is lectured on exactly once
ForAll([s:speakers], Exists([p:philosophers], specializes(s) == p)) ::: Each speaker specializes in exactly one philosopher
ForAll([p:philosophers], Exists([s:speakers], specializes(s) == p)) ::: Each philosopher is specialized in by exactly one speaker
ForAll([w:weeks], specializes(speaker1) == Kant or specializes(speaker1) == Locke or specializes(speaker1) == Mill) ::: The first week's speaker specializes in Kant, Locke, and Mill
ForAll([w:weeks], specializes(speaker2) == Kant or specializes(speaker2) == Locke or specializes(speaker2) == Mill or specializes(speaker2) == Nietzsche) ::: The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche
ForAll([w:weeks], specializes(speaker3) == Mill or specializes(speaker3) == Nietzsche) ::: The third week's speaker specializes in Mill and Nietzsche
ForAll([w:weeks], specializes(speaker4) == Mill or specializes(speaker4) == Nietzsche) ::: The fourth week's speaker specializes in Mill and Nietzsche
ForAll([w:weeks], specializes(speaker5) == Nietzsche or specializes(speaker5) == Ockham or specializes(speaker5) == Plato) ::: The fifth week's speaker specializes in Nietzsche, Ockham, and Plato
# Options
is_valid(And(Exists([w:weeks], lectures(w) == Kant), Exists([w:weeks], lectures(w) == Locke), Exists([w:weeks], lectures(w) == Mill))) ::: (A)
is_valid(And(Exists([w:weeks], lectures(w) == Kant), Exists([w:weeks], lectures(w) == Mill), Exists([w:weeks], lectures(w) == Nietzsche))) ::: (B)
is_valid(And(Exists([w:weeks], lectures(w) == Kant), Exists([w:weeks], lectures(w) == Mill), Exists([w:weeks], lectures(w) == Ockham))) ::: (C)
is_valid(And(Exists([w:weeks], lectures(w) == Mill), Exists([w:weeks], lectures(w) == Nietzsche), Exists([w:weeks], lectures(w) == Ockham))) ::: (D)
is_valid(And(Exists([w:weeks], lectures(w) == Mill), Exists([w:weeks], lectures(w) == Nietzsche), Exists([w:weeks], lectures(w) == Plato))) ::: (E)"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
If Hilltop has exactly three attractions, then each of the following could be true EXCEPT:

# Options:
A) Hilltop has a museum.
B) Hilltop has a playground.
C) Island does not have a fountain.
D) Island has a garden.
E) Jessup has a garden.","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks, attractions] -> [bool])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p, a))) ::: Each park has at least one attraction
Exists([a:attractions], ForAll([p:parks], Exists([p1:parks], And(p1 != p, has_attraction(p1, a))))) ::: Among the three parks at least one of each type of attraction is included
ForAll([p:parks, a:attractions], Implies(has_attraction(p, a), ForAll([a1:attractions], Implies(a1 == a, Not(has_attraction(p, a1)))))) ::: No two attractions of the same type are included in any park
Count([p:parks], Exists([a:attractions], has_attraction(p, garden))) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup, museum) ::: Jessup has a museum
Not(has_attraction(Jessup, theater)) ::: Jessup does not have a theater
Count([a:attractions], has_attraction(Island, a)) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(And(has_attraction(p, playground), has_attraction(p, fountain)), False)) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p, theater), has_attraction(p, garden))) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p, museum), has_attraction(p, playground))) ::: Each park that has a museum also has a playground
Count([a:attractions], has_attraction(Hilltop, a)) == 3 ::: Hilltop has exactly three attractions
# Options
is_unsat(has_attraction(Hilltop, museum)) ::: (A)
is_unsat(has_attraction(Hilltop, playground)) ::: (B)
is_unsat(Not(has_attraction(Island, fountain))) ::: (C)
is_unsat(has_attraction(Island, garden)) ::: (D)
is_unsat(has_attraction(Jessup, garden)) ::: (E)"
"# Context:
Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.

# Question:
What is the minimum number of doctors that could be at Souderton?

# Options:
A) zero
B) one
C) two
D) three
E) four","# Declarations
doctors = EnumSort([Juarez, Kudrow, Longtree, Nance, Onawa, Palermo])
clinics = EnumSort([Souderton, Randsborough])
assigned = Function([doctors] -> [clinics])
# Constraints
Implies(assigned(Juarez) == Souderton, assigned(Kudrow) == Randsborough) ::: Kudrow is at Randsborough if Juarez is at Souderton
Implies(assigned(Juarez) == Randsborough, assigned(Onawa) == Souderton) ::: Onawa is at Souderton if Juarez is at Randsborough
Implies(assigned(Longtree) == Souderton, And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: If Longtree is at Souderton, then both Nance and Palermo are at Randsborough
Implies(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough) ::: If Nance is at Randsborough, then so is Onawa
Implies(assigned(Palermo) == Randsborough, And(assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton)) ::: If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton
# Options
is_sat(Count([d:doctors], assigned(d) == Souderton) == 0) ::: (A)
is_sat(Count([d:doctors], assigned(d) == Souderton) == 1) ::: (B)
is_sat(Count([d:doctors], assigned(d) == Souderton) == 2) ::: (C)
is_sat(Count([d:doctors], assigned(d) == Souderton) == 3) ::: (D)
is_sat(Count([d:doctors], assigned(d) == Souderton) == 4) ::: (E)"
"# Context:
A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.

# Question:
Which one of the following could be the order, from first to last, in which the clowns get out of the car?

# Options:
A) T, Z, V, R, W, Y, S, Q
B) Z, R, W, Q, T, V, Y, S
C) R, W, T, V, Q, Z, S, Y
D) Z, W, R, T, V, Y, Q, S
E) R, W, T, V, Z, S, Y, Q","# Declarations
clowns = EnumSort([Q, R, S, T, V, W, Y, Z])
order = Function([clowns] -> [int])
# Constraints
order(V) < order(Y) ::: V gets out at some time before both Y and Q
order(V) < order(Q) ::: V gets out at some time before both Y and Q
order(Q) > order(Z) ::: Q gets out at some time after Z
order(T) < order(V) ::: T gets out at some time before V but at some time after R
order(T) > order(R) ::: T gets out at some time before V but at some time after R
order(S) > order(V) ::: S gets out at some time after V
order(R) < order(W) ::: R gets out at some time before W
# Options
is_sat(And(order(T) == 1, order(Z) == 2, order(V) == 3, order(R) == 4, order(W) == 5, order(Y) == 6, order(S) == 7, order(Q) == 8)) ::: (A)
is_sat(And(order(Z) == 1, order(R) == 2, order(W) == 3, order(Q) == 4, order(T) == 5, order(V) == 6, order(Y) == 7, order(S) == 8)) ::: (B)
is_sat(And(order(R) == 1, order(W) == 2, order(T) == 3, order(V) == 4, order(Q) == 5, order(Z) == 6, order(S) == 7, order(Y) == 8)) ::: (C)
is_sat(And(order(Z) == 1, order(W) == 2, order(R) == 3, order(T) == 4, order(V) == 5, order(Y) == 6, order(Q) == 7, order(S) == 8)) ::: (D)
is_sat(And(order(R) == 1, order(W) == 2, order(T) == 3, order(V) == 4, order(Z) == 5, order(S) == 6, order(Y) == 7, order(Q) == 8)) ::: (E)"
"# Context:
Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.

# Question:
If exactly two professors were hired in 1992, then which one of the following could be true?

# Options:
A) Orozco, Paton, and Togo share a specialty.
B) Madison, Paton, and Togo share a specialty.
C) Exactly two professors were hired in 1991.
D) Exactly two professors were hired in 1993.
E) Paton was hired in 1991.","# Declarations
professors = EnumSort([Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, Togo])
years = EnumSort([1989, 1990, 1991, 1992, 1993, 1994, 1995])
specialties = EnumSort([specialty1, specialty2, specialty3, specialty4, specialty5, specialty6, specialty7])
hired_in = Function([professors] -> [years])
has_specialty = Function([professors, specialties] -> [bool])
# Constraints
ForAll([p:professors], Exists([y:years], hired_in(p) == y)) ::: Each professor was hired in exactly one year
ForAll([p1:professors, p2:professors], Implies(And(hired_in(p1) == hired_in(p2), p1 != p2), ForAll([s:specialties], Not(And(has_specialty(p1, s), has_specialty(p2, s)))))) ::: Any two professors hired in the same year do not have a specialty in common
ForAll([p1:professors, p2:professors], Implies(And(Abs(hired_in(p1) - hired_in(p2)) == 1, p1 != p2), ForAll([s:specialties], Not(And(has_specialty(p1, s), has_specialty(p2, s)))))) ::: Any two professors hired in consecutive years do not have a specialty in common
hired_in(Madison) == 1993 ::: Madison was hired in 1993
hired_in(Robinson) == 1991 ::: Robinson was hired in 1991
Exists([s:specialties], And(has_specialty(Madison, s), has_specialty(Orozco, s), has_specialty(Togo, s))) ::: There is at least one specialty that Madison, Orozco, and Togo have in common
Exists([s:specialties], And(has_specialty(Nilsson, s), has_specialty(Robinson, s))) ::: Nilsson shares a specialty with Robinson
hired_in(Paton) > hired_in(Nilsson) ::: Paton was hired at least one year after Nilsson
hired_in(Paton) < 1993 ::: Paton was hired at least one year before Madison
hired_in(Sarkis) > hired_in(Nilsson) ::: Sarkis was hired at least one year after Nilsson
hired_in(Sarkis) < 1993 ::: Sarkis was hired at least one year before Madison
hired_in(Orozco) == 1990 ::: Orozco was hired in 1990
Exists([s:specialties], And(has_specialty(Orozco, s), has_specialty(Sarkis, s))) ::: Orozco shares a specialty with Sarkis
Count([p:professors], hired_in(p) == 1992) == 2 ::: Exactly two professors were hired in 1992
# Options
is_valid(Exists([s:specialties], And(has_specialty(Orozco, s), has_specialty(Paton, s), has_specialty(Togo, s)))) ::: (A)
is_valid(Exists([s:specialties], And(has_specialty(Madison, s), has_specialty(Paton, s), has_specialty(Togo, s)))) ::: (B)
is_valid(Count([p:professors], hired_in(p) == 1991) == 2) ::: (C)
is_valid(Count([p:professors], hired_in(p) == 1993) == 2) ::: (D)
is_valid(hired_in(Paton) == 1991) ::: (E)"
"# Context:
A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.

# Question:
Which one of the following statements could be true?

# Options:
A) The first speaker lectures on Mill.
B) The second speaker lectures on Mill.
C) The second speaker lectures on Nietzsche.
D) The fifth speaker lectures on Nietzsche.
E) The fifth speaker lectures on Ockham.","# Declarations
weeks = EnumSort([week1, week2, week3, week4, week5])
philosophers = EnumSort([Kant, Locke, Mill, Nietzsche, Ockham, Plato])
speakers = EnumSort([speaker1, speaker2, speaker3, speaker4, speaker5])
specializes = Function([speakers] -> [philosophers])
lectures = Function([weeks] -> [philosophers])
# Constraints
ForAll([w:weeks], Exists([s:speakers], specializes(s) == lectures(w))) ::: Each lecture is delivered by a different speaker
ForAll([w1:weeks, w2:weeks], Implies(w1 != w2, lectures(w1) != lectures(w2))) ::: No lecture is given more than once
ForAll([s1:speakers, s2:speakers], Implies(s1 != s2, specializes(s1) != specializes(s2))) ::: No two speakers lecture on the same philosopher
Or(specializes(speaker1) == Kant, specializes(speaker1) == Locke, specializes(speaker1) == Mill) ::: The first week's speaker specializes in Kant, Locke, and Mill
Or(specializes(speaker2) == Kant, specializes(speaker2) == Locke, specializes(speaker2) == Mill, specializes(speaker2) == Nietzsche) ::: The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche
Or(specializes(speaker3) == Mill, specializes(speaker3) == Nietzsche) ::: The third week's speaker specializes in Mill and Nietzsche
Or(specializes(speaker4) == Mill, specializes(speaker4) == Nietzsche) ::: The fourth week's speaker specializes in Mill and Nietzsche
Or(specializes(speaker5) == Nietzsche, specializes(speaker5) == Ockham, specializes(speaker5) == Plato) ::: The fifth week's speaker specializes in Nietzsche, Ockham, and Plato
# Options
is_sat(lectures(week1) == Mill) ::: (A)
is_sat(lectures(week2) == Mill) ::: (B)
is_sat(lectures(week2) == Nietzsche) ::: (C)
is_sat(lectures(week5) == Nietzsche) ::: (D)
is_sat(lectures(week5) == Ockham) ::: (E)"
"# Context:
In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.

# Question:
For which one of the following pairs of trucks is it the case that they CANNOT both be red?

# Options:
A) S and X
B) T and S
C) U and W
D) W and T
E) X and Z","# Declarations
trucks = EnumSort([S, T, U, W, X, Y, Z])
colors = EnumSort([green, red])
arrival_order = Function([trucks] -> [int])
truck_color = Function([trucks] -> [colors])
# Constraints
ForAll([t:trucks], arrival_order(t) >= 1) ::: Each truck arrives at some time
ForAll([t:trucks], arrival_order(t) <= 7) ::: Each truck arrives at some time
ForAll([t1:trucks, t2:trucks], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: No truck arrives at the same time as any other truck
ForAll([t:trucks], Or(truck_color(t) == green, truck_color(t) == red)) ::: Each truck is either green or red
ForAll([t1:trucks, t2:trucks], Implies(And(arrival_order(t1) + 1 == arrival_order(t2), truck_color(t1) == red), truck_color(t2) != red)) ::: No two consecutive arrivals are red
arrival_order(Y) < arrival_order(T) ::: Y arrives at some time before T
arrival_order(Y) < arrival_order(W) ::: Y arrives at some time before W
Count([t:trucks], And(arrival_order(t) < arrival_order(Y), truck_color(t) == red)) == 2 ::: Exactly two of the trucks that arrive before Y are red
arrival_order(S) == 6 ::: S is the sixth arrival
arrival_order(Z) < arrival_order(U) ::: Z arrives at some time before U
# Options
is_unsat(And(truck_color(S) == red, truck_color(X) == red)) ::: (A)
is_unsat(And(truck_color(T) == red, truck_color(S) == red)) ::: (B)
is_unsat(And(truck_color(U) == red, truck_color(W) == red)) ::: (C)
is_unsat(And(truck_color(W) == red, truck_color(T) == red)) ::: (D)
is_unsat(And(truck_color(X) == red, truck_color(Z) == red)) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
If Medici ranks lower than Lautrec, then which one of the following must be true?

# Options:
A) Lautrec ranks higher than Tantoko.
B) Scheherazade's ranks higher than Vistula.
C) Pastilla ranks higher than Tantoko.
D) Tantoko ranks higher than Scheherazade's.
E) Tantoko ranks higher than Pastilla.","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazades, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazades) > rank(Pastilla), rank(Medici) > rank(Scheherazades)) ::: If Scheherazades ranks higher than Pastilla, Medici ranks higher than Scheherazades
Implies(rank(Medici) > rank(Scheherazades), rank(Scheherazades) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazades, Scheherazades ranks higher than Pastilla
rank(Medici) < rank(Lautrec) ::: Medici ranks lower than Lautrec
# Options
is_valid(rank(Lautrec) > rank(Tantoko)) ::: (A)
is_valid(rank(Scheherazades) > rank(Vistula)) ::: (B)
is_valid(rank(Pastilla) > rank(Tantoko)) ::: (C)
is_valid(rank(Tantoko) > rank(Scheherazades)) ::: (D)
is_valid(rank(Tantoko) > rank(Pastilla)) ::: (E)"
"# Context:
A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.

# Question:
If the Farsi grammar is not on the third shelf, which one of the following could be true?

# Options:
A) The phonology monograph is on the second shelf.
B) The Hausa grammar is on the second shelf.
C) The semantics monograph is on the third shelf.
D) The Vonnegut novel is on the third shelf.
E) The Woolf novel is on the second shelf.","# Declarations
shelves = EnumSort([first, second, third])
books = EnumSort([FarsiGrammar, HausaGrammar, PhonologyMonograph, SemanticsMonograph, VonnegutNovel, WoolfNovel])
located = Function([books] -> [shelves])
# Constraints
located(FarsiGrammar) != third ::: The Farsi grammar is not on the third shelf
Count([b:books], located(b) == first) == 1 ::: one book on the first shelf
Count([b:books], located(b) == second) == 2 ::: two books on the second shelf
Count([b:books], located(b) == third) == 3 ::: three books on the third shelf
Exists([b:books], And(Or(b == VonnegutNovel, b == WoolfNovel), located(b) == located(FarsiGrammar))) ::: There is at least one novel on the same shelf as the Farsi grammar
located(PhonologyMonograph) != located(SemanticsMonograph) ::: The monographs are not both on the same shelf
located(VonnegutNovel) != located(PhonologyMonograph) ::: The Vonnegut novel is not on the same shelf as the phonology monograph
located(VonnegutNovel) != located(SemanticsMonograph) ::: The Vonnegut novel is not on the same shelf as the semantics monograph
# Options
is_valid(located(PhonologyMonograph) == second) ::: (A)
is_valid(located(HausaGrammar) == second) ::: (B)
is_valid(located(SemanticsMonograph) == third) ::: (C)
is_valid(located(VonnegutNovel) == third) ::: (D)
is_valid(located(WoolfNovel) == second) ::: (E)"
"# Context:
Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.

# Question:
If Palermo is at Randsborough, then which one of the following must be true?

# Options:
A) Juarez is at Randsborough.
B) Kudrow is at Randsborough.
C) Longtree is at Souderton.
D) Nance is at Randsborough.
E) Onawa is at Randsborough.","# Declarations
doctors = EnumSort([Juarez, Kudrow, Longtree, Nance, Onawa, Palermo])
clinics = EnumSort([Souderton, Randsborough])
assigned = Function([doctors] -> [clinics])
# Constraints
Implies(assigned(Juarez) == Souderton, assigned(Kudrow) == Randsborough) ::: Kudrow is at Randsborough if Juarez is at Souderton
Implies(assigned(Juarez) == Randsborough, assigned(Onawa) == Souderton) ::: Onawa is at Souderton if Juarez is at Randsborough
Implies(assigned(Longtree) == Souderton, And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: If Longtree is at Souderton, then both Nance and Palermo are at Randsborough
Implies(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough) ::: If Nance is at Randsborough, then so is Onawa
Implies(assigned(Palermo) == Randsborough, And(assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton)) ::: If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton
# Options
is_valid(assigned(Juarez) == Randsborough) ::: (A)
is_valid(assigned(Kudrow) == Randsborough) ::: (B)
is_valid(assigned(Longtree) == Souderton) ::: (C)
is_valid(assigned(Nance) == Randsborough) ::: (D)
is_valid(assigned(Onawa) == Randsborough) ::: (E)"
"# Context:
There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.

# Question:
If green lights decorate five stores on the street, then which one of the following statements must be true?

# Options:
A) Green lights decorate store 9.
B) Red lights decorate store 2.
C) Red lights decorate store 7.
D) Red lights decorate store 10.
E) Yellow lights decorate store 8.","# Declarations
stores = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
colors = EnumSort([green, red, yellow])
decorated = Function([stores] -> [colors])
# Constraints
ForAll([s:stores], Exists([c:colors], decorated(s) == c)) ::: Each store is decorated with lights in exactly one color
ForAll([s:stores], Implies(s != 1, decorated(s) != decorated(s-1))) ::: No store is decorated with lights of the same color as those of any store adjacent to it
ForAll([s:stores], decorated(s) != decorated(s+1)) ::: No store is decorated with lights of the same color as those of any store adjacent to it
ForAll([s:stores], decorated(s) != decorated(s+5)) ::: No store is decorated with lights of the same color as those of the store directly across the street from it
Count([s:stores], decorated(s) == yellow) == 2 ::: Yellow lights decorate exactly one store on each side of the street
decorated(4) == red ::: Red lights decorate store 4
decorated(5) == yellow ::: Yellow lights decorate store 5
Count([s:stores], decorated(s) == green) == 5 ::: Green lights decorate five stores on the street
# Options
is_valid(decorated(9) == green) ::: (A)
is_valid(decorated(2) == red) ::: (B)
is_valid(decorated(7) == red) ::: (C)
is_valid(decorated(10) == red) ::: (D)
is_valid(decorated(8) == yellow) ::: (E)"
"# Context:
There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.

# Question:
Suppose that yellow lights decorate exactly two stores, not just one, on the south side of the street and decorate exactly one store on the north side. If all of the other conditions remain the same, then which one of the following statements must be true?

# Options:
A) Green lights decorate store 1.
B) Red lights decorate store 7.
C) Red lights decorate store 10.
D) Yellow lights decorate store 2.
E) Yellow lights decorate store 8.","# Declarations
stores = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
colors = EnumSort([green, red, yellow])
decorated = Function([stores] -> [colors])
# Constraints
ForAll([s:stores], Exists([c:colors], decorated(s) == c)) ::: Each store is decorated with lights in exactly one color
ForAll([s:stores], decorated(s) != decorated(s + 1)) ::: No store is decorated with lights of the same color as those of any store adjacent to it
ForAll([s:stores], decorated(s) != decorated(s + 1)) ::: No store is decorated with lights of the same color as those of the store directly across the street from it
Count([s:stores], And(s % 2 == 0, decorated(s) == yellow)) == 2 ::: Yellow lights decorate exactly two stores on the south side of the street
Count([s:stores], And(s % 2 != 0, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the north side of the street
decorated(4) == red ::: Red lights decorate store 4
decorated(5) == yellow ::: Yellow lights decorate store 5
# Options
is_valid(decorated(1) == green) ::: (A)
is_valid(decorated(7) == red) ::: (B)
is_valid(decorated(10) == red) ::: (C)
is_valid(decorated(2) == yellow) ::: (D)
is_valid(decorated(8) == yellow) ::: (E)"
"# Context:
From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.

# Question:
Which one of the following must be true?

# Options:
A) The selection of stones includes at least one ruby.
B) The selection of stones includes at most two rubies.
C) The selection of stones includes either F or Z, or both.
D) The selection of stones includes either X or Y, or both.
E) The selection of stones includes either X or Z, or both.","# Declarations
stones = EnumSort([F, G, H, J, K, M, W, X, Y, Z])
selected = Function([stones] -> [bool])
# Constraints
Count([s:stones], selected(s)) == 6 ::: a jeweler will select six stones
Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) >= 2 ::: At least two of the topazes are selected
Implies(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 2, Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1) ::: If exactly two of the sapphires are selected, exactly one of the rubies is selected
Implies(selected(W), And(Not(selected(H)), Not(selected(Z)))) ::: If W is selected, neither H nor Z is selected
Implies(selected(M), selected(W)) ::: If M is selected, W is also selected
# Options
is_valid(Exists([s:stones], And(selected(s), Or(s == F, s == G, s == H)))) ::: (A) The selection of stones includes at least one ruby
is_valid(Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) <= 2) ::: (B) The selection of stones includes at most two rubies
is_valid(Or(selected(F), selected(Z))) ::: (C) The selection of stones includes either F or Z, or both
is_valid(Or(selected(X), selected(Y))) ::: (D) The selection of stones includes either X or Y, or both
is_valid(Or(selected(X), selected(Z))) ::: (E) The selection of stones includes either X or Z, or both"
"# Context:
Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.

# Question:
Which one of the following could be a complete and accurate list of the doctors that are at Souderton?

# Options:
A) Juarez, Kudrow, Onawa
B) Juarez, Nance, Onawa, Palermo
C) Kudrow, Longtree, Onawa
D) Nance, Onawa
E) Nance, Palermo","# Declarations
doctors = EnumSort([Juarez, Kudrow, Longtree, Nance, Onawa, Palermo])
clinics = EnumSort([Souderton, Randsborough])
assigned = Function([doctors] -> [clinics])
# Constraints
Implies(assigned(Juarez) == Souderton, assigned(Kudrow) == Randsborough) ::: Kudrow is at Randsborough if Juarez is at Souderton
Implies(assigned(Juarez) == Randsborough, assigned(Onawa) == Souderton) ::: Onawa is at Souderton if Juarez is at Randsborough
Implies(assigned(Longtree) == Souderton, And(assigned(Nance) == Randsborough, assigned(Palermo) == Randsborough)) ::: If Longtree is at Souderton, then both Nance and Palermo are at Randsborough
Implies(assigned(Nance) == Randsborough, assigned(Onawa) == Randsborough) ::: If Nance is at Randsborough, then so is Onawa
Implies(assigned(Palermo) == Randsborough, And(assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton)) ::: If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton
# Options
is_accurate_list([assigned(Juarez) == Souderton, assigned(Kudrow) == Souderton, assigned(Onawa) == Souderton]) ::: (A)
is_accurate_list([assigned(Juarez) == Souderton, assigned(Nance) == Souderton, assigned(Onawa) == Souderton, assigned(Palermo) == Souderton]) ::: (B)
is_accurate_list([assigned(Kudrow) == Souderton, assigned(Longtree) == Souderton, assigned(Onawa) == Souderton]) ::: (C)
is_accurate_list([assigned(Nance) == Souderton, assigned(Onawa) == Souderton]) ::: (D)
is_accurate_list([assigned(Nance) == Souderton, assigned(Palermo) == Souderton]) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
Which one of the following is the lowest ranking that Medici could have?

# Options:
A) second highest
B) third highest
C) fourth highest
D) fifth highest
E) sixth highest","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazade, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazade) > rank(Pastilla), rank(Medici) > rank(Scheherazade)) ::: If Scheherazade ranks higher than Pastilla, Medici ranks higher than Scheherazade
Implies(rank(Medici) > rank(Scheherazade), rank(Scheherazade) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazade, Scheherazade ranks higher than Pastilla
ForAll([r1:restaurants, r2:restaurants], Implies(r1 != r2, rank(r1) != rank(r2))) ::: There are no ties
# Options
is_valid(rank(Medici) == 2) ::: (A)
is_valid(rank(Medici) == 3) ::: (B)
is_valid(rank(Medici) == 4) ::: (C)
is_valid(rank(Medici) == 5) ::: (D)
is_valid(rank(Medici) == 6) ::: (E)"
"# Context:
Each of seven television programs—H, J, L, P, Q, S, V—is assigned a different rank: from first through seventh (from most popular to least popular). The ranking is consistent with the following conditions: J and L are each less popular than H. J is more popular than Q. S and V are each less popular than L. P and S are each less popular than Q. S is not seventh.

# Question:
If J is more popular than L, and S is more popular than P, then which one of the following must be true of the ranking?

# Options:
A) J is second.
B) J is third.
C) L is third.
D) Q is third.
E) P is seventh.","# Declarations
programs = EnumSort([H, J, L, P, Q, S, V])
rank = Function([programs] -> [int])
# Constraints
ForAll([p1:programs, p2:programs], Implies(p1 != p2, rank(p1) != rank(p2))) ::: Each program is assigned a different rank
rank(J) < rank(H) ::: J is less popular than H
rank(L) < rank(H) ::: L is less popular than H
rank(J) > rank(Q) ::: J is more popular than Q
rank(S) < rank(L) ::: S is less popular than L
rank(V) < rank(L) ::: V is less popular than L
rank(P) < rank(Q) ::: P is less popular than Q
rank(S) < rank(Q) ::: S is less popular than Q
rank(S) != 7 ::: S is not seventh
rank(J) > rank(L) ::: J is more popular than L
rank(S) > rank(P) ::: S is more popular than P
# Options
is_valid(rank(J) == 2) ::: (A)
is_valid(rank(J) == 3) ::: (B)
is_valid(rank(L) == 3) ::: (C)
is_valid(rank(Q) == 3) ::: (D)
is_valid(rank(P) == 7) ::: (E)"
"# Context:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.

# Question:
If the Quigley arrives at some time before the Rockville, then the Wooster must arrive

# Options:
A) second
B) third
C) fourth
D) fifth
E) sixth","# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrival_order = Function([trains] -> [int])
# Constraints
ForAll([t1:trains, t2:trains], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: The trains arrive one at a time
Or(arrival_order(York) == 4, arrival_order(Wooster) == 4) ::: Either the York or the Wooster arrives fourth
Implies(arrival_order(Wooster) < arrival_order(York), And(arrival_order(Wooster) < arrival_order(Sunnydale), arrival_order(Sunnydale) < arrival_order(York))) ::: The Sunnydale arrives at some time after the Wooster but at some time before the York
ForAll([t:trains], Implies(t == Tilbury, arrival_order(t) > arrival_order(Rockville))) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
ForAll([t:trains], Implies(t == Victoria, arrival_order(t) > arrival_order(Rockville))) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
Not(arrival_order(Tilbury) == arrival_order(Victoria) + 1) ::: The Tilbury does not arrive next after the Victoria
Not(arrival_order(Victoria) == arrival_order(Tilbury) + 1) ::: The Victoria does not arrive next after the Tilbury
Implies(arrival_order(Quigley) < arrival_order(Rockville), True) ::: If the Quigley arrives at some time before the Rockville
# Options
is_valid(arrival_order(Wooster) == 2) ::: (A)
is_valid(arrival_order(Wooster) == 3) ::: (B)
is_valid(arrival_order(Wooster) == 4) ::: (C)
is_valid(arrival_order(Wooster) == 5) ::: (D)
is_valid(arrival_order(Wooster) == 6) ::: (E)"
"# Context:
A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.

# Question:
If Tuscarora South is assigned females, then it could be true that females are assigned to both

# Options:
A) Richards South and Wisteria North
B) Richards South and Wisteria South
C) Veblen North and Wisteria North
D) Veblen South and Wisteria South
E) Veblen South and Veblen North","# Declarations
dormitories = EnumSort([Richards, Tuscarora, Veblen, Wisteria])
wings = EnumSort([North, South])
gender = EnumSort([Male, Female])
assigned = Function([dormitories, wings] -> [gender])
# Constraints
ForAll([d:dormitories, w:wings], Or(assigned(d, w) == Male, assigned(d, w) == Female)) ::: Each wing is assigned only male students or only female students
Count([d:dormitories, w:wings], assigned(d, w) == Male) == 3 ::: Exactly three wings have males assigned to them
assigned(Richards, North) == Female ::: Richards North and Tuscarora North are assigned females
assigned(Tuscarora, North) == Female ::: Richards North and Tuscarora North are assigned females
ForAll([d:dormitories], Implies(assigned(d, North) == Male, assigned(d, South) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
ForAll([d:dormitories], Implies(assigned(d, South) == Male, assigned(d, North) == Female)) ::: If a dormitory has males assigned to one of its wings, then its other wing is assigned females
Implies(assigned(Veblen, South) == Male, assigned(Wisteria, North) == Male) ::: If males are assigned to Veblen South, then Wisteria North is assigned males
assigned(Tuscarora, South) == Female ::: If Tuscarora South is assigned females
# Options
is_valid(And(assigned(Richards, South) == Female, assigned(Wisteria, North) == Female)) ::: (A)
is_valid(And(assigned(Richards, South) == Female, assigned(Wisteria, South) == Female)) ::: (B)
is_valid(And(assigned(Veblen, North) == Female, assigned(Wisteria, North) == Female)) ::: (C)
is_valid(And(assigned(Veblen, South) == Female, assigned(Wisteria, South) == Female)) ::: (D)
is_valid(And(assigned(Veblen, South) == Female, assigned(Veblen, North) == Female)) ::: (E)"
"# Context:
From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.

# Question:
If Z is selected, which one of the following could be true?

# Options:
A) All three of the sapphires are selected.
B) Both J and M are selected.
C) Both K and M are selected.
D) None of the rubies is selected.
E) None of the sapphires is selected.","# Declarations
stones = EnumSort([F, G, H, J, K, M, W, X, Y, Z])
selected = Function([stones] -> [bool])
# Constraints
Count([s:stones], selected(s)) == 6 ::: a jeweler will select six stones
Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) >= 2 ::: At least two of the topazes are selected
Implies(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 2, Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1) ::: If exactly two of the sapphires are selected, exactly one of the rubies is selected
Implies(selected(W), And(Not(selected(H)), Not(selected(Z)))) ::: If W is selected, neither H nor Z is selected
Implies(selected(M), selected(W)) ::: If M is selected, W is also selected
selected(Z) ::: If Z is selected
# Options
is_valid(And(selected(J), selected(K), selected(M))) ::: (A)
is_valid(And(selected(J), selected(M))) ::: (B)
is_valid(And(selected(K), selected(M))) ::: (C)
is_valid(ForAll([s:stones], Implies(Or(s == F, s == G, s == H), Not(selected(s))))) ::: (D)
is_valid(ForAll([s:stones], Implies(Or(s == J, s == K, s == M), Not(selected(s))))) ::: (E)"
"# Context:
A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.

# Question:
Suppose that the condition requiring that X has more options than W is replaced by a new condition requiring that X and W have exactly two options in common. If all of the other original conditions remain in effect, which one of the following must be false?

# Options:
A) T and X have no options in common.
B) V and X have exactly one option in common.
C) V and X have exactly two options in common.
D) X and Z have no options in common.
E) X and Z have exactly two options in common.","# Declarations
cars = EnumSort([T, V, W, X, Y, Z])
options = EnumSort([power_windows, leather_interior, sunroof])
has_option = Function([cars, options] -> [bool])
# Constraints
has_option(V, power_windows) ::: V has power windows
has_option(V, sunroof) ::: V has a sunroof
has_option(W, power_windows) ::: W has power windows
has_option(W, leather_interior) ::: W has a leather interior
ForAll([o:options], Or(Not(has_option(W, o)), Not(has_option(Y, o)))) ::: W and Y have no options in common
Count([o:options], has_option(X, o)) == 2 ::: X and W have exactly two options in common
Count([o:options], And(has_option(V, o), has_option(Z, o))) == 1 ::: V and Z have exactly one option in common
Count([o:options], has_option(T, o)) < Count([o:options], has_option(Z, o)) ::: T has fewer options than Z
# Options
is_unsat(ForAll([o:options], Not(And(has_option(T, o), has_option(X, o))))) ::: (A)
is_unsat(Count([o:options], And(has_option(V, o), has_option(X, o))) == 1) ::: (B)
is_unsat(Count([o:options], And(has_option(V, o), has_option(X, o))) == 2) ::: (C)
is_unsat(ForAll([o:options], Not(And(has_option(X, o), has_option(Z, o))))) ::: (D)
is_unsat(Count([o:options], And(has_option(X, o), has_option(Z, o))) == 2) ::: (E)"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
If Jessup has exactly three attractions, then it is possible to determine the exact set of attractions featured by which of the parks?

# Options:
A) Island only
B) Jessup only
C) Island and Hilltop only
D) Island and Jessup only
E) Jessup, Island, and Hilltop","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks, attractions] -> [bool])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p, a))) ::: Each park has at least one attraction
ForAll([a:attractions], Exists([p:parks], has_attraction(p, a))) ::: At least one of each type of attraction is included
ForAll([p:parks, a:attractions], Implies(has_attraction(p, a), ForAll([p2:parks], Implies(p != p2, Not(has_attraction(p2, a)))))) ::: No two attractions of the same type are included in any park
Count([p:parks], Exists([a:attractions], has_attraction(p, garden))) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup, museum) ::: Jessup has a museum
Not(has_attraction(Jessup, theater)) ::: Jessup does not have a theater
Count([a:attractions], has_attraction(Island, a)) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(And(has_attraction(p, playground), has_attraction(p, fountain)), False)) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p, theater), has_attraction(p, garden))) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p, museum), has_attraction(p, playground))) ::: Each park that has a museum also has a playground
Count([a:attractions], has_attraction(Jessup, a)) == 3 ::: Jessup has exactly three attractions
# Options
is_valid(ForAll([p:parks], Implies(p == Island, Exists([a:attractions], has_attraction(p, a))))) ::: (A)
is_valid(ForAll([p:parks], Implies(p == Jessup, Exists([a:attractions], has_attraction(p, a))))) ::: (B)
is_valid(And(ForAll([p:parks], Implies(p == Island, Exists([a:attractions], has_attraction(p, a)))), ForAll([p:parks], Implies(p == Hilltop, Exists([a:attractions], has_attraction(p, a)))))) ::: (C)
is_valid(And(ForAll([p:parks], Implies(p == Island, Exists([a:attractions], has_attraction(p, a)))), ForAll([p:parks], Implies(p == Jessup, Exists([a:attractions], has_attraction(p, a)))))) ::: (D)
is_valid(And(ForAll([p:parks], Implies(p == Jessup, Exists([a:attractions], has_attraction(p, a)))), ForAll([p:parks], Implies(p == Island, Exists([a:attractions], has_attraction(p, a)))), ForAll([p:parks], Implies(p == Hilltop, Exists([a:attractions], has_attraction(p, a)))))) ::: (E)"
"# Context:
Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.

# Question:
If neither Gutierrez nor Imamura sits in row 1, then which one of the following could be true?

# Options:
A) Hoffman sits in row 2.
B) Kelly sits in row 2.
C) Moore sits in row 2.
D) Imamura occupies an aisle seat.
E) Moore occupies an aisle seat.","# Declarations
passengers = EnumSort([Gutierrez, Hoffman, Imamura, Kelly, Lapas, Moore])
rows = EnumSort([1, 2, 3])
seats = EnumSort([window, aisle])
occupies = Function([passengers] -> [rows])
seat_type = Function([passengers] -> [seats])
# Constraints
ForAll([p:passengers], Exists([p1:passengers], And(p1 != p, occupies(p1) == occupies(p)))) ::: Each passenger sits in a different seat
ForAll([p:passengers], Exists([p1:passengers], And(p1 != p, seat_type(p1) == seat_type(p)))) ::: Each passenger sits in a different seat
occupies(Hoffman) == occupies(Gutierrez) + 1 ::: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat
seat_type(Hoffman) == aisle ::: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat
Implies(seat_type(Moore) == aisle, occupies(Hoffman) == occupies(Lapas)) ::: If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas
Implies(occupies(Gutierrez) == occupies(Kelly), occupies(Moore) == occupies(Imamura) + 1) ::: If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat
Implies(seat_type(Kelly) == window, occupies(Moore) == 3) ::: If Kelly occupies a window seat, Moore sits in row 3
Implies(occupies(Kelly) == 3, occupies(Imamura) == 1) ::: If Kelly sits in row 3, Imamura sits in row 1
Not(occupies(Gutierrez) == 1) ::: Gutierrez does not sit in row 1
Not(occupies(Imamura) == 1) ::: Imamura does not sit in row 1
# Options
is_valid(occupies(Hoffman) == 2) ::: (A)
is_valid(occupies(Kelly) == 2) ::: (B)
is_valid(occupies(Moore) == 2) ::: (C)
is_valid(seat_type(Imamura) == aisle) ::: (D)
is_valid(seat_type(Moore) == aisle) ::: (E)"
"# Context:
From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.

# Question:
Which one of the following most be true?

# Options:
A) G is selected.
B) J is selected.
C) X is selected.
D) Of at least one of the three types of stones, exactly one stone is selected.
E) Of at least one of the three types of stones, exactly three stones are selected.","# Declarations
stones = EnumSort([F, G, H, J, K, M, W, X, Y, Z])
selected = Function([stones] -> [bool])
# Constraints
Count([s:stones], selected(s)) == 6 ::: a jeweler will select six stones
Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) >= 2 ::: At least two of the topazes are selected
Implies(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 2, Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1) ::: If exactly two of the sapphires are selected, exactly one of the rubies is selected
Implies(selected(W), And(Not(selected(H)), Not(selected(Z)))) ::: If W is selected, neither H nor Z is selected
Implies(selected(M), selected(W)) ::: If M is selected, W is also selected
# Options
is_valid(selected(G)) ::: (A)
is_valid(selected(J)) ::: (B)
is_valid(selected(X)) ::: (C)
is_valid(Or(Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1, Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 1, Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) == 1)) ::: (D)
is_valid(Or(Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 3, Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 3, Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) == 3)) ::: (E)"
"# Context:
Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.

# Question:
If O is prescribed for a given case, which one of the following is a pair of treatments both of which must also be prescribed for that case?

# Options:
A) F, M
B) G, V
C) N, U
D) U, V
E) U, W","# Declarations
treatments = EnumSort([F, G, H, M, N, O, U, V, W])
dietary_regimens = EnumSort([M, N, O])
prescribed = Function([treatments] -> [bool])
# Constraints
Count([t:treatments], prescribed(t)) == 5 ::: a doctor will prescribe exactly five of the treatments
Implies(And(prescribed(F), prescribed(G)), Not(prescribed(H))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Implies(And(prescribed(F), prescribed(H)), Not(prescribed(G))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Implies(And(prescribed(G), prescribed(H)), Not(prescribed(F))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Count([d:dietary_regimens], prescribed(d)) == 1 ::: There must be exactly one dietary regimen prescribed
Implies(Not(prescribed(O)), Not(prescribed(F))) ::: If O is not prescribed, F cannot be prescribed
Implies(prescribed(W), Not(prescribed(F))) ::: If W is prescribed, F cannot be prescribed
Implies(And(prescribed(N), prescribed(U)), Not(prescribed(G))) ::: G cannot be prescribed if both N and U are prescribed
Implies(prescribed(V), And(prescribed(H), prescribed(M))) ::: V cannot be prescribed unless both H and M are prescribed
prescribed(O) ::: O is prescribed for a given case
# Options
is_valid(And(prescribed(F), prescribed(M))) ::: (A)
is_valid(And(prescribed(G), prescribed(V))) ::: (B)
is_valid(And(prescribed(N), prescribed(U))) ::: (C)
is_valid(And(prescribed(U), prescribed(V))) ::: (D)
is_valid(And(prescribed(U), prescribed(W))) ::: (E)"
"# Context:
Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.

# Question:
Suppose that, rather than just one, Larisa stocks both end aisles; all other conditions remaining in effect, which one of the following CANNOT be true?

# Options:
A) Jill stocks aisle 3.
B) Olga stocks aisle 6.
C) Olga stocks the only aisle between the two aisles that Jill stocks.
D) Kurt stocks only even-numbered aisles.
E) One of Larisa's aisles is immediately next to Olga's.","# Declarations
clerks = EnumSort([Jill, Kurt, Larisa, Manny, Olga])
aisles = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
stocks = Function([clerks] -> [aisles])
# Constraints
ForAll([a:aisles], Exists([c:clerks], stocks(c) == a)) ::: Each aisle is stocked by exactly one clerk
ForAll([c:clerks], Count([a:aisles], stocks(c) == a) <= 2) ::: No clerk stocks more than two aisles
Count([a:aisles], stocks(Olga) == a) == 1 ::: Olga stocks exactly one aisle
stocks(Kurt) == 2 ::: Kurt stocks aisle 2
ForAll([a:aisles], Implies(stocks(Manny) == a, a != 1)) ::: Manny does not stock aisle 1
ForAll([a:aisles], Implies(stocks(Jill) == a, And(a != 1, a != 9, ForAll([a1:aisles], Implies(stocks(Jill) == a1, Abs(a - a1) != 1))))) ::: Jill does not stock consecutive aisles
Exists([a:aisles], And(stocks(Kurt) == a, Exists([a1:aisles], And(stocks(Manny) == a1, Abs(a - a1) == 1)))) ::: Kurt stocks the only aisle between the two aisles Manny stocks
Or(stocks(Larisa) == 1, stocks(Larisa) == 9) ::: Exactly one of Larisa's aisles is an end aisle
ForAll([a:aisles], Implies(stocks(Olga) == a, And(a > 2, Exists([a1:aisles], And(stocks(Larisa) == a1, a < a1))))) ::: Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's
Count([a:aisles], stocks(Larisa) == a) == 2 ::: Larisa stocks both end aisles
# Options
is_unsat(stocks(Jill) == 3) ::: (A)
is_unsat(stocks(Olga) == 6) ::: (B)
is_unsat(Exists([a:aisles], And(stocks(Jill) == a, Exists([a1:aisles], And(stocks(Jill) == a1, Abs(a - a1) == 1))))) ::: (C)
is_unsat(ForAll([a:aisles], Implies(stocks(Kurt) == a, a % 2 == 0))) ::: (D)
is_unsat(Exists([a:aisles], And(stocks(Larisa) == a, Abs(a - stocks(Olga)) == 1))) ::: (E)"
"# Context:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.

# Question:
If exactly one of the trains arrives after the Wooster but before the York, then which one of the following could be true?

# Options:
A) The sixth train to arrive is the Sunnydale.
B) The sixth train to arrive is the Tilbury.
C) The third train to arrive is the Rockville.
D) The second train to arrive is the Sunnydale.
E) The first train to arrive is the Rockville.","# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrival_order = Function([trains] -> [int])
# Constraints
ForAll([t1:trains, t2:trains], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: The trains arrive one at a time
Or(arrival_order(York) == 4, arrival_order(Wooster) == 4) ::: Either the York or the Wooster arrives fourth
arrival_order(Sunnydale) > arrival_order(Wooster) ::: The Sunnydale arrives at some time after the Wooster
arrival_order(Sunnydale) < arrival_order(York) ::: The Sunnydale arrives at some time before the York
arrival_order(Tilbury) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
arrival_order(Victoria) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
Not(arrival_order(Tilbury) == arrival_order(Victoria) + 1) ::: The Tilbury does not arrive next after the Victoria
Not(arrival_order(Victoria) == arrival_order(Tilbury) + 1) ::: The Victoria does not arrive next after the Tilbury
Count([t:trains], And(arrival_order(t) > arrival_order(Wooster), arrival_order(t) < arrival_order(York))) == 1 ::: Exactly one of the trains arrives after the Wooster but before the York
# Options
is_valid(arrival_order(Sunnydale) == 6) ::: (A)
is_valid(arrival_order(Tilbury) == 6) ::: (B)
is_valid(arrival_order(Rockville) == 3) ::: (C)
is_valid(arrival_order(Sunnydale) == 2) ::: (D)
is_valid(arrival_order(Rockville) == 1) ::: (E)"
"# Context:
A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.

# Question:
If exactly four of the six cars have leather interiors, and exactly four of the six cars have power windows, then each of the following must be true EXCEPT:

# Options:
A) T and V have no options in common.
B) T and Y have no options in common.
C) T and Z have exactly one option in common.
D) W and Z have exactly one option in common.
E) Y and Z have no options in common.","# Declarations
cars = EnumSort([T, V, W, X, Y, Z])
options = EnumSort([power_windows, leather_interior, sunroof])
has_option = Function([cars, options] -> [bool])
# Constraints
has_option(V, power_windows) ::: V has power windows
has_option(V, sunroof) ::: V has a sunroof
has_option(W, power_windows) ::: W has power windows
has_option(W, leather_interior) ::: W has a leather interior
ForAll([o:options], Not(And(has_option(W, o), has_option(Y, o)))) ::: W and Y have no options in common
Count([o:options], has_option(X, o)) > Count([o:options], has_option(W, o)) ::: X has more options than W
Count([o:options], And(has_option(V, o), has_option(Z, o))) == 1 ::: V and Z have exactly one option in common
Count([o:options], has_option(T, o)) < Count([o:options], has_option(Z, o)) ::: T has fewer options than Z
Count([c:cars], has_option(c, leather_interior)) == 4 ::: exactly four of the six cars have leather interiors
Count([c:cars], has_option(c, power_windows)) == 4 ::: exactly four of the six cars have power windows
# Options
is_unsat(ForAll([o:options], Not(And(has_option(T, o), has_option(V, o))))) ::: (A)
is_unsat(ForAll([o:options], Not(And(has_option(T, o), has_option(Y, o))))) ::: (B)
is_unsat(Count([o:options], And(has_option(T, o), has_option(Z, o))) == 1) ::: (C)
is_unsat(Count([o:options], And(has_option(W, o), has_option(Z, o))) == 1) ::: (D)
is_unsat(ForAll([o:options], Not(And(has_option(Y, o), has_option(Z, o))))) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
If Pastilla ranks second highest, then which one of the following is a complete and accurate list of restaurants any one of which could be ranked fourth highest?

# Options:
A) Lautrec
B) Lautrec, Vistula
C) Scheherazade's, Lautrec
D) Scheherazade's, Lautrec, Medici
E) Scheherazade's, Lautrec, Tantoko","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazades, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazades) > rank(Pastilla), rank(Medici) > rank(Scheherazades)) ::: If Scheherazades ranks higher than Pastilla, Medici ranks higher than Scheherazades
Implies(rank(Medici) > rank(Scheherazades), rank(Scheherazades) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazades, Scheherazades ranks higher than Pastilla
ForAll([r1:restaurants, r2:restaurants], Implies(r1 != r2, rank(r1) != rank(r2))) ::: There are no ties
rank(Pastilla) == 2 ::: Pastilla ranks second highest
# Options
is_accurate_list([rank(Lautrec) == 4]) ::: (A)
is_accurate_list([rank(Lautrec) == 4, rank(Vistula) == 4]) ::: (B)
is_accurate_list([rank(Scheherazades) == 4, rank(Lautrec) == 4]) ::: (C)
is_accurate_list([rank(Scheherazades) == 4, rank(Lautrec) == 4, rank(Medici) == 4]) ::: (D)
is_accurate_list([rank(Scheherazades) == 4, rank(Lautrec) == 4, rank(Tantoko) == 4]) ::: (E)"
"# Context:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.

# Question:
Which one of the following could be true?

# Options:
A) The Sunnydale is the next train to arrive after the Quigley.
B) The Rockville is the next train to arrive after the Sunnydale.
C) The Rockville is the next train to arrive after the Tilbury.
D) The Quigley is the next train to arrive after the Sunnydale.
E) The Quigley is the next train to arrive after the Wooster.","# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrival_order = Function([trains] -> [int])
# Constraints
ForAll([t1:trains, t2:trains], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: The trains arrive one at a time
Or(arrival_order(York) == 4, arrival_order(Wooster) == 4) ::: Either the York or the Wooster arrives fourth
arrival_order(Sunnydale) > arrival_order(Wooster) ::: The Sunnydale arrives at some time after the Wooster
arrival_order(Sunnydale) < arrival_order(York) ::: The Sunnydale arrives at some time before the York
arrival_order(Tilbury) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
arrival_order(Victoria) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
Not(arrival_order(Tilbury) == arrival_order(Victoria) + 1) ::: The Tilbury does not arrive next after the Victoria
Not(arrival_order(Victoria) == arrival_order(Tilbury) + 1) ::: The Victoria does not arrive next after the Tilbury
# Options
is_sat(arrival_order(Sunnydale) == arrival_order(Quigley) + 1) ::: (A)
is_sat(arrival_order(Rockville) == arrival_order(Sunnydale) + 1) ::: (B)
is_sat(arrival_order(Rockville) == arrival_order(Tilbury) + 1) ::: (C)
is_sat(arrival_order(Quigley) == arrival_order(Sunnydale) + 1) ::: (D)
is_sat(arrival_order(Quigley) == arrival_order(Wooster) + 1) ::: (E)"
"# Context:
Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.

# Question:
If Gianola votes for the tax bill, then which one of the following statements could be true?

# Options:
A) Fu and Gianola each vote for exactly one bill.
B) Gianola and Herstein each vote for exactly one bill.
C) Fu votes for exactly two bills.
D) Gianola votes for the recreation bill.
E) Herstein votes against the recreation bill.","# Declarations
council_members = EnumSort([Fu, Gianola, Herstein])
bills = EnumSort([recreation, school, tax])
votes = Function([council_members, bills] -> [bool])
# Constraints
ForAll([m:council_members], Or(Exists([b:bills], votes(m, b)), Exists([b:bills], Not(votes(m, b))))) ::: Each member of the council votes for at least one of the bills and against at least one of the bills
Count([m:council_members], votes(m, recreation)) == 2 ::: Exactly two members of the council vote for the recreation bill
Count([m:council_members], votes(m, school)) == 1 ::: Exactly one member of the council votes for the school bill
Count([m:council_members], votes(m, tax)) == 1 ::: Exactly one member of the council votes for the tax bill
votes(Fu, recreation) ::: Fu votes for the recreation bill
Not(votes(Fu, school)) ::: Fu votes against the school bill
Not(votes(Gianola, recreation)) ::: Gianola votes against the recreation bill
Not(votes(Herstein, tax)) ::: Herstein votes against the tax bill
votes(Gianola, tax) ::: Gianola votes for the tax bill
# Options
is_valid(And(Count([b:bills], votes(Fu, b)) == 1, Count([b:bills], votes(Gianola, b)) == 1)) ::: (A) Fu and Gianola each vote for exactly one bill
is_valid(And(Count([b:bills], votes(Gianola, b)) == 1, Count([b:bills], votes(Herstein, b)) == 1)) ::: (B) Gianola and Herstein each vote for exactly one bill
is_valid(Count([b:bills], votes(Fu, b)) == 2) ::: (C) Fu votes for exactly two bills
is_valid(votes(Gianola, recreation)) ::: (D) Gianola votes for the recreation bill
is_valid(Not(votes(Herstein, recreation))) ::: (E) Herstein votes against the recreation bill"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
Which one of the following could be true of the mannequins' outfits?

# Options:
A) Mannequin 1 wears the navy jacket and the yellow skirt.
B) Mannequin 2 wears the red hat and the red jacket.
C) Mannequin 1 wears exactly one red article of clothing.
D) Mannequin 1 wears exactly three yellow articles of clothing.
E) Mannequin 2 wears no red articles of clothing.","# Declarations
mannequins = EnumSort([1, 2])
colors = EnumSort([navy, red, yellow])
articles = EnumSort([hat, jacket, skirt, tie])
outfit = Function([mannequins, articles] -> [colors])
# Constraints
ForAll([m:mannequins], And(outfit(m, hat) != outfit(m, jacket), outfit(m, hat) != outfit(m, skirt), outfit(m, jacket) != outfit(m, skirt))) ::: Each mannequin wears a hat in a different color from the jacket it wears, and a different color from the skirt it wears
outfit(2, skirt) == navy ::: Mannequin 2 wears the navy skirt
outfit(1, tie) == red ::: Mannequin 1 wears the tie
ForAll([m:mannequins], Not(And(outfit(m, hat) != outfit(m, jacket), outfit(m, jacket) != outfit(m, skirt), outfit(m, skirt) != outfit(m, hat)))) ::: Neither mannequin wears all three colors
# Options
is_valid(And(outfit(1, jacket) == navy, outfit(1, skirt) == yellow)) ::: (A)
is_valid(And(outfit(2, hat) == red, outfit(2, jacket) == red)) ::: (B)
is_valid(Count([a:articles], outfit(1, a) == red) == 1) ::: (C)
is_valid(Count([a:articles], outfit(1, a) == yellow) == 3) ::: (D)
is_valid(ForAll([a:articles], outfit(2, a) != red)) ::: (E)"
"# Context:
From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.

# Question:
Which one of the following could be the selection of stones?

# Options:
A) F, G, H, M, X, Y
B) F, G, J, K, M, W
C) F, G, J, K, W, X
D) G, H, J, X, Y, Z
E) G, H, K, W, X, Z","# Declarations
stones = EnumSort([F, G, H, J, K, M, W, X, Y, Z])
selected = Function([stones] -> [bool])
# Constraints
Count([s:stones], selected(s)) == 6 ::: a jeweler will select six stones
Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) >= 2 ::: At least two of the topazes are selected
Implies(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 2, Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1) ::: If exactly two of the sapphires are selected, exactly one of the rubies is selected
Implies(selected(W), And(Not(selected(H)), Not(selected(Z)))) ::: If W is selected, neither H nor Z is selected
Implies(selected(M), selected(W)) ::: If M is selected, W is also selected
# Options
is_sat(And(selected(F), selected(G), selected(H), selected(M), selected(X), selected(Y))) ::: (A)
is_sat(And(selected(F), selected(G), selected(J), selected(K), selected(M), selected(W))) ::: (B)
is_sat(And(selected(F), selected(G), selected(J), selected(K), selected(W), selected(X))) ::: (C)
is_sat(And(selected(G), selected(H), selected(J), selected(X), selected(Y), selected(Z))) ::: (D)
is_sat(And(selected(G), selected(H), selected(K), selected(W), selected(X), selected(Z))) ::: (E)"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
If each of exactly two of the parks has a fountain, then which one of the following could be true?

# Options:
A) Island does not have a fountain.
B) Jessup does not have a garden.
C) Jessup has exactly two attractions.
D) Hilltop has exactly three attractions.
E) Hilltop has exactly four attractions.","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks, attractions] -> [bool])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p, a))) ::: Each park has at least one attraction
ForAll([a:attractions], Exists([p:parks], has_attraction(p, a))) ::: At least one of each type of attraction is included
ForAll([p:parks, a:attractions], Implies(has_attraction(p, a), ForAll([p2:parks], Implies(p != p2, Not(has_attraction(p2, a)))))) ::: No two attractions of the same type are included in any park
Count([p:parks], Exists([a:attractions], has_attraction(p, garden))) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup, museum) ::: Jessup has a museum
Not(has_attraction(Jessup, theater)) ::: Jessup does not have a theater
Count([a:attractions], has_attraction(Island, a)) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(And(has_attraction(p, playground), has_attraction(p, fountain)), False)) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p, theater), has_attraction(p, garden))) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p, museum), has_attraction(p, playground))) ::: Each park that has a museum also has a playground
Count([p:parks], Exists([a:attractions], has_attraction(p, fountain))) == 2 ::: Each of exactly two parks has a fountain
# Options
is_valid(Not(has_attraction(Island, fountain))) ::: (A)
is_valid(Not(has_attraction(Jessup, garden))) ::: (B)
is_valid(Count([a:attractions], has_attraction(Jessup, a)) == 2) ::: (C)
is_valid(Count([a:attractions], has_attraction(Hilltop, a)) == 3) ::: (D)
is_valid(Count([a:attractions], has_attraction(Hilltop, a)) == 4) ::: (E)"
"# Context:
A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.

# Question:
If the Japanese award is presented at some time before the Swahili award is presented, any of the following could be true EXCEPT:

# Options:
A) The German award is presented immediately before the French award is presented.
B) The German award is presented immediately before the Japanese award is presented.
C) The Hebrew award is presented immediately before the Latin award is presented.
D) The Korean award is presented immediately before the Japanese award is presented.
E) The Swahili award is presented immediately before the German award is presented.","# Declarations
awards = EnumSort([French, German, Hebrew, Japanese, Korean, Latin, Swahili])
position = Function([awards] -> [int])
# Constraints
position(German) != 1 ::: The German award is not presented first
position(Hebrew) < position(Korean) ::: The Hebrew award is presented at some time before the Korean award is presented
position(Latin) < position(Japanese) ::: The Latin award is presented at some time before the Japanese award is presented
Or(position(French) == position(Hebrew) - 1, position(French) == position(Hebrew) + 1) ::: The French award is presented either immediately before or immediately after the Hebrew award is presented
Or(position(Korean) == position(Latin) - 1, position(Korean) == position(Latin) + 1) ::: The Korean award is presented either immediately before or immediately after the Latin award is presented
position(Japanese) < position(Swahili) ::: The Japanese award is presented at some time before the Swahili award is presented
# Options
is_unsat(position(German) == position(French) - 1) ::: (A)
is_unsat(position(German) == position(Japanese) - 1) ::: (B)
is_unsat(position(Hebrew) == position(Latin) - 1) ::: (C)
is_unsat(position(Korean) == position(Japanese) - 1) ::: (D)
is_unsat(position(Swahili) == position(German) - 1) ::: (E)"
"# Context:
Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.

# Question:
If Jill stocks aisle 3, then which one of the following CANNOT be true?

# Options:
A) Jill stocks aisle 9.
B) Kurt stocks aisle 6.
C) Larisa stocks aisle 4.
D) Manny stocks aisle 4.
E) Olga stocks aisle 6.","# Declarations
clerks = EnumSort([Jill, Kurt, Larisa, Manny, Olga])
aisles = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
stocks = Function([clerks] -> [aisles])
# Constraints
Count([a:aisles], stocks(Olga) == a) == 1 ::: Olga stocks exactly one aisle
stocks(Kurt) == 2 ::: Kurt stocks aisle 2
ForAll([a:aisles], stocks(Manny) != 1) ::: Manny does not stock aisle 1
ForAll([a:aisles], Implies(stocks(Jill) == a, And(a != 1, a != 9, ForAll([b:aisles], Implies(b == a + 1, stocks(Jill) != b))))) ::: Jill does not stock consecutive aisles
Exists([a:aisles], And(a > 2, a < 9, stocks(Kurt) == a, ForAll([b:aisles], Implies(b == a - 1, stocks(Manny) == b)), ForAll([c:aisles], Implies(c == a + 1, stocks(Manny) == c)))) ::: Kurt stocks the only aisle between the two aisles Manny stocks
Exists([a:aisles], Or(a == 1, a == 9, stocks(Larisa) == a)) ::: Exactly one of Larisa's aisles is an end aisle
ForAll([a:aisles], Implies(stocks(Olga) == a, And(a > 2, Exists([b:aisles], And(stocks(Larisa) == b, a < b))))) ::: Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's
stocks(Jill) == 3 ::: If Jill stocks aisle 3
# Options
is_unsat(stocks(Jill) == 9) ::: (A)
is_unsat(stocks(Kurt) == 6) ::: (B)
is_unsat(stocks(Larisa) == 4) ::: (C)
is_unsat(stocks(Manny) == 4) ::: (D)
is_unsat(stocks(Olga) == 6) ::: (E)"
"# Context:
A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.

# Question:
The earliest that the Japanese award could be presented is

# Options:
A) third
B) fourth
C) fifth
D) sixth
E) seventh","# Declarations
awards = EnumSort([French, German, Hebrew, Japanese, Korean, Latin, Swahili])
position = Function([awards] -> [int])
# Constraints
position(German) != 1 ::: The German award is not presented first
position(Hebrew) < position(Korean) ::: The Hebrew award is presented at some time before the Korean award is presented
position(Latin) < position(Japanese) ::: The Latin award is presented at some time before the Japanese award is presented
Or(position(French) == position(Hebrew) - 1, position(French) == position(Hebrew) + 1) ::: The French award is presented either immediately before or immediately after the Hebrew award is presented
Or(position(Korean) == position(Latin) - 1, position(Korean) == position(Latin) + 1) ::: The Korean award is presented either immediately before or immediately after the Latin award is presented
ForAll([a:awards], And(position(a) >= 1, position(a) <= 7)) ::: Each award is presented exactly once and consecutively
# Options
is_valid(position(Japanese) == 3) ::: (A)
is_valid(position(Japanese) == 4) ::: (B)
is_valid(position(Japanese) == 5) ::: (C)
is_valid(position(Japanese) == 6) ::: (D)
is_valid(position(Japanese) == 7) ::: (E)"
"# Context:
At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.

# Question:
Which one of the following could be a list of the four teams participating in the boat race?

# Options:
A) J and L; K and S; M and Q; P and R
B) J and M; K and P; L and Q; R and S
C) J and M; K and R; L and S; P and Q
D) J and M; K and S; L and Q; P and R
E) J and P; K and L; M and R; Q and S","# Declarations
lifeguards = EnumSort([J, K, L, M, P, Q, R, S])
boat_race = Function([lifeguards, lifeguards] -> [bool])
rescue_exercise = Function([lifeguards, lifeguards] -> [bool])
# Constraints
ForAll([a:lifeguards, b:lifeguards], Implies(boat_race(a, b), Not(rescue_exercise(a, b)))) ::: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise
boat_race(L, Q) ::: L and Q are teammates in the boat race
rescue_exercise(K, L) ::: K and L are teammates in the rescue exercise
ForAll([a:lifeguards], And(Not(boat_race(R, S)), Not(rescue_exercise(R, S)))) ::: R and S are not teammates in either event
# Options
is_accurate_list([boat_race(J, L), boat_race(K, S), boat_race(M, Q), boat_race(P, R)]) ::: (A)
is_accurate_list([boat_race(J, M), boat_race(K, P), boat_race(L, Q), boat_race(R, S)]) ::: (B)
is_accurate_list([boat_race(J, M), boat_race(K, R), boat_race(L, S), boat_race(P, Q)]) ::: (C)
is_accurate_list([boat_race(J, M), boat_race(K, S), boat_race(L, Q), boat_race(P, R)]) ::: (D)
is_accurate_list([boat_race(J, P), boat_race(K, L), boat_race(M, R), boat_race(Q, S)]) ::: (E)"
"# Context:
Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.

# Question:
Which one of the following must be true?

# Options:
A) The first train to arrive is the Rockville.
B) The Quigley arrives at some time before the Sunnydale.
C) The Rockville arrives at some time before the Wooster.
D) The Victoria arrives at some time before the York.
E) The Wooster arrives at some time before the York.","# Declarations
trains = EnumSort([Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, York])
arrival_order = Function([trains] -> [int])
# Constraints
ForAll([t1:trains, t2:trains], Implies(t1 != t2, arrival_order(t1) != arrival_order(t2))) ::: The trains arrive one at a time
Or(arrival_order(York) == 4, arrival_order(Wooster) == 4) ::: Either the York or the Wooster arrives fourth
arrival_order(Sunnydale) > arrival_order(Wooster) ::: The Sunnydale arrives at some time after the Wooster
arrival_order(Sunnydale) < arrival_order(York) ::: The Sunnydale arrives at some time before the York
arrival_order(Tilbury) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
arrival_order(Victoria) > arrival_order(Rockville) ::: Both the Tilbury and the Victoria arrive at some time after the Rockville
Not(arrival_order(Tilbury) == arrival_order(Victoria) + 1) ::: The Tilbury does not arrive next after the Victoria
Not(arrival_order(Victoria) == arrival_order(Tilbury) + 1) ::: The Victoria does not arrive next after the Tilbury
# Options
is_valid(arrival_order(Rockville) == 1) ::: (A)
is_valid(arrival_order(Quigley) < arrival_order(Sunnydale)) ::: (B)
is_valid(arrival_order(Rockville) < arrival_order(Wooster)) ::: (C)
is_valid(arrival_order(Victoria) < arrival_order(York)) ::: (D)
is_valid(arrival_order(Wooster) < arrival_order(York)) ::: (E)"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
Suppose the condition is added that if shrikes are in the forest, then harriers are not. If all other conditions remain in effect, then which one of the following could be true?

# Options:
A) The forest contains both jays and shrikes.
B) The forest contains both wrens and shrikes.
C) The forest contains both martins and shrikes.
D) Jays are not in the forest, whereas martins are.
E) Only two of the six kinds of birds are not in the forest.","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
Implies(in_forest(shrike), Not(in_forest(harrier))) ::: If shrikes are in the forest, then harriers are not
# Options
is_sat(And(in_forest(jay), in_forest(shrike))) ::: (A)
is_sat(And(in_forest(wren), in_forest(shrike))) ::: (B)
is_sat(And(in_forest(martin), in_forest(shrike))) ::: (C)
is_sat(And(Not(in_forest(jay)), in_forest(martin))) ::: (D)
is_sat(Count([b:birds], Not(in_forest(b))) == 2) ::: (E)"
"# Context:
There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.

# Question:
Which one of the following could be an accurate list of the colors of the lights that decorate stores 2, 4, 6, 8, and 10, respectively?

# Options:
A) green, red, green, red, green
B) green, red, green, yellow, red
C) green, red, yellow, red, green
D) yellow, green, red, green, red
E) yellow, red, green, red, yellow","# Declarations
stores = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
colors = EnumSort([green, red, yellow])
decorated = Function([stores] -> [colors])
# Constraints
ForAll([s:stores], Exists([c:colors], decorated(s) == c)) ::: Each store is decorated with lights in exactly one color
ForAll([s:stores], Implies(s % 2 == 1, decorated(s) != decorated(s + 1))) ::: No store is decorated with lights of the same color as those of any store adjacent to it
ForAll([s:stores], Implies(s % 2 == 1, decorated(s) != decorated(s + 1))) ::: No store is decorated with lights of the same color as those of the store directly across the street from it
Count([s:stores], And(s % 2 == 1, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the north side of the street
Count([s:stores], And(s % 2 == 0, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the south side of the street
decorated(4) == red ::: Red lights decorate store 4
decorated(5) == yellow ::: Yellow lights decorate store 5
# Options
is_accurate_list([decorated(2) == green, decorated(4) == red, decorated(6) == green, decorated(8) == red, decorated(10) == green]) ::: (A)
is_accurate_list([decorated(2) == green, decorated(4) == red, decorated(6) == green, decorated(8) == yellow, decorated(10) == red]) ::: (B)
is_accurate_list([decorated(2) == green, decorated(4) == red, decorated(6) == yellow, decorated(8) == red, decorated(10) == green]) ::: (C)
is_accurate_list([decorated(2) == yellow, decorated(4) == green, decorated(6) == red, decorated(8) == green, decorated(10) == red]) ::: (D)
is_accurate_list([decorated(2) == yellow, decorated(4) == red, decorated(6) == green, decorated(8) == red, decorated(10) == yellow]) ::: (E)"
"# Context:
There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.

# Question:
If green lights decorate store 7, then each of the following statements could be false EXCEPT:

# Options:
A) Green lights decorate store 2.
B) Green lights decorate store 10.
C) Red lights decorate store 8.
D) Red lights decorate store 9.
E) Yellow lights decorate store 2.","# Declarations
stores = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
colors = EnumSort([green, red, yellow])
decorated = Function([stores] -> [colors])
# Constraints
ForAll([s:stores], Exists([c:colors], decorated(s) == c)) ::: Each store is decorated with lights in exactly one color
ForAll([s:stores], Implies(s % 2 == 1, decorated(s) != decorated(s + 1))) ::: No store is decorated with lights of the same color as those of any store adjacent to it
ForAll([s:stores], Implies(s % 2 == 1, decorated(s) != decorated(s + 1))) ::: No store is decorated with lights of the same color as those of the store directly across the street from it
Count([s:stores], And(s % 2 == 1, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the north side of the street
Count([s:stores], And(s % 2 == 0, decorated(s) == yellow)) == 1 ::: Yellow lights decorate exactly one store on the south side of the street
decorated(4) == red ::: Red lights decorate store 4
decorated(5) == yellow ::: Yellow lights decorate store 5
decorated(7) == green ::: Green lights decorate store 7
# Options
is_valid(decorated(2) == green) ::: (A)
is_valid(decorated(10) == green) ::: (B)
is_valid(decorated(8) == red) ::: (C)
is_valid(decorated(9) == red) ::: (D)
is_valid(decorated(2) == yellow) ::: (E)"
"# Context:
Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.

# Question:
Which one of the following could be the antibiotics and physical therapies prescribed for a given case?

# Options:
A) F, G, H, W
B) F, G, U, V
C) F, U, V, W
D) G, U, V, W
E) H, U, V, W","# Declarations
treatments = EnumSort([F, G, H, M, N, O, U, V, W])
antibiotics = EnumSort([F, G, H])
dietary_regimens = EnumSort([M, N, O])
physical_therapies = EnumSort([U, V, W])
prescribed = Function([treatments] -> [bool])
# Constraints
Count([t:treatments], prescribed(t)) == 5 ::: a doctor will prescribe exactly five of the treatments
Count([d:dietary_regimens], prescribed(d)) == 1 ::: There must be exactly one dietary regimen prescribed
Implies(And(prescribed(F), prescribed(G)), Not(prescribed(H))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Implies(Not(prescribed(O)), Not(prescribed(F))) ::: If O is not prescribed, F cannot be prescribed
Implies(prescribed(W), Not(prescribed(F))) ::: If W is prescribed, F cannot be prescribed
Implies(And(prescribed(N), prescribed(U)), Not(prescribed(G))) ::: G cannot be prescribed if both N and U are prescribed
Implies(prescribed(V), And(prescribed(H), prescribed(M))) ::: V cannot be prescribed unless both H and M are prescribed
# Options
is_sat(And(prescribed(F), prescribed(G), prescribed(H), prescribed(W))) ::: (A)
is_sat(And(prescribed(F), prescribed(G), prescribed(U), prescribed(V))) ::: (B)
is_sat(And(prescribed(F), prescribed(U), prescribed(V), prescribed(W))) ::: (C)
is_sat(And(prescribed(G), prescribed(U), prescribed(V), prescribed(W))) ::: (D)
is_sat(And(prescribed(H), prescribed(U), prescribed(V), prescribed(W))) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
If M is assembled on line 1, which one of the following could be true?

# Options:
A) F is assembled on a line numbered one lower than the line on which H is assembled.
B) F is assembled on a line numbered one lower than the line on which K is assembled.
C) G is assembled on a line numbered one lower than the line on which J is assembled.
D) G is assembled on a line numbered one lower than the line on which K is assembled.
E) K is assembled on a line numbered one lower than the line on which G is assembled.","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assembled = Function([models] -> [lines])
# Constraints
assembled(F) < assembled(J) ::: F is assembled on a lower-numbered line than J
assembled(M) == assembled(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assembled(H) == 1, assembled(H) == 7) ::: H is assembled on line 1 or else line 7
assembled(S) == 4 ::: S is assembled on line 4
assembled(M) == 1 ::: If M is assembled on line 1
# Options
is_valid(assembled(F) == assembled(H) - 1) ::: (A)
is_valid(assembled(F) == assembled(K) - 1) ::: (B)
is_valid(assembled(G) == assembled(J) - 1) ::: (C)
is_valid(assembled(G) == assembled(K) - 1) ::: (D)
is_valid(assembled(K) == assembled(G) - 1) ::: (E)"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
Which one of the following could be complete outfits for the two mannequins?

# Options:
A) mannequin 1: navy hat, red jacket, yellow skirt, red tie mannequin 2: red hat, navy jacket, navy skirt
B) mannequin 1: red hat, red jacket, yellow skirt, red tie mannequin 2: yellow hat, navy jacket, navy skirt
C) mannequin 1: red hat, yellow jacket, red skirt, red tie mannequin 2: yellow hat, navy jacket, yellow skirt
D) mannequin 1: yellow hat, red jacket, yellow skirt, red tie mannequin 2: red hat, navy jacket, navy skirt
E) mannequin 1: yellow hat, yellow jacket, red skirt mannequin 2: red hat, navy jacket, navy skirt","# Declarations
mannequins = EnumSort([mannequin1, mannequin2])
colors = EnumSort([navy, red, yellow])
hats = Function([mannequins] -> [colors])
jackets = Function([mannequins] -> [colors])
skirts = Function([mannequins] -> [colors])
tie = Function([mannequins] -> [bool])
# Constraints
ForAll([m:mannequins], hats(m) != jackets(m)) ::: Each mannequin wears a hat in a different color from the jacket it wears
skirts(mannequin2) == navy ::: Mannequin 2 wears the navy skirt
tie(mannequin1) == True ::: Mannequin 1 wears the tie
ForAll([m:mannequins], Not(And(hats(m) == navy, jackets(m) == red, skirts(m) == yellow))) ::: Neither mannequin wears all three colors
# Options
is_sat(And(hats(mannequin1) == navy, jackets(mannequin1) == red, skirts(mannequin1) == yellow, tie(mannequin1) == True, hats(mannequin2) == red, jackets(mannequin2) == navy, skirts(mannequin2) == navy)) ::: (A)
is_sat(And(hats(mannequin1) == red, jackets(mannequin1) == red, skirts(mannequin1) == yellow, tie(mannequin1) == True, hats(mannequin2) == yellow, jackets(mannequin2) == navy, skirts(mannequin2) == navy)) ::: (B)
is_sat(And(hats(mannequin1) == red, jackets(mannequin1) == yellow, skirts(mannequin1) == red, tie(mannequin1) == True, hats(mannequin2) == yellow, jackets(mannequin2) == navy, skirts(mannequin2) == yellow)) ::: (C)
is_sat(And(hats(mannequin1) == yellow, jackets(mannequin1) == red, skirts(mannequin1) == yellow, tie(mannequin1) == True, hats(mannequin2) == red, jackets(mannequin2) == navy, skirts(mannequin2) == navy)) ::: (D)
is_sat(And(hats(mannequin1) == yellow, jackets(mannequin1) == yellow, skirts(mannequin1) == red, tie(mannequin1) == True, hats(mannequin2) == red, jackets(mannequin2) == navy, skirts(mannequin2) == navy)) ::: (E)"
"# Context:
A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.

# Question:
Which one of the following must be true?

# Options:
A) At least one female reptile is alone in a habitat.
B) At least one male reptile is alone in a habitat.
C) At least one lizard is alone in a habitat.
D) At least one lizard is male.
E) At least one snake is male.","# Declarations
habitats = EnumSort([1, 2, 3, 4, 5])
reptiles = EnumSort([S1, S2, S3, S4, L1, L2, L3])
genders = EnumSort([male, female])
types = EnumSort([snake, lizard])
housed = Function([reptiles] -> [habitats])
reptile_gender = Function([reptiles] -> [genders])
reptile_type = Function([reptiles] -> [types])
# Constraints
ForAll([h:habitats], Count([r:reptiles], housed(r) == h) <= 2) ::: No habitat houses more than two reptiles
ForAll([h:habitats], ForAll([r1:reptiles, r2:reptiles], Implies(And(reptile_type(r1) == snake, reptile_type(r2) == lizard, housed(r1) == h, housed(r2) == h), r1 == r2))) ::: No habitat houses both a snake and a lizard
ForAll([r:reptiles], Implies(And(reptile_type(r) == snake, reptile_gender(r) == female), And(ForAll([r1:reptiles], Implies(And(reptile_type(r1) == lizard, reptile_gender(r1) == male, housed(r1) == housed(r) - 1), r1 == r)), ForAll([r2:reptiles], Implies(And(reptile_type(r2) == lizard, reptile_gender(r2) == male, housed(r2) == housed(r) + 1), r2 == r))))) ::: No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard
Count([r:reptiles], reptile_gender(r) == female) == 5 ::: Five of the reptiles are female
Count([r:reptiles], reptile_gender(r) == male) == 2 ::: Two of the reptiles are male
Count([r:reptiles], reptile_type(r) == snake) == 4 ::: Four snakes
Count([r:reptiles], reptile_type(r) == lizard) == 3 ::: Three lizards
# Options
is_valid(Exists([r:reptiles], And(reptile_gender(r) == female, Count([r1:reptiles], housed(r1) == housed(r)) == 1))) ::: (A) At least one female reptile is alone in a habitat
is_valid(Exists([r:reptiles], And(reptile_gender(r) == male, Count([r1:reptiles], housed(r1) == housed(r)) == 1))) ::: (B) At least one male reptile is alone in a habitat
is_valid(Exists([r:reptiles], And(reptile_type(r) == lizard, Count([r1:reptiles], housed(r1) == housed(r)) == 1))) ::: (C) At least one lizard is alone in a habitat
is_valid(Exists([r:reptiles], And(reptile_type(r) == lizard, reptile_gender(r) == male))) ::: (D) At least one lizard is male
is_valid(Exists([r:reptiles], And(reptile_type(r) == snake, reptile_gender(r) == male))) ::: (E) At least one snake is male"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
Which one of the following CANNOT be true?

# Options:
A) Neither Island nor Hilltop has a museum.
B) Neither Island nor Hilltop has a playground.
C) Neither Jessup nor Hilltop has a fountain.
D) Neither Jessup nor Island has a garden.
E) Neither Jessup nor Island has a theater.","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks, attractions] -> [bool])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p, a))) ::: Each park has at least one attraction
ForAll([a:attractions], Exists([p:parks], has_attraction(p, a))) ::: At least one of each type of attraction is included
ForAll([p:parks, a:attractions], Implies(has_attraction(p, a), ForAll([p2:parks], Implies(p2 != p, Not(has_attraction(p2, a)))))) ::: No two attractions of the same type are included in any park
Count([p:parks], Exists([a:attractions], And(a == garden, has_attraction(p, a)))) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup, museum) ::: Jessup has a museum
Not(has_attraction(Jessup, theater)) ::: Jessup does not have a theater
Count([a:attractions], has_attraction(Island, a)) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(And(has_attraction(p, playground), has_attraction(p, fountain)), False)) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p, theater), has_attraction(p, garden))) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p, museum), has_attraction(p, playground))) ::: Each park that has a museum also has a playground
# Options
is_unsat(And(Not(Exists([p:parks], And(p == Island, has_attraction(p, museum)))), Not(Exists([p:parks], And(p == Hilltop, has_attraction(p, museum)))))) ::: (A)
is_unsat(And(Not(Exists([p:parks], And(p == Island, has_attraction(p, playground)))), Not(Exists([p:parks], And(p == Hilltop, has_attraction(p, playground)))))) ::: (B)
is_unsat(And(Not(Exists([p:parks], And(p == Jessup, has_attraction(p, fountain)))), Not(Exists([p:parks], And(p == Hilltop, has_attraction(p, fountain)))))) ::: (C)
is_unsat(And(Not(Exists([p:parks], And(p == Jessup, has_attraction(p, garden)))), Not(Exists([p:parks], And(p == Island, has_attraction(p, garden)))))) ::: (D)
is_unsat(And(Not(Exists([p:parks], And(p == Jessup, has_attraction(p, theater)))), Not(Exists([p:parks], And(p == Island, has_attraction(p, theater)))))) ::: (E)"
"# Context:
Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.

# Question:
If the set of members of the council who vote against the school bill is the same set of members who vote against the tax bill, then which one of the following statements must be true?

# Options:
A) Fu votes for the tax bill.
B) Gianola votes for the recreation bill.
C) Gianola votes against the school bill.
D) Herstein votes against the recreation bill.
E) Herstein votes against the school bill.","# Declarations
members = EnumSort([Fu, Gianola, Herstein])
bills = EnumSort([recreation, school, tax])
votes = Function([members, bills] -> [bool])
# Constraints
ForAll([m:members], Or(Exists([b:bills], votes(m, b)), Exists([b:bills], Not(votes(m, b))))) ::: Each member of the council votes for at least one of the bills and against at least one of the bills
Count([m:members], votes(m, recreation)) == 2 ::: Exactly two members of the council vote for the recreation bill
Count([m:members], votes(m, school)) == 1 ::: Exactly one member of the council votes for the school bill
Count([m:members], votes(m, tax)) == 1 ::: Exactly one member of the council votes for the tax bill
votes(Fu, recreation) ::: Fu votes for the recreation bill
Not(votes(Fu, school)) ::: Fu votes against the school bill
Not(votes(Gianola, recreation)) ::: Gianola votes against the recreation bill
Not(votes(Herstein, tax)) ::: Herstein votes against the tax bill
ForAll([m:members], Implies(Not(votes(m, school)), Not(votes(m, tax)))) ::: If the set of members of the council who vote against the school bill is the same set of members who vote against the tax bill
# Options
is_valid(votes(Fu, tax)) ::: (A)
is_valid(votes(Gianola, recreation)) ::: (B)
is_valid(Not(votes(Gianola, school))) ::: (C)
is_valid(Not(votes(Herstein, recreation))) ::: (D)
is_valid(Not(votes(Herstein, school))) ::: (E)"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
If grosbeaks are in the forest, then which one of the following must be true?

# Options:
A) Shrikes are in the forest.
B) Wrens are in the forest.
C) The forest contains both wrens and shrikes.
D) At most two kinds of birds are in the forest.
E) At least three kinds of birds are in the forest.","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
in_forest(grosbeak) ::: If grosbeaks are in the forest
# Options
is_valid(in_forest(shrike)) ::: (A)
is_valid(in_forest(wren)) ::: (B)
is_valid(And(in_forest(wren), in_forest(shrike))) ::: (C)
is_valid(Count([b:birds], in_forest(b)) <= 2) ::: (D)
is_valid(Count([b:birds], in_forest(b)) >= 3) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
Which one of the following could be an accurate ranking of the restaurants, from highest to lowest?

# Options:
A) Tantoko, Medici, Scheherazade's, Pastilla, Vistula, Robusto, Lautrec
B) Robusto, Pastilla, Tantoko, Medici, Scheherazade's, Vistula, Lautrec
C) Tantoko, Medici, Scheherazade's, Robusto, Vistula, Pastilla, Lautrec
D) Tantoko, Robusto, Medici, Vistula, Pastilla, Scheherazade's, Lautrec
E) Robusto, Pastilla, Scheherazade's, Medici, Vistula, Tantoko, Lautrec","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazades, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazades) > rank(Pastilla), rank(Medici) > rank(Scheherazades)) ::: If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's
Implies(rank(Medici) > rank(Scheherazades), rank(Scheherazades) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla
ForAll([r1:restaurants, r2:restaurants], Implies(r1 != r2, rank(r1) != rank(r2))) ::: There are no ties
# Options
is_accurate_list([rank(Tantoko) < rank(Medici), rank(Medici) < rank(Scheherazades), rank(Scheherazades) < rank(Pastilla), rank(Pastilla) < rank(Vistula), rank(Vistula) < rank(Robusto), rank(Robusto) < rank(Lautrec)]) ::: (A)
is_accurate_list([rank(Robusto) < rank(Pastilla), rank(Pastilla) < rank(Tantoko), rank(Tantoko) < rank(Medici), rank(Medici) < rank(Scheherazades), rank(Scheherazades) < rank(Vistula), rank(Vistula) < rank(Lautrec)]) ::: (B)
is_accurate_list([rank(Tantoko) < rank(Medici), rank(Medici) < rank(Scheherazades), rank(Scheherazades) < rank(Robusto), rank(Robusto) < rank(Vistula), rank(Vistula) < rank(Pastilla), rank(Pastilla) < rank(Lautrec)]) ::: (C)
is_accurate_list([rank(Tantoko) < rank(Robusto), rank(Robusto) < rank(Medici), rank(Medici) < rank(Vistula), rank(Vistula) < rank(Pastilla), rank(Pastilla) < rank(Scheherazades), rank(Scheherazades) < rank(Lautrec)]) ::: (D)
is_accurate_list([rank(Robusto) < rank(Pastilla), rank(Pastilla) < rank(Scheherazades), rank(Scheherazades) < rank(Medici), rank(Medici) < rank(Vistula), rank(Vistula) < rank(Tantoko), rank(Tantoko) < rank(Lautrec)]) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
If G is assembled on the line numbered one less than the line on which F is assembled, then which one of the following must be true?

# Options:
A) F is assembled on line 3.
B) G is assembled on line 5.
C) H is assembled on line 1.
D) K is assembled on line 5.
E) M is assembled on line 6.","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assembled = Function([models] -> [lines])
# Constraints
assembled(F) < assembled(J) ::: F is assembled on a lower-numbered line than J
assembled(M) == assembled(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assembled(H) == 1, assembled(H) == 7) ::: H is assembled on line 1 or else line 7
assembled(S) == 4 ::: S is assembled on line 4
assembled(G) == assembled(F) - 1 ::: G is assembled on the line numbered one less than the line on which F is assembled
# Options
is_valid(assembled(F) == 3) ::: (A)
is_valid(assembled(G) == 5) ::: (B)
is_valid(assembled(H) == 1) ::: (C)
is_valid(assembled(K) == 5) ::: (D)
is_valid(assembled(M) == 6) ::: (E)"
"# Context:
On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.

# Question:
Which one of the following statements must be true?

# Options:
A) If bill 2 is paid on Thursday, bill 3 is paid on Wednesday.
B) If bill 4 is paid on Thursday, bill 1 is paid on Wednesday.
C) If bill 4 is paid on Thursday, bill 3 is paid on Wednesday.
D) If bill 6 is paid on Thursday, bill 3 is also paid on Thursday.
E) If bill 6 is paid on Thursday, bill 4 is also paid on Thursday.","# Declarations
bills = EnumSort([1, 2, 3, 4, 5, 6, 7])
days = EnumSort([Wednesday, Thursday])
paid_on = Function([bills] -> [days])
# Constraints
Or(Count([b:bills], paid_on(b) == Wednesday) == 3, Count([b:bills], paid_on(b) == Wednesday) == 4) ::: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday
paid_on(1) != paid_on(5) ::: Bill 1 cannot be paid on the same day as bill 5
paid_on(2) == Thursday ::: Bill 2 must be paid on Thursday
paid_on(4) == paid_on(7) ::: Bill 4 must be paid on the same day as bill 7
Implies(paid_on(6) == Wednesday, paid_on(7) == Thursday) ::: If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday
# Options
is_valid(Implies(paid_on(2) == Thursday, paid_on(3) == Wednesday)) ::: (A)
is_valid(Implies(paid_on(4) == Thursday, paid_on(1) == Wednesday)) ::: (B)
is_valid(Implies(paid_on(4) == Thursday, paid_on(3) == Wednesday)) ::: (C)
is_valid(Implies(paid_on(6) == Thursday, paid_on(3) == Thursday)) ::: (D)
is_valid(Implies(paid_on(6) == Thursday, paid_on(4) == Thursday)) ::: (E)"
"# Context:
Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.

# Question:
Which one of the following statements could be true?

# Options:
A) Fu and Gianola vote the same way on the tax bill.
B) Gianola and Herstein vote the same way on the recreation bill.
C) Gianola and Herstein vote the same way on the school bill.
D) Fu votes for one of the bills and Gianola votes for two of the bills.
E) Fu votes for two of the bills and Gianola votes for two of the bills.","# Declarations
council_members = EnumSort([Fu, Gianola, Herstein])
bills = EnumSort([recreation_bill, school_bill, tax_bill])
votes = Function([council_members, bills] -> [bool])
# Constraints
ForAll([m:council_members], Or(Exists([b:bills], votes(m, b)), Exists([b:bills], Not(votes(m, b))))) ::: Each member of the council votes for at least one of the bills and against at least one of the bills
Count([m:council_members], votes(m, recreation_bill)) == 2 ::: Exactly two members of the council vote for the recreation bill
Count([m:council_members], votes(m, school_bill)) == 1 ::: Exactly one member of the council votes for the school bill
Count([m:council_members], votes(m, tax_bill)) == 1 ::: Exactly one member of the council votes for the tax bill
votes(Fu, recreation_bill) ::: Fu votes for the recreation bill
Not(votes(Fu, school_bill)) ::: Fu votes against the school bill
Not(votes(Gianola, recreation_bill)) ::: Gianola votes against the recreation bill
Not(votes(Herstein, tax_bill)) ::: Herstein votes against the tax bill
# Options
is_valid(And(votes(Fu, tax_bill) == votes(Gianola, tax_bill))) ::: (A)
is_valid(And(votes(Gianola, recreation_bill) == votes(Herstein, recreation_bill))) ::: (B)
is_valid(And(votes(Gianola, school_bill) == votes(Herstein, school_bill))) ::: (C)
is_valid(And(Count([b:bills], votes(Fu, b)) == 1, Count([b:bills], votes(Gianola, b)) == 2)) ::: (D)
is_valid(And(Count([b:bills], votes(Fu, b)) == 2, Count([b:bills], votes(Gianola, b)) == 2)) ::: (E)"
"# Context:
Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.

# Question:
Which one of the following could be the five treatments prescribed for a given case?

# Options:
A) F, G, H, M, V
B) F, G, M, O, V
C) F, H, M, O, W
D) G, H, N, U, W
E) G, H, O, U, W","# Declarations
treatments = EnumSort([F, G, H, M, N, O, U, V, W])
dietary_regimens = EnumSort([M, N, O])
prescribed = Function([treatments] -> [bool])
# Constraints
Count([t:treatments], prescribed(t)) == 5 ::: a doctor will prescribe exactly five of the treatments
Implies(And(prescribed(F), prescribed(G)), Not(prescribed(H))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Implies(And(prescribed(F), prescribed(H)), Not(prescribed(G))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Implies(And(prescribed(G), prescribed(H)), Not(prescribed(F))) ::: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed
Count([d:dietary_regimens], prescribed(d)) == 1 ::: There must be exactly one dietary regimen prescribed
Implies(Not(prescribed(O)), Not(prescribed(F))) ::: If O is not prescribed, F cannot be prescribed
Implies(prescribed(W), Not(prescribed(F))) ::: If W is prescribed, F cannot be prescribed
Implies(And(prescribed(N), prescribed(U)), Not(prescribed(G))) ::: G cannot be prescribed if both N and U are prescribed
Implies(prescribed(V), And(prescribed(H), prescribed(M))) ::: V cannot be prescribed unless both H and M are prescribed
# Options
is_sat(And(prescribed(F), prescribed(G), prescribed(H), prescribed(M), prescribed(V))) ::: (A)
is_sat(And(prescribed(F), prescribed(G), prescribed(M), prescribed(O), prescribed(V))) ::: (B)
is_sat(And(prescribed(F), prescribed(H), prescribed(M), prescribed(O), prescribed(W))) ::: (C)
is_sat(And(prescribed(G), prescribed(H), prescribed(N), prescribed(U), prescribed(W))) ::: (D)
is_sat(And(prescribed(G), prescribed(H), prescribed(O), prescribed(U), prescribed(W))) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
If K is assembled on line 2, which one of the following must be true?

# Options:
A) F is assembled on a lower-numbered line than S.
B) H is assembled on a lower-numbered line than G.
C) J is assembled on a lower-numbered line than H.
D) M is assembled on a lower-numbered line than J.
E) S is assembled on a lower-numbered line than J.","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assembled = Function([models] -> [lines])
# Constraints
assembled(F) < assembled(J) ::: F is assembled on a lower-numbered line than J
assembled(M) == assembled(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assembled(H) == 1, assembled(H) == 7) ::: H is assembled on line 1 or else line 7
assembled(S) == 4 ::: S is assembled on line 4
assembled(K) == 2 ::: K is assembled on line 2
# Options
is_valid(assembled(F) < assembled(S)) ::: (A)
is_valid(assembled(H) < assembled(G)) ::: (B)
is_valid(assembled(J) < assembled(H)) ::: (C)
is_valid(assembled(M) < assembled(J)) ::: (D)
is_valid(assembled(S) < assembled(J)) ::: (E)"
"# Context:
Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.

# Question:
Which one of the following could be a complete and accurate matching of each park to its attractions?

# Options:
A) Jessup: garden, museum; Island: playground; Hilltop: garden, theater
B) Jessup: museum, theater; Island: garden; Hilltop: fountain, garden, playground, theater
C) Jessup: garden, museum, playground; Island: theater; Hilltop: garden, museum, playground
D) Jessup: garden, museum, playground; Island: fountain; Hilltop: garden, theater
E) Jessup: museum, playground; Island: fountain, garden; Hilltop: garden, theater","# Declarations
parks = EnumSort([Jessup, Island, Hilltop])
attractions = EnumSort([fountain, garden, museum, playground, theater])
has_attraction = Function([parks, attractions] -> [bool])
# Constraints
ForAll([p:parks], Exists([a:attractions], has_attraction(p, a))) ::: Each park has at least one attraction
ForAll([a:attractions], Exists([p:parks], has_attraction(p, a))) ::: At least one of each type of attraction is included
ForAll([p:parks, a:attractions], Not(And(has_attraction(p, a), Exists([p1:parks], And(p1 != p, has_attraction(p1, a)))))) ::: No two attractions of the same type are included in any park
Count([p:parks], Exists([a:attractions], has_attraction(p, garden))) == 2 ::: Each of exactly two parks has a garden
has_attraction(Jessup, museum) ::: Jessup has a museum
Not(has_attraction(Jessup, theater)) ::: Jessup does not have a theater
Count([a:attractions], has_attraction(Island, a)) == 1 ::: Island has exactly one attraction
ForAll([p:parks], Implies(has_attraction(p, playground), Not(has_attraction(p, fountain)))) ::: No park has both a playground and a fountain
ForAll([p:parks], Implies(has_attraction(p, theater), has_attraction(p, garden))) ::: Each park that has a theater also has a garden
ForAll([p:parks], Implies(has_attraction(p, museum), has_attraction(p, playground))) ::: Each park that has a museum also has a playground
# Options
is_accurate_list([has_attraction(Jessup, garden), has_attraction(Jessup, museum), has_attraction(Island, playground), has_attraction(Hilltop, garden), has_attraction(Hilltop, theater)]) ::: (A)
is_accurate_list([has_attraction(Jessup, museum), has_attraction(Jessup, theater), has_attraction(Island, garden), has_attraction(Hilltop, fountain), has_attraction(Hilltop, garden), has_attraction(Hilltop, playground), has_attraction(Hilltop, theater)]) ::: (B)
is_accurate_list([has_attraction(Jessup, garden), has_attraction(Jessup, museum), has_attraction(Jessup, playground), has_attraction(Island, theater), has_attraction(Hilltop, garden), has_attraction(Hilltop, museum), has_attraction(Hilltop, playground)]) ::: (C)
is_accurate_list([has_attraction(Jessup, garden), has_attraction(Jessup, museum), has_attraction(Jessup, playground), has_attraction(Island, fountain), has_attraction(Hilltop, garden), has_attraction(Hilltop, theater)]) ::: (D)
is_accurate_list([has_attraction(Jessup, museum), has_attraction(Jessup, playground), has_attraction(Island, fountain), has_attraction(Island, garden), has_attraction(Hilltop, garden), has_attraction(Hilltop, theater)]) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
Which one of the following must be true?

# Options:
A) Fewer of the languages are learned by the historian than are learned by the paleontologist.
B) Fewer of the languages are learned by the geologist than are learned by the historian.
C) Fewer of the languages are learned by the geologist than are learned by the linguist.
D) Fewer of the languages are learned by the paleontologist than are learned by the linguist.
E) Fewer of the languages are learned by the paleontologist than are learned by the historian.","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learned = Function([researchers, languages] -> [bool])
# Constraints
Count([r:researchers], learned(r, Rundi)) == 1 ::: Exactly one researcher learns Rundi
Count([r:researchers], learned(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learned(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learned(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learned(linguist, l), learned(paleontologist, l)), Not(learned(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learned(geologist, l), learned(historian, l))) ::: Any language learned by the geologist is learned by the historian
ForAll([r:researchers], And(Count([l:languages], learned(r, l)) >= 1, Count([l:languages], learned(r, l)) <= 3)) ::: Each researcher learns at least one and at most three languages
# Options
is_valid(Count([l:languages], learned(historian, l)) < Count([l:languages], learned(paleontologist, l))) ::: (A)
is_valid(Count([l:languages], learned(geologist, l)) < Count([l:languages], learned(historian, l))) ::: (B)
is_valid(Count([l:languages], learned(geologist, l)) < Count([l:languages], learned(linguist, l))) ::: (C)
is_valid(Count([l:languages], learned(paleontologist, l)) < Count([l:languages], learned(linguist, l))) ::: (D)
is_valid(Count([l:languages], learned(paleontologist, l)) < Count([l:languages], learned(historian, l))) ::: (E)"
"# Context:
A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.

# Question:
If the German award is presented third, which one of the following could be true?

# Options:
A) The French award is presented fourth.
B) The Japanese award is presented fifth.
C) The Japanese award is presented sixth.
D) The Korean award is presented second.
E) The Swahili award is presented fifth.","# Declarations
awards = EnumSort([French, German, Hebrew, Japanese, Korean, Latin, Swahili])
positions = EnumSort([1, 2, 3, 4, 5, 6, 7])
presented = Function([awards] -> [positions])
# Constraints
presented(German) != 1 ::: The German award is not presented first
Exists([p:positions], And(p < presented(Korean), presented(Hebrew) == p)) ::: The Hebrew award is presented at some time before the Korean award is presented
Exists([p:positions], And(p < presented(Japanese), presented(Latin) == p)) ::: The Latin award is presented at some time before the Japanese award is presented
Or(presented(French) == presented(Hebrew) - 1, presented(French) == presented(Hebrew) + 1) ::: The French award is presented either immediately before or immediately after the Hebrew award is presented
Or(presented(Korean) == presented(Latin) - 1, presented(Korean) == presented(Latin) + 1) ::: The Korean award is presented either immediately before or immediately after the Latin award is presented
presented(German) == 3 ::: The German award is presented third
# Options
is_valid(presented(French) == 4) ::: (A)
is_valid(presented(Japanese) == 5) ::: (B)
is_valid(presented(Japanese) == 6) ::: (C)
is_valid(presented(Korean) == 2) ::: (D)
is_valid(presented(Swahili) == 5) ::: (E)"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
Which one of the following pairs of birds CANNOT be among those birds contained in the forest?

# Options:
A) jays, wrens
B) jays, shrikes
C) shrikes, wrens
D) jays, martins
E) shrikes, martins","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
# Options
is_unsat(And(in_forest(jay), in_forest(wren))) ::: (A)
is_unsat(And(in_forest(jay), in_forest(shrike))) ::: (B)
is_unsat(And(in_forest(shrike), in_forest(wren))) ::: (C)
is_unsat(And(in_forest(jay), in_forest(martin))) ::: (D)
is_unsat(And(in_forest(shrike), in_forest(martin))) ::: (E)"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
Which one of the following is the maximum number of the six kinds of birds the forest could contain?

# Options:
A) two
B) three
C) four
D) five
E) six","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
# Options
is_sat(Count([b:birds], in_forest(b)) == 2) ::: (A)
is_sat(Count([b:birds], in_forest(b)) == 3) ::: (B)
is_sat(Count([b:birds], in_forest(b)) == 4) ::: (C)
is_sat(Count([b:birds], in_forest(b)) == 5) ::: (D)
is_sat(Count([b:birds], in_forest(b)) == 6) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
If the geologist learns exactly two of the languages, then which one of the following could be true?

# Options:
A) The paleontologist learns Rundi.
B) The paleontologist learns Swahili.
C) The historian learns Rundi.
D) The paleontologist learns exactly three of the languages.
E) The historian learns exactly two of the languages.","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learns = Function([researchers, languages] -> [bool])
# Constraints
Count([r:researchers], learns(r, Rundi)) == 1 ::: Exactly one researcher learns Rundi
Count([r:researchers], learns(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learns(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learns(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learns(linguist, l), learns(paleontologist, l)), Not(learns(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learns(geologist, l), learns(historian, l))) ::: Any language learned by the geologist is learned by the historian
Count([l:languages], learns(geologist, l)) == 2 ::: The geologist learns exactly two of the languages
# Options
is_valid(learns(paleontologist, Rundi)) ::: (A)
is_valid(learns(paleontologist, Swahili)) ::: (B)
is_valid(learns(historian, Rundi)) ::: (C)
is_valid(Count([l:languages], learns(paleontologist, l)) == 3) ::: (D)
is_valid(Count([l:languages], learns(historian, l)) == 2) ::: (E)"
"# Context:
On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.

# Question:
If bill 4 is paid on Thursday, which one of the following is a pair of bills that could also be paid on Thursday?

# Options:
A) 1 and 5
B) 1 and 7
C) 3 and 5
D) 3 and 6
E) 6 and 7","# Declarations
bills = EnumSort([1, 2, 3, 4, 5, 6, 7])
days = EnumSort([Wednesday, Thursday])
paid_on = Function([bills] -> [days])
# Constraints
Or(Count([b:bills], paid_on(b) == Wednesday) == 3, Count([b:bills], paid_on(b) == Wednesday) == 4) ::: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday
paid_on(1) != paid_on(5) ::: Bill 1 cannot be paid on the same day as bill 5
paid_on(2) == Thursday ::: Bill 2 must be paid on Thursday
paid_on(4) == paid_on(7) ::: Bill 4 must be paid on the same day as bill 7
Implies(paid_on(6) == Wednesday, paid_on(7) == Thursday) ::: If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday
paid_on(4) == Thursday ::: Bill 4 must be paid on Thursday
# Options
is_valid(And(paid_on(1) == Thursday, paid_on(5) == Thursday)) ::: (A)
is_valid(And(paid_on(1) == Thursday, paid_on(7) == Thursday)) ::: (B)
is_valid(And(paid_on(3) == Thursday, paid_on(5) == Thursday)) ::: (C)
is_valid(And(paid_on(3) == Thursday, paid_on(6) == Thursday)) ::: (D)
is_valid(And(paid_on(6) == Thursday, paid_on(7) == Thursday)) ::: (E)"
"# Context:
A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.

# Question:
If the Hebrew award is presented fourth, which one of the following must be true?

# Options:
A) The French award is presented fifth.
B) The German award is presented third.
C) The Japanese award is presented sixth.
D) The Korean award is presented fifth.
E) The Swahili award is presented first.","# Declarations
awards = EnumSort([French, German, Hebrew, Japanese, Korean, Latin, Swahili])
positions = EnumSort([1, 2, 3, 4, 5, 6, 7])
presented = Function([awards] -> [positions])
# Constraints
presented(German) != 1 ::: The German award is not presented first
Exists([p:positions], And(p < presented(Korean), presented(Hebrew) == p)) ::: The Hebrew award is presented at some time before the Korean award is presented
Exists([p:positions], And(p < presented(Japanese), presented(Latin) == p)) ::: The Latin award is presented at some time before the Japanese award is presented
Or(presented(French) == presented(Hebrew) - 1, presented(French) == presented(Hebrew) + 1) ::: The French award is presented either immediately before or immediately after the Hebrew award is presented
Or(presented(Korean) == presented(Latin) - 1, presented(Korean) == presented(Latin) + 1) ::: The Korean award is presented either immediately before or immediately after the Latin award is presented
presented(Hebrew) == 4 ::: The Hebrew award is presented fourth
# Options
is_valid(presented(French) == 5) ::: (A)
is_valid(presented(German) == 3) ::: (B)
is_valid(presented(Japanese) == 6) ::: (C)
is_valid(presented(Korean) == 5) ::: (D)
is_valid(presented(Swahili) == 1) ::: (E)"
"# Context:
From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.

# Question:
If J and M are the only sapphires selected, which one of the following could be true?

# Options:
A) F and G are both selected.
B) F and X are both selected.
C) G and H are both selected.
D) G and K are both selected.
E) Y and Z are both selected.","# Declarations
stones = EnumSort([F, G, H, J, K, M, W, X, Y, Z])
rings = EnumSort([ring1, ring2, ring3, ring4, ring5, ring6])
selected = Function([stones] -> [bool])
# Constraints
Count([s:stones], And(selected(s), Or(s == W, s == X, s == Y, s == Z))) >= 2 ::: At least two of the topazes are selected
Implies(Count([s:stones], And(selected(s), Or(s == J, s == K, s == M))) == 2, Count([s:stones], And(selected(s), Or(s == F, s == G, s == H))) == 1) ::: If exactly two of the sapphires are selected, exactly one of the rubies is selected
Implies(selected(W), And(Not(selected(H)), Not(selected(Z)))) ::: If W is selected, neither H nor Z is selected
Implies(selected(M), selected(W)) ::: If M is selected, W is also selected
selected(J) ::: J is selected
selected(M) ::: M is selected
ForAll([s:stones], Implies(And(s != J, s != M, Or(s == J, s == K, s == M)), Not(selected(s)))) ::: J and M are the only sapphires selected
# Options
is_sat(And(selected(F), selected(G))) ::: (A)
is_sat(And(selected(F), selected(X))) ::: (B)
is_sat(And(selected(G), selected(H))) ::: (C)
is_sat(And(selected(G), selected(K))) ::: (D)
is_sat(And(selected(Y), selected(Z))) ::: (E)"
"# Context:
A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.

# Question:
If habitat 2 contains at least one female snake and habitat 4 contains two male lizards, then which one of the following could be true?

# Options:
A) Habitat 3 contains two reptiles.
B) Habitat 5 contains two reptiles.
C) Habitat 1 contains a female lizard.
D) Habitat 2 contains a female lizard.
E) Habitat 5 contains a female lizard.","# Declarations
habitats = EnumSort([1, 2, 3, 4, 5])
reptiles = EnumSort([snake1, snake2, snake3, snake4, lizard1, lizard2, lizard3])
genders = EnumSort([male, female])
species = EnumSort([snake, lizard])
housed = Function([reptiles] -> [habitats])
reptile_gender = Function([reptiles] -> [genders])
reptile_species = Function([reptiles] -> [species])
# Constraints
ForAll([r:reptiles], Exists([h:habitats], housed(r) == h)) ::: Each reptile is housed in exactly one habitat
ForAll([h:habitats], Count([r:reptiles], housed(r) == h) <= 2) ::: No habitat houses more than two reptiles
ForAll([r:reptiles], ForAll([r2:reptiles], Implies(And(reptile_species(r) == snake, reptile_species(r2) == lizard), housed(r) != housed(r2)))) ::: No habitat houses both a snake and a lizard
ForAll([r:reptiles], Implies(And(reptile_species(r) == snake, reptile_gender(r) == female), And(housed(r) != 1, housed(r) != 5))) ::: No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard
Count([r:reptiles], And(reptile_gender(r) == female, reptile_species(r) == snake, housed(r) == 2)) >= 1 ::: Habitat 2 contains at least one female snake
Count([r:reptiles], And(reptile_gender(r) == male, reptile_species(r) == lizard, housed(r) == 4)) == 2 ::: Habitat 4 contains two male lizards
# Options
is_valid(Count([r:reptiles], housed(r) == 3) == 2) ::: (A) Habitat 3 contains two reptiles
is_valid(Count([r:reptiles], housed(r) == 5) == 2) ::: (B) Habitat 5 contains two reptiles
is_valid(Exists([r:reptiles], And(reptile_species(r) == lizard, reptile_gender(r) == female, housed(r) == 1))) ::: (C) Habitat 1 contains a female lizard
is_valid(Exists([r:reptiles], And(reptile_species(r) == lizard, reptile_gender(r) == female, housed(r) == 2))) ::: (D) Habitat 2 contains a female lizard
is_valid(Exists([r:reptiles], And(reptile_species(r) == lizard, reptile_gender(r) == female, housed(r) == 5))) ::: (E) Habitat 5 contains a female lizard"
"# Context:
Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.

# Question:
If jays are not in the forest, then which one of the following must be false?

# Options:
A) Martins are in the forest.
B) Harriers are in the forest.
C) Neither martins nor harriers are in the forest.
D) Neither martins nor shrikes are in the forest.
E) Harriers and shrikes are the only birds in the forest.","# Declarations
birds = EnumSort([grosbeak, harrier, jay, martin, shrike, wren])
in_forest = Function([birds] -> [bool])
# Constraints
Implies(in_forest(harrier), Not(in_forest(grosbeak))) ::: If harriers are in the forest, then grosbeaks are not
Implies(Or(in_forest(jay), in_forest(martin)), in_forest(harrier)) ::: If jays, martins, or both are in the forest, then so are harriers
Implies(in_forest(wren), in_forest(grosbeak)) ::: If wrens are in the forest, then so are grosbeaks
Implies(Not(in_forest(jay)), in_forest(shrike)) ::: If jays are not in the forest, then shrikes are
# Options
is_unsat(in_forest(martin)) ::: (A)
is_unsat(in_forest(harrier)) ::: (B)
is_unsat(And(Not(in_forest(martin)), Not(in_forest(harrier)))) ::: (C)
is_unsat(And(Not(in_forest(martin)), Not(in_forest(shrike)))) ::: (D)
is_unsat(And(in_forest(harrier), in_forest(shrike), ForAll([b:birds], Implies(b != harrier, b != shrike, Not(in_forest(b)))))) ::: (E)"
"# Context:
On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.

# Question:
If bill 6 is paid on Wednesday, which one of the following bills must also be paid on Wednesday?

# Options:
A) 1
B) 3
C) 4
D) 5
E) 7","# Declarations
bills = EnumSort([1, 2, 3, 4, 5, 6, 7])
days = EnumSort([Wednesday, Thursday])
paid_on = Function([bills] -> [days])
# Constraints
Or(Count([b:bills], paid_on(b) == Wednesday) == 3, Count([b:bills], paid_on(b) == Wednesday) == 4) ::: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday
paid_on(1) != paid_on(5) ::: Bill 1 cannot be paid on the same day as bill 5
paid_on(2) == Thursday ::: Bill 2 must be paid on Thursday
paid_on(4) == paid_on(7) ::: Bill 4 must be paid on the same day as bill 7
Implies(paid_on(6) == Wednesday, paid_on(7) == Thursday) ::: If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday
paid_on(6) == Wednesday ::: If bill 6 is paid on Wednesday
# Options
is_valid(paid_on(1) == Wednesday) ::: (A)
is_valid(paid_on(3) == Wednesday) ::: (B)
is_valid(paid_on(4) == Wednesday) ::: (C)
is_valid(paid_on(5) == Wednesday) ::: (D)
is_valid(paid_on(7) == Wednesday) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
Each of the following could be complete and accurate list of the film buffs who see the Fellini film EXCEPT:

# Options:
A) Ginnie, Ian
B) Ginnie, Marcos
C) Ian, Reveka
D) Marcos, Reveka
E) Viktor, Yow","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
directors = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [directors])
# Constraints
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
# Options
is_accurate_list([sees(Ginnie) == Fellini, sees(Ian) == Fellini]) ::: (A)
is_accurate_list([sees(Ginnie) == Fellini, sees(Marcos) == Fellini]) ::: (B)
is_accurate_list([sees(Ian) == Fellini, sees(Reveka) == Fellini]) ::: (C)
is_accurate_list([sees(Marcos) == Fellini, sees(Reveka) == Fellini]) ::: (D)
is_accurate_list([sees(Viktor) == Fellini, sees(Yow) == Fellini]) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
There can be at most how many lines between the line on which F is assembled and the line on which J is assembled?

# Options:
A) one
B) two
C) three
D) four
E) five","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assembled = Function([models] -> [lines])
# Constraints
assembled(F) < assembled(J) ::: F is assembled on a lower-numbered line than J
assembled(M) == assembled(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assembled(H) == 1, assembled(H) == 7) ::: H is assembled on line 1 or else line 7
assembled(S) == 4 ::: S is assembled on line 4
# Options
is_valid(assembled(J) - assembled(F) <= 1) ::: (A)
is_valid(assembled(J) - assembled(F) <= 2) ::: (B)
is_valid(assembled(J) - assembled(F) <= 3) ::: (C)
is_valid(assembled(J) - assembled(F) <= 4) ::: (D)
is_valid(assembled(J) - assembled(F) <= 5) ::: (E)"
"# Context:
During three days—Monday through Wednesday—a health officer will inspect exactly six buildings—three hotels: Grace, Jacaranda, and Lido; and three restaurants: Seville, Vesuvio, and Zeno. Each day, exactly two buildings are inspected: one in the morning and one in the afternoon. Inspections must occur according to the following conditions: Hotels are not inspected on Wednesday. Grace is inspected at some time before Jacaranda. Grace is not inspected on the same day as Seville. If Zeno is inspected in the morning, Lido is also inspected in the morning.

# Question:
If Seville is inspected on Monday morning, which one of the following must be true?

# Options:
A) Grace is inspected on Tuesday afternoon.
B) Jacaranda is inspected on Monday afternoon.
C) Lido is inspected on Tuesday morning.
D) Vesuvio is inspected on Wednesday morning.
E) Zeno is inspected on Wednesday morning.","# Declarations
days = EnumSort([Monday, Tuesday, Wednesday])
times = EnumSort([morning, afternoon])
buildings = EnumSort([Grace, Jacaranda, Lido, Seville, Vesuvio, Zeno])
inspected = Function([buildings, days, times] -> [bool])
# Constraints
ForAll([b:buildings], Exists([d:days, t:times], inspected(b, d, t))) ::: Each building is inspected exactly once
ForAll([d:days], Count([b:buildings, t:times], inspected(b, d, t)) == 2) ::: Exactly two buildings are inspected each day
ForAll([b:buildings], Implies(Or(b == Grace, b == Jacaranda, b == Lido), Not(Exists([t:times], inspected(b, Wednesday, t))))) ::: Hotels are not inspected on Wednesday
Exists([d:days, t:times], And(inspected(Grace, d, t), ForAll([d1:days, t1:times], Implies(And(d1 == d, t1 == t), Not(inspected(Jacaranda, d1, t1)))))) ::: Grace is inspected at some time before Jacaranda
ForAll([d:days], Implies(Exists([t:times], inspected(Grace, d, t)), Not(Exists([t:times], inspected(Seville, d, t))))) ::: Grace is not inspected on the same day as Seville
ForAll([d:days], Implies(Exists([t:times], inspected(Zeno, d, morning)), Exists([t:times], inspected(Lido, d, morning)))) ::: If Zeno is inspected in the morning, Lido is also inspected in the morning
inspected(Seville, Monday, morning) ::: Seville is inspected on Monday morning
# Options
is_valid(inspected(Grace, Tuesday, afternoon)) ::: (A)
is_valid(inspected(Jacaranda, Monday, afternoon)) ::: (B)
is_valid(inspected(Lido, Tuesday, morning)) ::: (C)
is_valid(inspected(Vesuvio, Wednesday, morning)) ::: (D)
is_valid(inspected(Zeno, Wednesday, morning)) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
If K is assembled on line 5, which one of the following is a pair of models that could be assembled, not necessarily in the order given, on lines whose numbers are consecutive to each other?

# Options:
A) G, H
B) G, J
C) H, J
D) J, M
E) M, S","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assembled = Function([models] -> [lines])
# Constraints
assembled(F) < assembled(J) ::: F is assembled on a lower-numbered line than J
assembled(M) == assembled(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assembled(H) == 1, assembled(H) == 7) ::: H is assembled on line 1 or else line 7
assembled(S) == 4 ::: S is assembled on line 4
assembled(K) == 5 ::: K is assembled on line 5
# Options
is_valid(Or(assembled(G) == assembled(H) + 1, assembled(H) == assembled(G) + 1)) ::: (A)
is_valid(Or(assembled(G) == assembled(J) + 1, assembled(J) == assembled(G) + 1)) ::: (B)
is_valid(Or(assembled(H) == assembled(J) + 1, assembled(J) == assembled(H) + 1)) ::: (C)
is_valid(Or(assembled(J) == assembled(M) + 1, assembled(M) == assembled(J) + 1)) ::: (D)
is_valid(Or(assembled(M) == assembled(S) + 1, assembled(S) == assembled(M) + 1)) ::: (E)"
"# Context:
A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.

# Question:
If Tantoko is ranked third highest, then which one of the following CANNOT be true?

# Options:
A) Lautrec ranked fourth highest.
B) Pastilla is ranked fifth highest.
C) Medici is ranked fifth highest.
D) Scheherazade's is ranked fifth highest.
E) Medici is ranked sixth highest.","# Declarations
restaurants = EnumSort([Lautrec, Medici, Pastilla, Robusto, Scheherazades, Tantoko, Vistula])
rank = Function([restaurants] -> [int])
# Constraints
rank(Pastilla) > rank(Lautrec) ::: Pastilla ranks higher than Lautrec
rank(Pastilla) < rank(Robusto) ::: Pastilla ranks lower than Robusto
rank(Medici) > rank(Vistula) ::: Medici ranks higher than Vistula
rank(Medici) < rank(Tantoko) ::: Medici ranks lower than Tantoko
Implies(rank(Scheherazades) > rank(Pastilla), rank(Medici) > rank(Scheherazades)) ::: If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's
Implies(rank(Medici) > rank(Scheherazades), rank(Scheherazades) > rank(Pastilla)) ::: If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla
rank(Tantoko) == 3 ::: Tantoko is ranked third highest
# Options
is_unsat(rank(Lautrec) == 4) ::: (A)
is_unsat(rank(Pastilla) == 5) ::: (B)
is_unsat(rank(Medici) == 5) ::: (C)
is_unsat(rank(Scheherazades) == 5) ::: (D)
is_unsat(rank(Medici) == 6) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
If Viktor sees the same film as Ginnie does, then which one of the following could be true?

# Options:
A) Ginnie sees the Fellini film.
B) Ian sees the Hitchcock film.
C) Reveka sees the Kurosawa film.
D) Viktor sees the Hitchcock film.
E) Yow sees the Fellini film.","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
directors = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [directors])
# Constraints
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
sees(Viktor) == sees(Ginnie) ::: If Viktor sees the same film as Ginnie does
# Options
is_valid(sees(Ginnie) == Fellini) ::: (A)
is_valid(sees(Ian) == Hitchcock) ::: (B)
is_valid(sees(Reveka) == Kurosawa) ::: (C)
is_valid(sees(Viktor) == Hitchcock) ::: (D)
is_valid(sees(Yow) == Fellini) ::: (E)"
"# Context:
On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.

# Question:
If bill 2 and bill 6 are paid on different days from each other, which one of the following must be true?

# Options:
A) Exactly three bills are paid on Wednesday.
B) Exactly three bills are paid on Thursday.
C) Bill 1 is paid on the same day as bill 4.
D) Bill 2 is paid on the same day as bill 3.
E) Bill 5 is paid on the same day as bill 7.","# Declarations
bills = EnumSort([1, 2, 3, 4, 5, 6, 7])
days = EnumSort([Wednesday, Thursday])
paid_on = Function([bills] -> [days])
# Constraints
Or(Count([b:bills], paid_on(b) == Wednesday) == 3, Count([b:bills], paid_on(b) == Wednesday) == 4) ::: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday
paid_on(1) != paid_on(5) ::: Bill 1 cannot be paid on the same day as bill 5
paid_on(2) == Thursday ::: Bill 2 must be paid on Thursday
paid_on(4) == paid_on(7) ::: Bill 4 must be paid on the same day as bill 7
Implies(paid_on(6) == Wednesday, paid_on(7) == Thursday) ::: If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday
paid_on(2) != paid_on(6) ::: bill 2 and bill 6 are paid on different days from each other
# Options
is_valid(Count([b:bills], paid_on(b) == Wednesday) == 3) ::: (A)
is_valid(Count([b:bills], paid_on(b) == Thursday) == 3) ::: (B)
is_valid(paid_on(1) == paid_on(4)) ::: (C)
is_valid(paid_on(2) == paid_on(3)) ::: (D)
is_valid(paid_on(5) == paid_on(7)) ::: (E)"
"# Context:
A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.

# Question:
Which one of the following could be a complete and accurate matching of habitats to reptiles?

# Options:
A) 1: two female snakes; 2: one male snake; 3: one female lizard; 4: one male snake, one female lizard; 5: one female lizard
B) 1: empty; 2: two female snakes; 3: two female lizards; 4: two male snakes; 5: one female lizard
C) 1: one female snake, one male snake; 2: two female snakes; 3: one male lizard; 4: one female lizard; 5: one female lizard
D) 1: two male snakes; 2: empty; 3: one female lizard; 4: one female lizard; 5: two female snakes, one female lizard
E) 1: one female snake, one male snake; 2: one female snake, one male snake; 3: one male lizard; 4: one female lizard; 5: one female lizard","# Declarations
habitats = EnumSort([1, 2, 3, 4, 5])
reptiles = EnumSort([Snake1, Snake2, Snake3, Snake4, Lizard1, Lizard2, Lizard3])
genders = EnumSort([Male, Female])
species = EnumSort([Snake, Lizard])
housed = Function([reptiles] -> [habitats])
reptile_gender = Function([reptiles] -> [genders])
reptile_species = Function([reptiles] -> [species])
# Constraints
ForAll([h:habitats], Count([r:reptiles], housed(r) == h) <= 2) ::: No habitat houses more than two reptiles
ForAll([h:habitats], ForAll([r1:reptiles, r2:reptiles], Implies(And(housed(r1) == h, housed(r2) == h, r1 != r2), reptile_species(r1) == reptile_species(r2)))) ::: No habitat houses both a snake and a lizard
ForAll([r:reptiles], Implies(And(reptile_species(r) == Snake, reptile_gender(r) == Female), And(ForAll([r2:reptiles], Implies(And(reptile_species(r2) == Lizard, reptile_gender(r2) == Male, Abs(housed(r) - housed(r2)) == 1), False))))) ::: No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard
# Options
is_accurate_list([And(housed(Snake1) == 1, housed(Snake2) == 1, reptile_gender(Snake1) == Female, reptile_gender(Snake2) == Female), housed(Snake3) == 2, reptile_gender(Snake3) == Male, housed(Lizard1) == 3, reptile_gender(Lizard1) == Female, And(housed(Snake4) == 4, housed(Lizard2) == 4, reptile_gender(Snake4) == Male, reptile_gender(Lizard2) == Female), housed(Lizard3) == 5, reptile_gender(Lizard3) == Female]) ::: (A)
is_accurate_list([housed(Snake1) == 2, housed(Snake2) == 2, reptile_gender(Snake1) == Female, reptile_gender(Snake2) == Female, housed(Lizard1) == 3, housed(Lizard2) == 3, reptile_gender(Lizard1) == Female, reptile_gender(Lizard2) == Female, housed(Snake3) == 4, housed(Snake4) == 4, reptile_gender(Snake3) == Male, reptile_gender(Snake4) == Male, housed(Lizard3) == 5, reptile_gender(Lizard3) == Female]) ::: (B)
is_accurate_list([And(housed(Snake1) == 1, housed(Snake2) == 1, reptile_gender(Snake1) == Female, reptile_gender(Snake2) == Male), housed(Snake3) == 2, housed(Snake4) == 2, reptile_gender(Snake3) == Female, reptile_gender(Snake4) == Female, housed(Lizard1) == 3, reptile_gender(Lizard1) == Male, housed(Lizard2) == 4, reptile_gender(Lizard2) == Female, housed(Lizard3) == 5, reptile_gender(Lizard3) == Female]) ::: (C)
is_accurate_list([And(housed(Snake1) == 1, housed(Snake2) == 1, reptile_gender(Snake1) == Male, reptile_gender(Snake2) == Male), housed(Lizard1) == 3, reptile_gender(Lizard1) == Female, housed(Lizard2) == 4, reptile_gender(Lizard2) == Female, And(housed(Snake3) == 5, housed(Snake4) == 5, reptile_gender(Snake3) == Female, reptile_gender(Snake4) == Female), housed(Lizard3) == 5, reptile_gender(Lizard3) == Female]) ::: (D)
is_accurate_list([And(housed(Snake1) == 1, housed(Snake2) == 1, reptile_gender(Snake1) == Female, reptile_gender(Snake2) == Male), And(housed(Snake3) == 2, housed(Snake4) == 2, reptile_gender(Snake3) == Female, reptile_gender(Snake4) == Male), housed(Lizard1) == 3, reptile_gender(Lizard1) == Male, housed(Lizard2) == 4, reptile_gender(Lizard2) == Female, housed(Lizard3) == 5, reptile_gender(Lizard3) == Female]) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
It must be true that the lowest-numbered line on which

# Options:
A) F can be assembled is line 2
B) G can be assembled is line 3
C) J can be assembled is line 2
D) K can be assembled is line 3
E) M can be assembled is line 2","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assembled = Function([models] -> [lines])
# Constraints
assembled(F) < assembled(J) ::: F is assembled on a lower-numbered line than J
assembled(M) == assembled(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assembled(H) == 1, assembled(H) == 7) ::: H is assembled on line 1 or else line 7
assembled(S) == 4 ::: S is assembled on line 4
# Options
is_valid(assembled(F) >= 2) ::: (A)
is_valid(assembled(G) >= 3) ::: (B)
is_valid(assembled(J) >= 2) ::: (C)
is_valid(assembled(K) >= 3) ::: (D)
is_valid(assembled(M) >= 2) ::: (E)"
"# Context:
Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.

# Question:
If Francisco sits in chair 2 and Olivia sits next to Simone, Gabrielle must sit next to which one of the following persons?

# Options:
A) Francisco
B) Olivia
C) Lee
D) Raymond
E) Peter","# Declarations
persons = EnumSort([Francisco, Gabrielle, Kyoko, Lee, Olivia, Peter, Raymond, Simone])
chairs = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
spouses = Function([persons] -> [persons])
sits = Function([persons] -> [chairs])
# Constraints
sits(Simone) == 1 ::: Simone sits in chair 1
sits(Raymond) == 4 ::: Raymond sits in chair 4
ForAll([p:persons], And(sits(p) != sits(spouses(p)) + 1, sits(p) != sits(spouses(p)) - 1, sits(p) != sits(spouses(p)) + 7, sits(p) != sits(spouses(p)) - 7)) ::: No person sits next to her or his spouse
sits(Francisco) == 2 ::: Francisco sits in chair 2
Or(sits(Olivia) == 2, sits(Olivia) == 8) ::: Olivia sits next to Simone
ForAll([p:persons], Implies(sits(p) == 3, Not(Or(p == Peter, p == Olivia)))) ::: Neither Peter nor Olivia sits next to Raymond
ForAll([p:persons], Implies(sits(p) == 3, Not(Or(p == Kyoko, p == Lee)))) ::: Neither Kyoko nor Lee sits next to Gabrielle
# Options
is_valid(sits(Gabrielle) == sits(Francisco) + 1) ::: (A)
is_valid(sits(Gabrielle) == sits(Olivia) + 1) ::: (B)
is_valid(sits(Gabrielle) == sits(Lee) + 1) ::: (C)
is_valid(sits(Gabrielle) == sits(Raymond) + 1) ::: (D)
is_valid(sits(Gabrielle) == sits(Peter) + 1) ::: (E)"
"# Context:
At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.

# Question:
If J and P are teammates in the boat race, then M could be the teammate of

# Options:
A) K in the boat race and S in the rescue exercise
B) L in the boat race and S in the rescue exercise
C) R in the boat race and L in the rescue exercise
D) S in the boat race and K in the rescue exercise
E) S in the boat race and P in the rescue exercise","# Declarations
lifeguards = EnumSort([J, K, L, M, P, Q, R, S])
events = EnumSort([boat_race, rescue_exercise])
teammates = Function([lifeguards, lifeguards, events] -> [bool])
# Constraints
ForAll([a:lifeguards, b:lifeguards], Implies(teammates(a, b, boat_race), Not(teammates(a, b, rescue_exercise)))) ::: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise
teammates(L, Q, boat_race) ::: L and Q are teammates in the boat race
teammates(K, L, rescue_exercise) ::: K and L are teammates in the rescue exercise
ForAll([e:events], Not(teammates(R, S, e))) ::: R and S are not teammates in either event
teammates(J, P, boat_race) ::: J and P are teammates in the boat race
# Options
is_valid(And(teammates(M, K, boat_race), teammates(M, S, rescue_exercise))) ::: (A)
is_valid(And(teammates(M, L, boat_race), teammates(M, S, rescue_exercise))) ::: (B)
is_valid(And(teammates(M, R, boat_race), teammates(M, L, rescue_exercise))) ::: (C)
is_valid(And(teammates(M, S, boat_race), teammates(M, K, rescue_exercise))) ::: (D)
is_valid(And(teammates(M, S, boat_race), teammates(M, P, rescue_exercise))) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
Each of the following could be a complete and accurate list of the researchers who learn both Swahili and Yoruba EXCEPT:

# Options:
A) the historian
B) the paleontologist
C) the historian, the linguist
D) the historian, the paleontologist
E) the linguist, the paleontologist","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learns = Function([researchers, languages] -> [bool])
# Constraints
Count([r:researchers], learns(r, Rundi)) == 1 ::: Exactly one researcher learns Rundi
Count([r:researchers], learns(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learns(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learns(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learns(linguist, l), learns(paleontologist, l)), Not(learns(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learns(geologist, l), learns(historian, l))) ::: Any language learned by the geologist is learned by the historian
ForAll([r:researchers], And(Count([l:languages], learns(r, l)) >= 1, Count([l:languages], learns(r, l)) <= 3)) ::: Each researcher learns at least one and at most three languages
# Options
is_accurate_list([learns(historian, Swahili), learns(historian, Yoruba)]) ::: (A)
is_accurate_list([learns(paleontologist, Swahili), learns(paleontologist, Yoruba)]) ::: (B)
is_accurate_list([learns(historian, Swahili), learns(historian, Yoruba), learns(linguist, Swahili), learns(linguist, Yoruba)]) ::: (C)
is_accurate_list([learns(historian, Swahili), learns(historian, Yoruba), learns(paleontologist, Swahili), learns(paleontologist, Yoruba)]) ::: (D)
is_accurate_list([learns(linguist, Swahili), learns(linguist, Yoruba), learns(paleontologist, Swahili), learns(paleontologist, Yoruba)]) ::: (E)"
"# Context:
A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.

# Question:
Which one of the following must be true?

# Options:
A) The French award is presented at some time before the Japanese award is presented.
B) The French award is presented at some time before the Swahili award is presented.
C) The German award is presented at some time before the Korean award is presented.
D) The German award is presented at some time before the Swahili award is presented.
E) The Swahili award is presented at some time before the Hebrew award is presented.","# Declarations
awards = EnumSort([French, German, Hebrew, Japanese, Korean, Latin, Swahili])
position = Function([awards] -> [int])
# Constraints
position(German) != 1 ::: The German award is not presented first
position(Hebrew) < position(Korean) ::: The Hebrew award is presented at some time before the Korean award is presented
position(Latin) < position(Japanese) ::: The Latin award is presented at some time before the Japanese award is presented
Or(position(French) == position(Hebrew) - 1, position(French) == position(Hebrew) + 1) ::: The French award is presented either immediately before or immediately after the Hebrew award is presented
Or(position(Korean) == position(Latin) - 1, position(Korean) == position(Latin) + 1) ::: The Korean award is presented either immediately before or immediately after the Latin award is presented
# Options
is_valid(position(French) < position(Japanese)) ::: (A)
is_valid(position(French) < position(Swahili)) ::: (B)
is_valid(position(German) < position(Korean)) ::: (C)
is_valid(position(German) < position(Swahili)) ::: (D)
is_valid(position(Swahili) < position(Hebrew)) ::: (E)"
"# Context:
On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.

# Question:
Which one of the following is a complete and accurate list of the bills any one of which could be among the bills paid on Wednesday?

# Options:
A) 3, 5, and 6
B) 1, 3, 4, 6, and 7
C) 1, 3, 4, 5, 6, and 7
D) 2, 3, 4, 5, 6, and 7
E) 1, 2, 3, 4, 5, 6, and 7","# Declarations
bills = EnumSort([1, 2, 3, 4, 5, 6, 7])
days = EnumSort([Wednesday, Thursday])
paid_on = Function([bills] -> [days])
# Constraints
Or(Count([b:bills], paid_on(b) == Wednesday) == 3, Count([b:bills], paid_on(b) == Wednesday) == 4) ::: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday
paid_on(1) != paid_on(5) ::: Bill 1 cannot be paid on the same day as bill 5
paid_on(2) == Thursday ::: Bill 2 must be paid on Thursday
paid_on(4) == paid_on(7) ::: Bill 4 must be paid on the same day as bill 7
Implies(paid_on(6) == Wednesday, paid_on(7) == Thursday) ::: If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday
# Options
is_accurate_list([Exists([b:bills], And(b == 3, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 5, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 6, paid_on(b) == Wednesday))]) ::: (A)
is_accurate_list([Exists([b:bills], And(b == 1, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 3, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 4, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 6, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 7, paid_on(b) == Wednesday))]) ::: (B)
is_accurate_list([Exists([b:bills], And(b == 1, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 3, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 4, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 5, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 6, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 7, paid_on(b) == Wednesday))]) ::: (C)
is_accurate_list([Exists([b:bills], And(b == 2, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 3, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 4, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 5, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 6, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 7, paid_on(b) == Wednesday))]) ::: (D)
is_accurate_list([Exists([b:bills], And(b == 1, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 2, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 3, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 4, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 5, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 6, paid_on(b) == Wednesday)), Exists([b:bills], And(b == 7, paid_on(b) == Wednesday))]) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
Which one of the following must be true?

# Options:
A) Ginnie sees a different film than Ian does.
B) Ian sees a different film than Lianna does.
C) Ian sees a different film than Viktor does.
D) Ian, Lianna, and Viktor do not all see the same film.
E) Ginnie, Lianna, and Marcos do not all see the same film.","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
directors = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [directors])
# Constraints
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
# Options
is_valid(sees(Ginnie) != sees(Ian)) ::: (A)
is_valid(sees(Ian) != sees(Lianna)) ::: (B)
is_valid(sees(Ian) != sees(Viktor)) ::: (C)
is_valid(Not(And(sees(Ian) == sees(Lianna), sees(Lianna) == sees(Viktor)))) ::: (D)
is_valid(Not(And(sees(Ginnie) == sees(Lianna), sees(Lianna) == sees(Marcos)))) ::: (E)"
"# Context:
Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.

# Question:
Which one of the following is an acceptable assignment of toy-truck models to lines, on order from line 1 through line 7?

# Options:
A) F, J, K, S, H, M, G
B) F, K, J, S, M, G, H
C) F, M, K, S, G, J, H
D) H, K, S, M, G, F, J
E) H, M, G, S, J, F, K","# Declarations
models = EnumSort([F, G, H, J, K, M, S])
lines = EnumSort([1, 2, 3, 4, 5, 6, 7])
assigned = Function([models] -> [lines])
# Constraints
assigned(F) < assigned(J) ::: F is assembled on a lower-numbered line than J
assigned(M) == assigned(G) - 1 ::: M is assembled on the line numbered one lower than the line on which G is assembled
Or(assigned(H) == 1, assigned(H) == 7) ::: H is assembled on line 1 or else line 7
assigned(S) == 4 ::: S is assembled on line 4
# Options
is_accurate_list([assigned(F) == 1, assigned(J) == 2, assigned(K) == 3, assigned(S) == 4, assigned(H) == 5, assigned(M) == 6, assigned(G) == 7]) ::: (A)
is_accurate_list([assigned(F) == 1, assigned(K) == 2, assigned(J) == 3, assigned(S) == 4, assigned(M) == 5, assigned(G) == 6, assigned(H) == 7]) ::: (B)
is_accurate_list([assigned(F) == 1, assigned(M) == 2, assigned(K) == 3, assigned(S) == 4, assigned(G) == 5, assigned(J) == 6, assigned(H) == 7]) ::: (C)
is_accurate_list([assigned(H) == 1, assigned(K) == 2, assigned(S) == 4, assigned(M) == 5, assigned(G) == 6, assigned(F) == 7, assigned(J) == 8]) ::: (D)
is_accurate_list([assigned(H) == 1, assigned(M) == 2, assigned(G) == 3, assigned(S) == 4, assigned(J) == 5, assigned(F) == 6, assigned(K) == 7]) ::: (E)"
"# Context:
At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.

# Question:
If P and K are teammates in the boat race and P and Q are teammates in the rescue exercise, then each of the following lists a pair of lifeguards who must be teammates in one of the two events EXCEPT:

# Options:
A) J and M
B) J and R
C) J and S
D) M and R
E) M and S","# Declarations
lifeguards = EnumSort([J, K, L, M, P, Q, R, S])
boat_race = Function([lifeguards, lifeguards] -> [bool])
rescue_exercise = Function([lifeguards, lifeguards] -> [bool])
# Constraints
ForAll([a:lifeguards, b:lifeguards], Implies(boat_race(a, b), Not(rescue_exercise(a, b)))) ::: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise
boat_race(L, Q) ::: L and Q are teammates in the boat race
rescue_exercise(K, L) ::: K and L are teammates in the rescue exercise
ForAll([a:lifeguards], And(Not(boat_race(R, a)), Not(rescue_exercise(R, a)))) ::: R and S are not teammates in either event
boat_race(P, K) ::: P and K are teammates in the boat race
rescue_exercise(P, Q) ::: P and Q are teammates in the rescue exercise
# Options
is_valid(Or(boat_race(J, M), rescue_exercise(J, M))) ::: (A)
is_valid(Or(boat_race(J, R), rescue_exercise(J, R))) ::: (B)
is_valid(Or(boat_race(J, S), rescue_exercise(J, S))) ::: (C)
is_valid(Or(boat_race(M, R), rescue_exercise(M, R))) ::: (D)
is_valid(Or(boat_race(M, S), rescue_exercise(M, S))) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
Each of the following could be true of the researcher who learns Rundi EXCEPT:

# Options:
A) The researcher also learns Tigrinya but not Swahili.
B) The researcher learns neither Tigrinya nor Swahili.
C) The researcher also learns Tigrinya but not Yoruba.
D) The researcher also learns both Tigrinya and Yoruba.
E) The researcher also learns Yoruba but not Tigrinya.","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learns = Function([researchers, languages] -> [bool])
# Constraints
Exists([r:researchers], learns(r, Rundi)) ::: Exactly one researcher learns Rundi
Count([r:researchers], learns(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learns(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learns(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learns(linguist, l), learns(paleontologist, l)), Not(learns(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learns(geologist, l), learns(historian, l))) ::: Any language learned by the geologist is learned by the historian
ForAll([r:researchers], And(Count([l:languages], learns(r, l)) >= 1, Count([l:languages], learns(r, l)) <= 3)) ::: Each researcher learns at least one and at most three languages
# Options
is_unsat(And(learns(r, Rundi), learns(r, Tigrinya), Not(learns(r, Swahili)))) ::: (A)
is_unsat(And(learns(r, Rundi), Not(learns(r, Tigrinya)), Not(learns(r, Swahili)))) ::: (B)
is_unsat(And(learns(r, Rundi), learns(r, Tigrinya), Not(learns(r, Yoruba)))) ::: (C)
is_unsat(And(learns(r, Rundi), learns(r, Tigrinya), learns(r, Yoruba))) ::: (D)
is_unsat(And(learns(r, Rundi), learns(r, Yoruba), Not(learns(r, Tigrinya)))) ::: (E)"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
If mannequin 1 wears the skirt that is the same color as the jacket that mannequin 2 wears, which one of the following must be true?

# Options:
A) Mannequin 1 wears the yellow hat.
B) Mannequin 1 wears the yellow jacket.
C) Mannequin 2 wears the navy hat.
D) Mannequin 2 wears the red hat.
E) Mannequin 2 wears the red jacket.","# Declarations
mannequins = EnumSort([mannequin1, mannequin2])
colors = EnumSort([navy, red, yellow])
hats = Function([mannequins] -> [colors])
jackets = Function([mannequins] -> [colors])
skirts = Function([mannequins] -> [colors])
# Constraints
ForAll([m:mannequins], hats(m) != jackets(m)) ::: Each mannequin wears a hat in a different color from the jacket it wears
skirts(mannequin2) == navy ::: Mannequin 2 wears the navy skirt
Exists([m:mannequins], And(jackets(m) == red, hats(m) == red)) ::: Mannequin 1 wears the tie (implied by the tie being red and each mannequin wearing one of each color)
ForAll([m:mannequins], Not(And(hats(m) == navy, jackets(m) == red, skirts(m) == yellow))) ::: Neither mannequin wears all three colors
jackets(mannequin2) == skirts(mannequin1) ::: Mannequin 1 wears the skirt that is the same color as the jacket that mannequin 2 wears
# Options
is_valid(hats(mannequin1) == yellow) ::: (A)
is_valid(jackets(mannequin1) == yellow) ::: (B)
is_valid(hats(mannequin2) == navy) ::: (C)
is_valid(hats(mannequin2) == red) ::: (D)
is_valid(jackets(mannequin2) == red) ::: (E)"
"# Context:
Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.

# Question:
Each of the following could be true EXCEPT:

# Options:
A) Peter and Gabrielle sit in chairs 2 and 3, respectively.
B) Peter and Kyoko sit in chairs 1 and 3, respectively.
C) Francisco, Kyoko, and Peter sit in chairs 5, 6, and 7, respectively.
D) Gabrielle, Olivia, and Kyoko sit in chairs 5, 6, and 7, respectively.
E) Gabrielle, Peter, and Lee sit in chairs 5, 6, and 7, respectively.","# Declarations
people = EnumSort([Francisco, Gabrielle, Kyoko, Lee, Olivia, Peter, Raymond, Simone])
chairs = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
sits = Function([people] -> [chairs])
# Constraints
sits(Simone) == 1 ::: Simone sits in chair 1
sits(Raymond) == 4 ::: Raymond sits in chair 4
ForAll([p:people], ForAll([c:chairs], Implies(sits(p) == c, ForAll([p2:people], Implies(p2 != p, sits(p2) != c))))) ::: Each person sits in a different chair
ForAll([p:people], Implies(p == Gabrielle, And(sits(p) != sits(Francisco) + 1, sits(p) != sits(Francisco) - 1, sits(p) != 8, sits(p) != 1))) ::: No person sits next to her or his spouse
ForAll([p:people], Implies(p == Francisco, And(sits(p) != sits(Gabrielle) + 1, sits(p) != sits(Gabrielle) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([p:people], Implies(p == Kyoko, And(sits(p) != sits(Lee) + 1, sits(p) != sits(Lee) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([p:people], Implies(p == Lee, And(sits(p) != sits(Kyoko) + 1, sits(p) != sits(Kyoko) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([p:people], Implies(p == Olivia, And(sits(p) != sits(Peter) + 1, sits(p) != sits(Peter) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([p:people], Implies(p == Peter, And(sits(p) != sits(Olivia) + 1, sits(p) != sits(Olivia) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([p:people], Implies(p == Raymond, And(sits(p) != sits(Simone) + 1, sits(p) != sits(Simone) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([p:people], Implies(p == Simone, And(sits(p) != sits(Raymond) + 1, sits(p) != sits(Raymond) - 1, sits(p) != 8, sits(p) != 1)))
ForAll([c:chairs], Implies(c == sits(Olivia), And(c != sits(Raymond) + 1, c != sits(Raymond) - 1, c != 8, c != 1))) ::: Neither Peter nor Olivia sits next to Raymond
ForAll([c:chairs], Implies(c == sits(Peter), And(c != sits(Raymond) + 1, c != sits(Raymond) - 1, c != 8, c != 1)))
ForAll([c:chairs], Implies(c == sits(Kyoko), And(c != sits(Gabrielle) + 1, c != sits(Gabrielle) - 1, c != 8, c != 1))) ::: Neither Kyoko nor Lee sits next to Gabrielle
ForAll([c:chairs], Implies(c == sits(Lee), And(c != sits(Gabrielle) + 1, c != sits(Gabrielle) - 1, c != 8, c != 1)))
# Options
is_unsat(And(sits(Peter) == 2, sits(Gabrielle) == 3)) ::: (A)
is_unsat(And(sits(Peter) == 1, sits(Kyoko) == 3)) ::: (B)
is_unsat(And(sits(Francisco) == 5, sits(Kyoko) == 6, sits(Peter) == 7)) ::: (C)
is_unsat(And(sits(Gabrielle) == 5, sits(Olivia) == 6, sits(Kyoko) == 7)) ::: (D)
is_unsat(And(sits(Gabrielle) == 5, sits(Peter) == 6, sits(Lee) == 7)) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
If exactly one film buff sees the Kurosawa film, then which one of the following must be true?

# Options:
A) Viktor sees the Hitchcock film.
B) Ginnie sees the Fellini film.
C) Marcos sees the Fellini film.
D) Ian sees the Fellini film.
E) Reveka sees the Hitchcock film.","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
directors = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [directors])
# Constraints
ForAll([f:film_buffs], Exists([d:directors], sees(f) == d)) ::: Each film buff sees exactly one of the three films
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
Count([f:film_buffs], sees(f) == Kurosawa) == 1 ::: Exactly one film buff sees the Kurosawa film
# Options
is_valid(sees(Viktor) == Hitchcock) ::: (A)
is_valid(sees(Ginnie) == Fellini) ::: (B)
is_valid(sees(Marcos) == Fellini) ::: (C)
is_valid(sees(Ian) == Fellini) ::: (D)
is_valid(sees(Reveka) == Hitchcock) ::: (E)"
"# Context:
At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.

# Question:
If M and P are teammates in the boat race and J and R are teammates in the rescue exercise, which one of the following is a pair that must be teammates in the boat race?

# Options:
A) J and K
B) J and S
C) K and L
D) K and S
E) Q and R","# Declarations
lifeguards = EnumSort([J, K, L, M, P, Q, R, S])
events = EnumSort([boat_race, rescue_exercise])
teammates = Function([lifeguards, lifeguards, events] -> [bool])
# Constraints
ForAll([a:lifeguards, b:lifeguards], Implies(teammates(a, b, boat_race), Not(teammates(a, b, rescue_exercise)))) ::: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise
teammates(L, Q, boat_race) ::: L and Q are teammates in the boat race
teammates(K, L, rescue_exercise) ::: K and L are teammates in the rescue exercise
ForAll([e:events], Not(teammates(R, S, e))) ::: R and S are not teammates in either event
teammates(M, P, boat_race) ::: M and P are teammates in the boat race
teammates(J, R, rescue_exercise) ::: J and R are teammates in the rescue exercise
# Options
is_valid(teammates(J, K, boat_race)) ::: (A)
is_valid(teammates(J, S, boat_race)) ::: (B)
is_valid(teammates(K, L, boat_race)) ::: (C)
is_valid(teammates(K, S, boat_race)) ::: (D)
is_valid(teammates(Q, R, boat_race)) ::: (E)"
"# Context:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.

# Question:
If Jamie's performance is scheduled to be immediately before Lalitha's performance, Jamie's performance CANNOT be scheduled to be

# Options:
A) second
B) third
C) fourth
D) fifth
E) sixth","# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([singers] -> [performances])
# Constraints
scheduled(Jamie) == scheduled(Ken) + 1 ::: Jamie performs immediately after Ken
scheduled(Patrick) > scheduled(Maya) ::: Patrick performs at some time after Maya
Implies(scheduled(Lalitha) == 3, scheduled(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth
Implies(scheduled(Patrick) != 2, scheduled(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth
scheduled(Jamie) == scheduled(Lalitha) - 1 ::: Jamie's performance is scheduled to be immediately before Lalitha's performance
# Options
is_unsat(scheduled(Jamie) == 2) ::: (A)
is_unsat(scheduled(Jamie) == 3) ::: (B)
is_unsat(scheduled(Jamie) == 4) ::: (C)
is_unsat(scheduled(Jamie) == 5) ::: (D)
is_unsat(scheduled(Jamie) == 6) ::: (E)"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
If all three of the yellow articles of clothing are included in the two mannequins' outfits, which one of the following could be true?

# Options:
A) Mannequin 1 wears the navy jacket.
B) Mannequin 1 wears the yellow jacket.
C) Mannequin 1 wears the red skirt.
D) Mannequin 2 wears the red hat.
E) Mannequin 2 wears the red jacket.","# Declarations
mannequins = EnumSort([1, 2])
colors = EnumSort([navy, red, yellow])
articles = EnumSort([hat, jacket, skirt, tie])
wears = Function([mannequins, articles] -> [colors])
# Constraints
ForAll([m:mannequins], And(Exists([a:articles], wears(m, a) == navy), Exists([a:articles], wears(m, a) == red), Exists([a:articles], wears(m, a) == yellow))) ::: Neither mannequin wears all three colors
ForAll([m:mannequins], wears(m, hat) != wears(m, jacket)) ::: Each mannequin wears a hat in a different color from the jacket it wears
wears(2, skirt) == navy ::: Mannequin 2 wears the navy skirt
wears(1, tie) == red ::: Mannequin 1 wears the tie
ForAll([m:mannequins], Exists([a:articles], wears(m, a) == yellow)) ::: All three of the yellow articles of clothing are included in the two mannequins' outfits
# Options
is_valid(wears(1, jacket) == navy) ::: (A)
is_valid(wears(1, jacket) == yellow) ::: (B)
is_valid(wears(1, skirt) == red) ::: (C)
is_valid(wears(2, hat) == red) ::: (D)
is_valid(wears(2, jacket) == red) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
Which one of the following could be a complete and accurate list of the film buffs who do NOT see the Hitchcock film?

# Options:
A) Ginnie, Marcos
B) Ginnie Reveka
C) Ginnie, Ian, Reveka
D) Ginnie, Marcos, Yow
E) Ginnie, Viktor, Yow","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
directors = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [directors])
# Constraints
ForAll([f:film_buffs], Exists([d:directors], sees(f) == d)) ::: Each film buff sees exactly one of the three films
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
# Options
is_accurate_list([sees(Ginnie) != Hitchcock, sees(Marcos) != Hitchcock]) ::: (A)
is_accurate_list([sees(Ginnie) != Hitchcock, sees(Reveka) != Hitchcock]) ::: (B)
is_accurate_list([sees(Ginnie) != Hitchcock, sees(Ian) != Hitchcock, sees(Reveka) != Hitchcock]) ::: (C)
is_accurate_list([sees(Ginnie) != Hitchcock, sees(Marcos) != Hitchcock, sees(Yow) != Hitchcock]) ::: (D)
is_accurate_list([sees(Ginnie) != Hitchcock, sees(Viktor) != Hitchcock, sees(Yow) != Hitchcock]) ::: (E)"
"# Context:
On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.

# Question:
If exactly four bills are paid on Wednesday, then those four bills could be

# Options:
A) 1, 3, 4, and 6
B) 1, 3, 5, and 6
C) 2, 4, 5, and 7
D) 3, 4, 5, and 7
E) 3, 4, 6, and 7","# Declarations
bills = EnumSort([1, 2, 3, 4, 5, 6, 7])
days = EnumSort([Wednesday, Thursday])
paid_on = Function([bills] -> [days])
# Constraints
Or(Count([b:bills], paid_on(b) == Wednesday) == 3, Count([b:bills], paid_on(b) == Wednesday) == 4) ::: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday
paid_on(1) != paid_on(5) ::: Bill 1 cannot be paid on the same day as bill 5
paid_on(2) == Thursday ::: Bill 2 must be paid on Thursday
paid_on(4) == paid_on(7) ::: Bill 4 must be paid on the same day as bill 7
Implies(paid_on(6) == Wednesday, paid_on(7) == Thursday) ::: If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday
Count([b:bills], paid_on(b) == Wednesday) == 4 ::: exactly four bills are paid on Wednesday
# Options
is_accurate_list([paid_on(1) == Wednesday, paid_on(3) == Wednesday, paid_on(4) == Wednesday, paid_on(6) == Wednesday]) ::: (A)
is_accurate_list([paid_on(1) == Wednesday, paid_on(3) == Wednesday, paid_on(5) == Wednesday, paid_on(6) == Wednesday]) ::: (B)
is_accurate_list([paid_on(2) == Wednesday, paid_on(4) == Wednesday, paid_on(5) == Wednesday, paid_on(7) == Wednesday]) ::: (C)
is_accurate_list([paid_on(3) == Wednesday, paid_on(4) == Wednesday, paid_on(5) == Wednesday, paid_on(7) == Wednesday]) ::: (D)
is_accurate_list([paid_on(3) == Wednesday, paid_on(4) == Wednesday, paid_on(6) == Wednesday, paid_on(7) == Wednesday]) ::: (E)"
"# Context:
At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.

# Question:
Which one of the following is a pair of lifeguards who cannot be teammates in the rescue exercise but who could be teammates in the boat race?

# Options:
A) J and P
B) K and R
C) L and S
D) P and M
E) P and Q","# Declarations
lifeguards = EnumSort([J, K, L, M, P, Q, R, S])
boat_race = Function([lifeguards, lifeguards] -> [bool])
rescue_exercise = Function([lifeguards, lifeguards] -> [bool])
# Constraints
ForAll([a:lifeguards, b:lifeguards], Implies(boat_race(a, b), Not(rescue_exercise(a, b)))) ::: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise
boat_race(L, Q) ::: L and Q are teammates in the boat race
rescue_exercise(K, L) ::: K and L are teammates in the rescue exercise
ForAll([a:lifeguards], And(Not(boat_race(R, a)), Not(rescue_exercise(R, a)))) ::: R and S are not teammates in either event
ForAll([a:lifeguards], And(Not(boat_race(S, a)), Not(rescue_exercise(S, a)))) ::: R and S are not teammates in either event
# Options
is_valid(And(Not(rescue_exercise(J, P)), boat_race(J, P))) ::: (A)
is_valid(And(Not(rescue_exercise(K, R)), boat_race(K, R))) ::: (B)
is_valid(And(Not(rescue_exercise(L, S)), boat_race(L, S))) ::: (C)
is_valid(And(Not(rescue_exercise(P, M)), boat_race(P, M))) ::: (D)
is_valid(And(Not(rescue_exercise(P, Q)), boat_race(P, Q))) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
If the linguist learns three of the languages, then which one of the following must be true?

# Options:
A) The linguist learns Tigrinya.
B) The linguist learns Rundi.
C) The linguist learns Swahili.
D) The paleontologist learns Rundi.
E) The paleontologist learns Swahili.","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learns = Function([researchers, languages] -> [bool])
# Constraints
ForAll([r:researchers], And(Exists([l:languages], learns(r, l)), Count([l:languages], learns(r, l)) <= 3)) ::: Each researcher learns at least one and at most three languages
Count([r:researchers], learns(r, Rundi)) == 1 ::: Exactly one researcher learns Rundi
Count([r:researchers], learns(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learns(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learns(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learns(linguist, l), learns(paleontologist, l)), Not(learns(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learns(geologist, l), learns(historian, l))) ::: Any language learned by the geologist is learned by the historian
Count([l:languages], learns(linguist, l)) == 3 ::: The linguist learns three of the languages
# Options
is_valid(learns(linguist, Tigrinya)) ::: (A)
is_valid(learns(linguist, Rundi)) ::: (B)
is_valid(learns(linguist, Swahili)) ::: (C)
is_valid(learns(paleontologist, Rundi)) ::: (D)
is_valid(learns(paleontologist, Swahili)) ::: (E)"
"# Context:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.

# Question:
If Maya is scheduled for the second performance, which one of the following could be true?

# Options:
A) Jamie is scheduled for the sixth performance.
B) Ken is scheduled for the fourth performance.
C) Lalitha is scheduled for the third performance.
D) Norton is scheduled for the fifth performance.
E) Olive is scheduled for the fourth performance.","# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([singers] -> [performances])
# Constraints
scheduled(Jamie) == scheduled(Ken) + 1 ::: Jamie performs immediately after Ken
scheduled(Patrick) > scheduled(Maya) ::: Patrick performs at some time after Maya
Implies(scheduled(Lalitha) == 3, scheduled(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth
Implies(scheduled(Patrick) != 2, scheduled(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth
scheduled(Maya) == 2 ::: Maya is scheduled for the second performance
# Options
is_valid(scheduled(Jamie) == 6) ::: (A)
is_valid(scheduled(Ken) == 4) ::: (B)
is_valid(scheduled(Lalitha) == 3) ::: (C)
is_valid(scheduled(Norton) == 5) ::: (D)
is_valid(scheduled(Olive) == 4) ::: (E)"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
If mannequin 2 wears the red jacket, then mannequin 1 must wear the

# Options:
A) navy hat
B) red hat
C) yellow hat
D) red skirt
E) yellow skirt","# Declarations
mannequins = EnumSort([1, 2])
colors = EnumSort([navy, red, yellow])
articles = EnumSort([hat, jacket, skirt, tie])
wears = Function([mannequins, articles] -> [colors])
# Constraints
ForAll([m:mannequins], And(wears(m, hat) != wears(m, jacket), wears(m, hat) != wears(m, skirt), wears(m, jacket) != wears(m, skirt))) ::: Each mannequin wears a hat in a different color from the jacket it wears, and a different color from the skirt it wears
wears(2, skirt) == navy ::: Mannequin 2 wears the navy skirt
wears(1, tie) == red ::: Mannequin 1 wears the tie
ForAll([m:mannequins], Not(And(wears(m, hat) != wears(m, jacket), wears(m, hat) != wears(m, skirt), wears(m, jacket) != wears(m, skirt)))) ::: Neither mannequin wears all three colors
wears(2, jacket) == red ::: Mannequin 2 wears the red jacket
# Options
is_valid(wears(1, hat) == navy) ::: (A)
is_valid(wears(1, hat) == red) ::: (B)
is_valid(wears(1, hat) == yellow) ::: (C)
is_valid(wears(1, skirt) == red) ::: (D)
is_valid(wears(1, skirt) == yellow) ::: (E)"
"# Context:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.

# Question:
If Norton is scheduled for the fifth performance, which one of the following could be true?

# Options:
A) Jamie is scheduled for the sixth performance.
B) Ken is scheduled for the second performance.
C) Lalitha is scheduled for the fourth performance.
D) Maya is scheduled for the third performance.
E) Olive is scheduled for the first performance.","# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([singers] -> [performances])
# Constraints
scheduled(Jamie) == scheduled(Ken) + 1 ::: Jamie performs immediately after Ken
scheduled(Patrick) > scheduled(Maya) ::: Patrick performs at some time after Maya
Implies(scheduled(Lalitha) == 3, scheduled(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth
Implies(scheduled(Patrick) != 2, scheduled(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth
scheduled(Norton) == 5 ::: Norton is scheduled for the fifth performance
# Options
is_valid(scheduled(Jamie) == 6) ::: (A)
is_valid(scheduled(Ken) == 2) ::: (B)
is_valid(scheduled(Lalitha) == 4) ::: (C)
is_valid(scheduled(Maya) == 3) ::: (D)
is_valid(scheduled(Olive) == 1) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
Each of the following must be false EXCEPT:

# Options:
A) Reveka is the only film buff to see the Fellini film.
B) Reveka is the only film buff to see the Hitchcock film.
C) Yow is the only film buff to see the Kurosawa film.
D) Exactly two film buffs see the Kurosawa film.
E) Exactly three film buffs see the Hitchcock film.","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
directors = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [directors])
# Constraints
ForAll([f:film_buffs], Exists([d:directors], sees(f) == d)) ::: Each film buff sees exactly one of the three films
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
# Options
is_unsat(ForAll([f:film_buffs], Implies(f != Reveka, sees(f) != Fellini))) ::: (A) Reveka is the only film buff to see the Fellini film
is_unsat(ForAll([f:film_buffs], Implies(f != Reveka, sees(f) != Hitchcock))) ::: (B) Reveka is the only film buff to see the Hitchcock film
is_unsat(ForAll([f:film_buffs], Implies(f != Yow, sees(f) != Kurosawa))) ::: (C) Yow is the only film buff to see the Kurosawa film
is_unsat(Count([f:film_buffs], sees(f) == Kurosawa) == 2) ::: (D) Exactly two film buffs see the Kurosawa film
is_unsat(Count([f:film_buffs], sees(f) == Hitchcock) == 3) ::: (E) Exactly three film buffs see the Hitchcock film"
"# Context:
Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.

# Question:
Which one of the following could be an accurate list of the activities participated in by Nguyen, Olson, Pike, Tyner, and Valdez, respectively?

# Options:
A) movie, soccer game, soccer game, restaurant, movie
B) movie, restaurant, soccer game, soccer game, movie
C) soccer game, restaurant, movie, soccer game, movie
D) soccer game, restaurant, movie, soccer game, restaurant
E) soccer game, restaurant, movie, soccer game, soccer game","# Declarations
persons = EnumSort([Nguyen, Olson, Pike, Tyner, Valdez])
activities = EnumSort([movie, soccer_game, restaurant])
participates = Function([persons] -> [activities])
# Constraints
ForAll([p:persons], Exists([a:activities], participates(p) == a)) ::: Each person participates in exactly one activity
participates(Nguyen) != participates(Olson) ::: Nguyen and Olson do not participate in the same activity as each other
participates(Nguyen) != participates(Pike) ::: Nguyen does not participate in the same activity as Pike
participates(Olson) != participates(Pike) ::: Olson does not participate in the same activity as Pike
Count([p:persons], participates(p) == soccer_game) == 2 ::: Exactly two persons go to a soccer game
participates(Tyner) != participates(Pike) ::: Tyner and Pike do not participate in the same activity as each other
Implies(Or(participates(Nguyen) == movie, participates(Valdez) == movie), And(participates(Nguyen) == movie, participates(Valdez) == movie)) ::: If Nguyen or Valdez goes to a movie, they both go to a movie
# Options
is_accurate_list([participates(Nguyen) == movie, participates(Olson) == soccer_game, participates(Pike) == soccer_game, participates(Tyner) == restaurant, participates(Valdez) == movie]) ::: (A)
is_accurate_list([participates(Nguyen) == movie, participates(Olson) == restaurant, participates(Pike) == soccer_game, participates(Tyner) == soccer_game, participates(Valdez) == movie]) ::: (B)
is_accurate_list([participates(Nguyen) == soccer_game, participates(Olson) == restaurant, participates(Pike) == movie, participates(Tyner) == soccer_game, participates(Valdez) == movie]) ::: (C)
is_accurate_list([participates(Nguyen) == soccer_game, participates(Olson) == restaurant, participates(Pike) == movie, participates(Tyner) == soccer_game, participates(Valdez) == restaurant]) ::: (D)
is_accurate_list([participates(Nguyen) == soccer_game, participates(Olson) == restaurant, participates(Pike) == movie, participates(Tyner) == soccer_game, participates(Valdez) == soccer_game]) ::: (E)"
"# Context:
Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.

# Question:
Which one of the following could be the list of people sitting in chairs 5 through 8, respectively?

# Options:
A) Francisco, Olivia, Gabrielle, Peter
B) Francisco, Gabrielle, Peter, Lee
C) Olivia, Gabrielle, Peter, Kyoko
D) Gabrielle, Lee, Olivia, Kyoko
E) Lee, Olivia, Francisco, Kyoko","# Declarations
people = EnumSort([Francisco, Gabrielle, Kyoko, Lee, Olivia, Peter, Raymond, Simone])
chairs = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
seated = Function([chairs] -> [people])
# Constraints
seated(1) == Simone ::: Simone sits in chair 1
seated(4) == Raymond ::: Raymond sits in chair 4
ForAll([c:chairs], Exists([p:people], seated(c) == p)) ::: Each person will sit in a different one of the eight chairs
ForAll([c:chairs], Implies(c == 1, And(seated(c) != seated(2), seated(c) != seated(8)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(c == 2, And(seated(c) != seated(1), seated(c) != seated(3)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(c == 3, And(seated(c) != seated(2), seated(c) != seated(4)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(c == 5, And(seated(c) != seated(6), seated(c) != seated(4)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(c == 6, And(seated(c) != seated(5), seated(c) != seated(7)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(c == 7, And(seated(c) != seated(6), seated(c) != seated(8)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(c == 8, And(seated(c) != seated(7), seated(c) != seated(1)))) ::: No person sits next to her or his spouse
ForAll([c:chairs], Implies(seated(c) == Peter, And(seated(c) != seated(3), seated(c) != seated(5)))) ::: Neither Peter nor Olivia sits next to Raymond
ForAll([c:chairs], Implies(seated(c) == Olivia, And(seated(c) != seated(3), seated(c) != seated(5)))) ::: Neither Peter nor Olivia sits next to Raymond
ForAll([c:chairs], Implies(seated(c) == Kyoko, And(seated(c) != seated(2), seated(c) != seated(8)))) ::: Neither Kyoko nor Lee sits next to Gabrielle
ForAll([c:chairs], Implies(seated(c) == Lee, And(seated(c) != seated(2), seated(c) != seated(8)))) ::: Neither Kyoko nor Lee sits next to Gabrielle
# Options
is_accurate_list([seated(5) == Francisco, seated(6) == Olivia, seated(7) == Gabrielle, seated(8) == Peter]) ::: (A)
is_accurate_list([seated(5) == Francisco, seated(6) == Gabrielle, seated(7) == Peter, seated(8) == Lee]) ::: (B)
is_accurate_list([seated(5) == Olivia, seated(6) == Gabrielle, seated(7) == Peter, seated(8) == Kyoko]) ::: (C)
is_accurate_list([seated(5) == Gabrielle, seated(6) == Lee, seated(7) == Olivia, seated(8) == Kyoko]) ::: (D)
is_accurate_list([seated(5) == Lee, seated(6) == Olivia, seated(7) == Francisco, seated(8) == Kyoko]) ::: (E)"
"# Context:
Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.

# Question:
If one of the members of the council votes against exactly the same bills as does another member of the council, then which one of the following statements must be true?

# Options:
A) Fu votes for the tax bill.
B) Gianola votes for the recreation bill.
C) Gianola votes against the school bill.
D) Gianola votes for exactly one bill
E) Herstein votes for exactly one bill.","# Declarations
council_members = EnumSort([Fu, Gianola, Herstein])
bills = EnumSort([recreation_bill, school_bill, tax_bill])
votes = Function([council_members, bills] -> [bool])
# Constraints
ForAll([m:council_members], Or(Exists([b:bills], votes(m, b)), Exists([b:bills], Not(votes(m, b))))) ::: Each member of the council votes for at least one of the bills and against at least one of the bills
Count([m:council_members], votes(m, recreation_bill)) == 2 ::: Exactly two members of the council vote for the recreation bill
Count([m:council_members], votes(m, school_bill)) == 1 ::: Exactly one member of the council votes for the school bill
Count([m:council_members], votes(m, tax_bill)) == 1 ::: Exactly one member of the council votes for the tax bill
votes(Fu, recreation_bill) ::: Fu votes for the recreation bill
Not(votes(Fu, school_bill)) ::: Fu votes against the school bill
Not(votes(Gianola, recreation_bill)) ::: Gianola votes against the recreation bill
Not(votes(Herstein, tax_bill)) ::: Herstein votes against the tax bill
Exists([m1:council_members, m2:council_members], And(m1 != m2, ForAll([b:bills], votes(m1, b) == votes(m2, b)))) ::: If one of the members of the council votes against exactly the same bills as does another member of the council
# Options
is_valid(votes(Fu, tax_bill)) ::: (A)
is_valid(votes(Gianola, recreation_bill)) ::: (B)
is_valid(Not(votes(Gianola, school_bill))) ::: (C)
is_valid(Count([b:bills], votes(Gianola, b)) == 1) ::: (D)
is_valid(Count([b:bills], votes(Herstein, b)) == 1) ::: (E)"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
If all four of the red articles of clothing are included in the two mannequins' outfits, which one of the following must be true?

# Options:
A) Mannequin 1 wears the red hat.
B) Mannequin 1 wears the yellow jacket.
C) Mannequin 2 wears the navy jacket.
D) Mannequin 1 wears no navy articles of clothing.
E) Mannequin 2 wears no yellow articles of clothing.","# Declarations
mannequins = EnumSort([1, 2])
colors = EnumSort([navy, red, yellow])
articles = EnumSort([hat, jacket, skirt, tie])
outfit = Function([mannequins, articles] -> [colors])
# Constraints
ForAll([m:mannequins], And(outfit(m, hat) != outfit(m, jacket), outfit(m, jacket) != outfit(m, skirt), outfit(m, hat) != outfit(m, skirt))) ::: Each mannequin wears a hat in a different color from the jacket it wears, and the jacket in a different color from the skirt
outfit(2, skirt) == navy ::: Mannequin 2 wears the navy skirt
outfit(1, tie) == red ::: Mannequin 1 wears the tie
ForAll([m:mannequins], Not(And(outfit(m, hat) == navy, outfit(m, jacket) == red, outfit(m, skirt) == yellow))) ::: Neither mannequin wears all three colors
Count([m:mannequins, a:articles], outfit(m, a) == red) == 4 ::: All four of the red articles of clothing are included in the two mannequins' outfits
# Options
is_valid(outfit(1, hat) == red) ::: (A)
is_valid(outfit(1, jacket) == yellow) ::: (B)
is_valid(outfit(2, jacket) == navy) ::: (C)
is_valid(ForAll([a:articles], outfit(1, a) != navy)) ::: (D)
is_valid(ForAll([a:articles], outfit(2, a) != yellow)) ::: (E)"
"# Context:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.

# Question:
If Lalitha is scheduled for the third performance, which one of the following must be scheduled for the sixth performance?

# Options:
A) Jamie
B) Ken
C) Norton
D) Olive
E) Patrick","# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([singers] -> [performances])
# Constraints
scheduled(Jamie) == scheduled(Ken) + 1 ::: Jamie performs immediately after Ken
scheduled(Patrick) > scheduled(Maya) ::: Patrick performs at some time after Maya
Implies(scheduled(Lalitha) == 3, scheduled(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth
Implies(scheduled(Patrick) != 2, scheduled(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth
scheduled(Lalitha) == 3 ::: Lalitha is scheduled for the third performance
# Options
is_valid(scheduled(Jamie) == 6) ::: (A)
is_valid(scheduled(Ken) == 6) ::: (B)
is_valid(scheduled(Norton) == 6) ::: (C)
is_valid(scheduled(Olive) == 6) ::: (D)
is_valid(scheduled(Patrick) == 6) ::: (E)"
"# Context:
A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.

# Question:
The order in which the awards are presented is completely determined if which one of the following is true?

# Options:
A) The French award is presented immediately before the German award is presented, and the Korean award is presented immediately before the Latin award is presented.
B) The French award is presented immediately before the Hebrew award is presented, and the Hebrew award is presented immediately before the Korean award is presented.
C) The French award is presented immediately before the Latin award is presented, and the Korean award is presented immediately before the Japanese award is presented.
D) The German award is presented immediately before the French award is presented, and the Latin award is presented immediately before the Japanese award is presented.
E) The German award is presented immediately before the Korean award is presented, and the Hebrew award is presented immediately before the French award is presented.","# Declarations
awards = EnumSort([French, German, Hebrew, Japanese, Korean, Latin, Swahili])
order = Function([awards] -> [int])
# Constraints
order(German) != 1 ::: The German award is not presented first
Exists([i:int], And(i < order(Korean), i == order(Hebrew))) ::: The Hebrew award is presented at some time before the Korean award is presented
Exists([i:int], And(i < order(Japanese), i == order(Latin))) ::: The Latin award is presented at some time before the Japanese award is presented
Or(order(French) == order(Hebrew) - 1, order(French) == order(Hebrew) + 1) ::: The French award is presented either immediately before or immediately after the Hebrew award is presented
Or(order(Korean) == order(Latin) - 1, order(Korean) == order(Latin) + 1) ::: The Korean award is presented either immediately before or immediately after the Latin award is presented
# Options
is_valid(And(order(French) == order(German) - 1, order(Korean) == order(Latin) - 1)) ::: (A)
is_valid(And(order(French) == order(Hebrew) - 1, order(Hebrew) == order(Korean) - 1)) ::: (B)
is_valid(And(order(French) == order(Latin) - 1, order(Korean) == order(Japanese) - 1)) ::: (C)
is_valid(And(order(German) == order(French) - 1, order(Latin) == order(Japanese) - 1)) ::: (D)
is_valid(And(order(German) == order(Korean) - 1, order(Hebrew) == order(French) - 1)) ::: (E)"
"# Context:
Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.

# Question:
Which one of the following must be true?

# Options:
A) Zalamea is assigned fewer than three of the tourists.
B) Xerxes is assigned fewer than two of the tourists.
C) Yossarian is assigned exactly two of the tourists.
D) Valois is assigned exactly one of the tourists.
E) Zalamea is assigned exactly one of the tourists.","# Declarations
tourists = EnumSort([Harry, Irene, Klaus, Laura, Michael, Norma])
guides = EnumSort([Valois, Xerxes, Yossarian, Zalamea])
languages = EnumSort([French, Turkish, Spanish, Russian])
assigned = Function([tourists] -> [guides])
speaks = Function([tourists] -> [languages])
# Constraints
ForAll([g:guides], Exists([t:tourists], assigned(t) == g)) ::: at least one tourist assigned to each guide
ForAll([t:tourists], Exists([g:guides], assigned(t) == g)) ::: each tourist is assigned to exactly one guide
ForAll([t:tourists], Exists([l:languages], speaks(t) == l)) ::: each tourist speaks exactly one language
ForAll([t:tourists], Implies(assigned(t) == Valois, speaks(t) == French)) ::: Valois speaks only French
ForAll([t:tourists], Implies(assigned(t) == Xerxes, Or(speaks(t) == Turkish, speaks(t) == Spanish))) ::: Xerxes speaks only Turkish and Spanish
ForAll([t:tourists], Implies(assigned(t) == Yossarian, Or(speaks(t) == French, speaks(t) == Turkish))) ::: Yossarian speaks only French and Turkish
ForAll([t:tourists], Implies(assigned(t) == Zalamea, Or(speaks(t) == Spanish, speaks(t) == Russian))) ::: Zalamea speaks only Spanish and Russian
Or(assigned(Harry) == Yossarian, assigned(Irene) == Yossarian) ::: at least Harry and Irene are assigned to Yossarian
assigned(Laura) == Zalamea ::: at least Laura is assigned to Zalamea
Implies(assigned(Klaus) == Xerxes, speaks(Michael) == French) ::: if Klaus is assigned to Xerxes, then Michael speaks French
# Options
is_valid(Count([t:tourists], assigned(t) == Zalamea) < 3) ::: (A)
is_valid(Count([t:tourists], assigned(t) == Xerxes) < 2) ::: (B)
is_valid(Count([t:tourists], assigned(t) == Yossarian) == 2) ::: (C)
is_valid(Count([t:tourists], assigned(t) == Valois) == 1) ::: (D)
is_valid(Count([t:tourists], assigned(t) == Zalamea) == 1) ::: (E)"
"# Context:
During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.

# Question:
If Hall views the site on the day after the day Knight views the site and if Fennelly views the site on the day after the day Lopez views the site, then Jones must view the site on day

# Options:
A) 1
B) 2
C) 3
D) 4
E) 5","# Declarations
investors = EnumSort([Fennelly, Gupta, Hall, Jones, Knight, Lopez, Moss])
days = EnumSort([1, 2, 3, 4, 5, 6, 7])
views = Function([investors] -> [days])
# Constraints
ForAll([d:days], Exists([i:investors], views(i) == d)) ::: Each day exactly one investor will view the site
ForAll([i:investors], Exists([d:days], views(i) == d)) ::: Each investor views the site exactly once
Or(views(Fennelly) == 3, views(Fennelly) == 5) ::: Fennelly views the site on day 3 or else day 5
And(views(Lopez) != 4, views(Lopez) != 6) ::: Lopez views the site on neither day 4 nor day 6
Implies(views(Jones) == 1, views(Hall) == 2) ::: If Jones views the site on day 1, Hall views the site on day 2
Implies(views(Knight) == 4, views(Lopez) == 5) ::: If Knight views the site on day 4, Lopez views the site on day 5
Exists([d:days], And(views(Hall) == d + 1, views(Gupta) == d + 2)) ::: Gupta views the site on the day after the day on which Hall views the site
views(Hall) == views(Knight) + 1 ::: Hall views the site on the day after the day Knight views the site
views(Fennelly) == views(Lopez) + 1 ::: Fennelly views the site on the day after the day Lopez views the site
# Options
is_valid(views(Jones) == 1) ::: (A)
is_valid(views(Jones) == 2) ::: (B)
is_valid(views(Jones) == 3) ::: (C)
is_valid(views(Jones) == 4) ::: (D)
is_valid(views(Jones) == 5) ::: (E)"
"# Context:
Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.

# Question:
If mannequin 1 wears the navy jacket, which one of the following could be true?

# Options:
A) Mannequin 1 wears the yellow hat.
B) Mannequin 1 wears the yellow skirt.
C) Mannequin 2 wears the red hat.
D) Mannequin 2 wears the yellow hat.
E) Mannequin 2 wears the yellow jacket.","# Declarations
mannequins = EnumSort([1, 2])
colors = EnumSort([navy, red, yellow])
articles = EnumSort([hat, jacket, skirt, tie])
outfit = Function([mannequins, articles] -> [colors])
# Constraints
ForAll([m:mannequins], And(outfit(m, hat) != outfit(m, jacket), outfit(m, hat) != outfit(m, skirt), outfit(m, jacket) != outfit(m, skirt))) ::: Each mannequin wears a hat in a different color from the jacket it wears and a different color from the skirt it wears
ForAll([m:mannequins], outfit(m, tie) == red) ::: Mannequin 1 wears the tie, which is red
outfit(2, skirt) == navy ::: Mannequin 2 wears the navy skirt
outfit(1, jacket) == navy ::: Mannequin 1 wears the navy jacket
ForAll([m:mannequins], Not(And(outfit(m, hat) == navy, outfit(m, jacket) == red, outfit(m, skirt) == yellow))) ::: Neither mannequin wears all three colors
# Options
is_valid(outfit(1, hat) == yellow) ::: (A)
is_valid(outfit(1, skirt) == yellow) ::: (B)
is_valid(outfit(2, hat) == red) ::: (C)
is_valid(outfit(2, hat) == yellow) ::: (D)
is_valid(outfit(2, jacket) == yellow) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
Which one of the following could be true?

# Options:
A) The linguist learns three languages—Rundi, Swahili, and Tigrinya.
B) The linguist learns three languages—Swahili, Tigrinya, and Yoruba.
C) The historian learns three languages—Rundi, Swahili, and Tigrinya.
D) The historian learns three languages—Swahili, Tigrinya, and Yoruba.
E) The paleontologist learns three languages—Rundi, Swahili, and Tigrinya.","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learns = Function([researchers, languages] -> [bool])
# Constraints
Count([r:researchers], learns(r, Rundi)) == 1 ::: Exactly one researcher learns Rundi
Count([r:researchers], learns(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learns(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learns(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learns(linguist, l), learns(paleontologist, l)), Not(learns(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learns(geologist, l), learns(historian, l))) ::: Any language learned by the geologist is learned by the historian
ForAll([r:researchers], And(Count([l:languages], learns(r, l)) >= 1, Count([l:languages], learns(r, l)) <= 3)) ::: Each researcher learns at least one and at most three languages
# Options
is_sat(And(learns(linguist, Rundi), learns(linguist, Swahili), learns(linguist, Tigrinya))) ::: (A)
is_sat(And(learns(linguist, Swahili), learns(linguist, Tigrinya), learns(linguist, Yoruba))) ::: (B)
is_sat(And(learns(historian, Rundi), learns(historian, Swahili), learns(historian, Tigrinya))) ::: (C)
is_sat(And(learns(historian, Swahili), learns(historian, Tigrinya), learns(historian, Yoruba))) ::: (D)
is_sat(And(learns(paleontologist, Rundi), learns(paleontologist, Swahili), learns(paleontologist, Tigrinya))) ::: (E)"
"# Context:
Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.

# Question:
If Gwen and Henry are not assigned to consecutively numbered benches, which one of the following must be true?

# Options:
A) Victor is assigned to bench 2.
B) Victor is assigned to bench 3.
C) Wanda is assigned to bench 1.
D) Wanda is assigned to bench 3.
E) Wanda is assigned to bench 4.","# Declarations
students = EnumSort([Frank, Gwen, Henry, Joan, Victor, Wanda, Xavier, Yvette])
benches = EnumSort([1, 2, 3, 4])
assigned = Function([students] -> [benches])
# Constraints
ForAll([b:benches], Count([s:students], assigned(s) == b) == 2) ::: exactly two students are assigned to each bench
ForAll([b:benches], Exists([s:students], Or(s == Frank, s == Gwen, s == Henry, s == Joan, assigned(s) == b))) ::: exactly one major is assigned to each bench
And(assigned(Frank) == assigned(Victor), assigned(Frank) == assigned(Joan) - 1) ::: Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench, and Frank is assigned to the same bench as Victor
assigned(Gwen) != assigned(Wanda) ::: Gwen is not assigned to the same bench as Wanda
ForAll([b:benches], Implies(And(assigned(Gwen) == b, assigned(Henry) == b + 1), False)) ::: Gwen and Henry are not assigned to consecutively numbered benches
# Options
is_valid(assigned(Victor) == 2) ::: (A)
is_valid(assigned(Victor) == 3) ::: (B)
is_valid(assigned(Wanda) == 1) ::: (C)
is_valid(assigned(Wanda) == 3) ::: (D)
is_valid(assigned(Wanda) == 4) ::: (E)"
"# Context:
Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.

# Question:
Which one of the following could be an accurate matching of film buffs to films?

# Options:
A) Ginnie: the Hitchcock film; Ian: the Kurosawa film; Marcos: the Hitchcock film
B) Ginnie: the Kurosawa film; Ian: the Fellini film; Viktor: the Fellini film
C) Ian: the Hitchcock film; Reveka: the Kurosawa film; Viktor: the Fellini film
D) Marcos: the Kurosawa film; Reveka: the Kurosawa film; Viktor: the Kurosawa film
E) Marcos: the Hitchcock film; Reveka: the Hitchcock film; Yow: the Hitchcock film","# Declarations
film_buffs = EnumSort([Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, Yow])
films = EnumSort([Fellini, Hitchcock, Kurosawa])
sees = Function([film_buffs] -> [films])
# Constraints
Count([f:film_buffs], sees(f) == Hitchcock) == 2 * Count([f:film_buffs], sees(f) == Fellini) ::: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film
sees(Ginnie) != sees(Reveka) ::: Ginnie and Reveka do not see the same film as each other
sees(Ian) != sees(Marcos) ::: Ian and Marcos do not see the same film as each other
sees(Viktor) == sees(Yow) ::: Viktor and Yow see the same film as each other
sees(Lianna) == Hitchcock ::: Lianna sees the Hitchcock film
Or(sees(Ginnie) == Fellini, sees(Ginnie) == Kurosawa) ::: Ginnie sees either the Fellini film or the Kurosawa film
# Options
is_accurate_list([sees(Ginnie) == Hitchcock, sees(Ian) == Kurosawa, sees(Marcos) == Hitchcock]) ::: (A)
is_accurate_list([sees(Ginnie) == Kurosawa, sees(Ian) == Fellini, sees(Viktor) == Fellini]) ::: (B)
is_accurate_list([sees(Ian) == Hitchcock, sees(Reveka) == Kurosawa, sees(Viktor) == Fellini]) ::: (C)
is_accurate_list([sees(Marcos) == Kurosawa, sees(Reveka) == Kurosawa, sees(Viktor) == Kurosawa]) ::: (D)
is_accurate_list([sees(Marcos) == Hitchcock, sees(Reveka) == Hitchcock, sees(Yow) == Hitchcock]) ::: (E)"
"# Context:
Five candidates for mayor—Q, R, S, T, and U—will each speak exactly once at each of three town meetings—meetings 1, 2, and 3. At each meeting, each candidate will speak in one of five consecutive time slots. No two candidates will speak in the same time slot as each other at any meeting. The order in which the candidates will speak will meet the following conditions: Each candidate must speak either first or second at at least one of the meetings. Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings. No candidate can speak fourth at more than one of the meetings.

# Question:
If the order in which the candidates speak at meeting 1 is R, U, S, T, Q, and the order in which they speak at meeting 2 is Q, R, U, S, T, which one of the following could be true of meeting 3?

# Options:
A) Q speaks first.
B) R speaks third.
C) S speaks first.
D) T speaks second.
E) U speaks fifth.","# Declarations
candidates = EnumSort([Q, R, S, T, U])
meetings = EnumSort([meeting1, meeting2, meeting3])
time_slots = EnumSort([first, second, third, fourth, fifth])
speaks_at = Function([candidates, meetings] -> [time_slots])
# Constraints
ForAll([c:candidates], ForAll([m:meetings], Exists([m1:meetings], And(m1 != m, Or(speaks_at(c, m1) == first, speaks_at(c, m1) == second))))) ::: Each candidate must speak either first or second at at least one of the meetings
ForAll([c:candidates], Implies(Exists([m:meetings], speaks_at(c, m) == fifth), Exists([m1:meetings], And(m1 != m, speaks_at(c, m1) == first)))) ::: Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings
ForAll([c:candidates], Count([m:meetings], speaks_at(c, m) == fourth) <= 1) ::: No candidate can speak fourth at more than one of the meetings
ForAll([m:meetings], ForAll([c1:candidates, c2:candidates], Implies(c1 != c2, speaks_at(c1, m) != speaks_at(c2, m)))) ::: No two candidates will speak in the same time slot as each other at any meeting
speaks_at(R, meeting1) == first ::: the order in which the candidates speak at meeting 1 is R, U, S, T, Q
speaks_at(U, meeting1) == second ::: the order in which the candidates speak at meeting 1 is R, U, S, T, Q
speaks_at(S, meeting1) == third ::: the order in which the candidates speak at meeting 1 is R, U, S, T, Q
speaks_at(T, meeting1) == fourth ::: the order in which the candidates speak at meeting 1 is R, U, S, T, Q
speaks_at(Q, meeting1) == fifth ::: the order in which the candidates speak at meeting 1 is R, U, S, T, Q
speaks_at(Q, meeting2) == first ::: the order in which they speak at meeting 2 is Q, R, U, S, T
speaks_at(R, meeting2) == second ::: the order in which they speak at meeting 2 is Q, R, U, S, T
speaks_at(U, meeting2) == third ::: the order in which they speak at meeting 2 is Q, R, U, S, T
speaks_at(S, meeting2) == fourth ::: the order in which they speak at meeting 2 is Q, R, U, S, T
speaks_at(T, meeting2) == fifth ::: the order in which they speak at meeting 2 is Q, R, U, S, T
# Options
is_valid(speaks_at(Q, meeting3) == first) ::: (A)
is_valid(speaks_at(R, meeting3) == third) ::: (B)
is_valid(speaks_at(S, meeting3) == first) ::: (C)
is_valid(speaks_at(T, meeting3) == second) ::: (D)
is_valid(speaks_at(U, meeting3) == fifth) ::: (E)"
"# Context:
Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.

# Question:
Which one of the following is an acceptable schedule for the evening's performers, from first through seventh?

# Options:
A) Ken, Jamie, Maya, Lalitha, Patrick, Norton, Olive
B) Lalitha, Patrick, Norton, Olive, Maya, Ken, Jamie
C) Norton, Olive, Ken, Jamie, Maya, Patrick, Lalitha
D) Olive, Maya, Ken, Lalitha, Patrick, Norton, Jamie
E) Olive, Maya, Lalitha, Norton, Patrick, Ken, Jamie","# Declarations
singers = EnumSort([Jamie, Ken, Lalitha, Maya, Norton, Olive, Patrick])
performances = EnumSort([1, 2, 3, 4, 5, 6, 7])
perform = Function([singers] -> [performances])
# Constraints
perform(Jamie) == perform(Ken) + 1 ::: Jamie performs immediately after Ken
perform(Patrick) > perform(Maya) ::: Patrick performs at some time after Maya
Implies(perform(Lalitha) == 3, perform(Norton) == 5) ::: Lalitha performs third only if Norton performs fifth
Implies(perform(Patrick) != 2, perform(Patrick) == 5) ::: If Patrick does not perform second, he performs fifth
ForAll([s:singers], Exists([p:performances], perform(s) == p)) ::: Each singer performs exactly once
ForAll([p:performances], Exists([s:singers], perform(s) == p)) ::: Each performance slot is filled
# Options
is_accurate_list([perform(Ken) == 1, perform(Jamie) == 2, perform(Maya) == 3, perform(Lalitha) == 4, perform(Patrick) == 5, perform(Norton) == 6, perform(Olive) == 7]) ::: (A)
is_accurate_list([perform(Lalitha) == 1, perform(Patrick) == 2, perform(Norton) == 3, perform(Olive) == 4, perform(Maya) == 5, perform(Ken) == 6, perform(Jamie) == 7]) ::: (B)
is_accurate_list([perform(Norton) == 1, perform(Olive) == 2, perform(Ken) == 3, perform(Jamie) == 4, perform(Maya) == 5, perform(Patrick) == 6, perform(Lalitha) == 7]) ::: (C)
is_accurate_list([perform(Olive) == 1, perform(Maya) == 2, perform(Ken) == 3, perform(Lalitha) == 4, perform(Patrick) == 5, perform(Norton) == 6, perform(Jamie) == 7]) ::: (D)
is_accurate_list([perform(Olive) == 1, perform(Maya) == 2, perform(Lalitha) == 3, perform(Norton) == 4, perform(Patrick) == 5, perform(Ken) == 6, perform(Jamie) == 7]) ::: (E)"
"# Context:
Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.

# Question:
If Gianola votes for exactly two of the three bills, which one of the following statements must be true?

# Options:
A) Fu votes for the tax bill.
B) Gianola votes for the recreation bill.
C) Gianola votes for the school bill.
D) Gianola votes against the tax bill.
E) Herstein votes for the school bill.","# Declarations
council_members = EnumSort([Fu, Gianola, Herstein])
bills = EnumSort([recreation_bill, school_bill, tax_bill])
votes = Function([council_members, bills] -> [bool])
# Constraints
ForAll([m:council_members], Or(Exists([b:bills], votes(m, b)), Exists([b:bills], Not(votes(m, b))))) ::: Each member of the council votes for at least one of the bills and against at least one of the bills
Count([m:council_members], votes(m, recreation_bill)) == 2 ::: Exactly two members of the council vote for the recreation bill
Count([m:council_members], votes(m, school_bill)) == 1 ::: Exactly one member of the council votes for the school bill
Count([m:council_members], votes(m, tax_bill)) == 1 ::: Exactly one member of the council votes for the tax bill
votes(Fu, recreation_bill) ::: Fu votes for the recreation bill
Not(votes(Fu, school_bill)) ::: Fu votes against the school bill
Not(votes(Gianola, recreation_bill)) ::: Gianola votes against the recreation bill
Not(votes(Herstein, tax_bill)) ::: Herstein votes against the tax bill
Count([b:bills], votes(Gianola, b)) == 2 ::: Gianola votes for exactly two of the three bills
# Options
is_valid(votes(Fu, tax_bill)) ::: (A)
is_valid(votes(Gianola, recreation_bill)) ::: (B)
is_valid(votes(Gianola, school_bill)) ::: (C)
is_valid(Not(votes(Gianola, tax_bill))) ::: (D)
is_valid(votes(Herstein, school_bill)) ::: (E)"
"# Context:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.

# Question:
If Oliver is the highest-ranking tennis player, which one of the following must be true?

# Options:
A) Oliver and Maricella play the same sport as each other.
B) Paulo and Lina play the same sport as each other.
C) Paulo and Oliver play the same sport as each other.
D) Kim and Lina do not play the same sport as each other.
E) Kim and Paulo do not play the same sport as each other.","# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people] -> [sports])
rank = Function([people, people] -> [bool])
# Constraints
plays(Oliver) == tennis ::: Oliver plays tennis
plays(Lina) == golf ::: Lina plays golf
ForAll([p:people], Implies(plays(p) == golf, rank(Lina, p))) ::: There is no golf player ranked higher than Lina
Implies(plays(Maricella) == golf, And(plays(Paulo) == golf, plays(Shigeru) == golf, rank(Maricella, Paulo), rank(Paulo, Shigeru))) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
Implies(plays(Maricella) == tennis, And(plays(Shigeru) == tennis, rank(Oliver, Shigeru), rank(Shigeru, Maricella))) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
Implies(plays(Paulo) == tennis, And(plays(Kim) == tennis, rank(Kim, Oliver), rank(Oliver, Paulo))) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo
ForAll([p:people], Implies(plays(p) == tennis, rank(Oliver, p))) ::: If Oliver is the highest-ranking tennis player
# Options
is_valid(plays(Oliver) == plays(Maricella)) ::: (A)
is_valid(plays(Paulo) == plays(Lina)) ::: (B)
is_valid(plays(Paulo) == plays(Oliver)) ::: (C)
is_valid(plays(Kim) != plays(Lina)) ::: (D)
is_valid(plays(Kim) != plays(Paulo)) ::: (E)"
"# Context:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.

# Question:
Each of the following could be an accurate, partial list of the kinds of trees in the park EXCEPT:

# Options:
A) oaks, spruces
B) oaks, yews
C) firs, laurels, oaks
D) firs, maples, oaks
E) laurels, maples, oaks","# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])
# Constraints
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces
# Options
is_unsat(And(in_park(oaks), in_park(spruces))) ::: (A)
is_unsat(And(in_park(oaks), in_park(yews))) ::: (B)
is_unsat(And(in_park(firs), in_park(laurels), in_park(oaks))) ::: (C)
is_unsat(And(in_park(firs), in_park(maples), in_park(oaks))) ::: (D)
is_unsat(And(in_park(laurels), in_park(maples), in_park(oaks))) ::: (E)"
"# Context:
Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.

# Question:
If Victor is assigned to bench 2 and Wanda is assigned to bench 4, which one of the following must be true?

# Options:
A) Frank is assigned to bench 1.
B) Gwen is assigned to bench 1.
C) Henry is assigned to bench 3.
D) Xavier is assigned to bench 1.
E) Yvette is assigned to bench 3.","# Declarations
students = EnumSort([Frank, Gwen, Henry, Joan, Victor, Wanda, Xavier, Yvette])
benches = EnumSort([1, 2, 3, 4])
assigned = Function([students] -> [benches])
# Constraints
ForAll([b:benches], Count([s:students], assigned(s) == b) == 2) ::: exactly two students are assigned to each bench
ForAll([b:benches], Exists([s:students], And(Or(s == Frank, s == Gwen, s == Henry, s == Joan), assigned(s) == b))) ::: exactly one major is assigned to each bench
And(assigned(Frank) == assigned(Joan) - 1, assigned(Frank) < assigned(Joan)) ::: Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench
assigned(Frank) == assigned(Victor) ::: Frank is assigned to the same bench as Victor
assigned(Gwen) != assigned(Wanda) ::: Gwen is not assigned to the same bench as Wanda
assigned(Victor) == 2 ::: Victor is assigned to bench 2
assigned(Wanda) == 4 ::: Wanda is assigned to bench 4
# Options
is_valid(assigned(Frank) == 1) ::: (A)
is_valid(assigned(Gwen) == 1) ::: (B)
is_valid(assigned(Henry) == 3) ::: (C)
is_valid(assigned(Xavier) == 1) ::: (D)
is_valid(assigned(Yvette) == 3) ::: (E)"
"# Context:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.

# Question:
If Valhalla arrived before Neptune but after Pacific, which one of the following could be true?

# Options:
A) Tornado arrived before Valhalla.
B) Kashmir arrived before Pacific.
C) Ojibwa was not the last of the boats to arrive.
D) Spain arrived before Valhalla.
E) Spain was not the seventh of the boats to arrive.","# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrival_order = Function([boats] -> [int])
# Constraints
arrival_order(Tornado) < arrival_order(Spain) ::: Tornado arrived before Spain
arrival_order(Jewel) < arrival_order(Tornado) ::: Tornado arrived after Jewel
arrival_order(Neptune) < arrival_order(Tornado) ::: Neptune arrived before Tornado
arrival_order(Jewel) < arrival_order(Kashmir) ::: Kashmir arrived after Jewel
arrival_order(Kashmir) < arrival_order(Spain) ::: Kashmir arrived before Spain
arrival_order(Spain) < arrival_order(Ojibwa) ::: Spain arrived before Ojibwa
arrival_order(Pacific) < arrival_order(Valhalla) ::: Valhalla arrived after Pacific
arrival_order(Valhalla) < arrival_order(Neptune) ::: Valhalla arrived before Neptune
# Options
is_valid(arrival_order(Tornado) < arrival_order(Valhalla)) ::: (A)
is_valid(arrival_order(Kashmir) < arrival_order(Pacific)) ::: (B)
is_valid(arrival_order(Ojibwa) != 8) ::: (C)
is_valid(arrival_order(Spain) < arrival_order(Valhalla)) ::: (D)
is_valid(arrival_order(Spain) != 7) ::: (E)"
"# Context:
A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.

# Question:
If all snakes are female and each of the lizards has a habitat to itself, then which one of the following habitats CANNOT contain any snakes?

# Options:
A) habitat 1
B) habitat 2
C) habitat 3
D) habitat 4
E) habitat 5","# Declarations
habitats = EnumSort([1, 2, 3, 4, 5])
reptiles = EnumSort([snake1, snake2, snake3, snake4, lizard1, lizard2, lizard3])
is_snake = Function([reptiles] -> [bool])
is_female = Function([reptiles] -> [bool])
housed_in = Function([reptiles] -> [habitats])
# Constraints
ForAll([r:reptiles], is_snake(r) == Or(r == snake1, r == snake2, r == snake3, r == snake4)) ::: Define snakes
ForAll([r:reptiles], is_female(r) == Or(r == snake1, r == snake2, r == snake3, r == snake4, r == lizard1, r == lizard2)) ::: Define females
ForAll([h:habitats], Count([r:reptiles], housed_in(r) == h) <= 2) ::: No habitat houses more than two reptiles
ForAll([r1:reptiles, r2:reptiles], Implies(And(is_snake(r1), Not(is_snake(r2))), housed_in(r1) != housed_in(r2))) ::: No habitat houses both a snake and a lizard
ForAll([r1:reptiles, r2:reptiles], Implies(And(is_snake(r1), is_female(r1), Not(is_female(r2)), housed_in(r2) == housed_in(r1) + 1), housed_in(r1) != housed_in(r2) - 1)) ::: No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard
ForAll([r:reptiles], Implies(is_snake(r), is_female(r))) ::: All snakes are female
ForAll([r:reptiles], Implies(Not(is_snake(r)), Count([r1:reptiles], And(housed_in(r1) == housed_in(r), Not(is_snake(r1)))) == 1)) ::: Each of the lizards has a habitat to itself
# Options
is_unsat(Exists([r:reptiles], And(is_snake(r), housed_in(r) == 1))) ::: (A)
is_unsat(Exists([r:reptiles], And(is_snake(r), housed_in(r) == 2))) ::: (B)
is_unsat(Exists([r:reptiles], And(is_snake(r), housed_in(r) == 3))) ::: (C)
is_unsat(Exists([r:reptiles], And(is_snake(r), housed_in(r) == 4))) ::: (D)
is_unsat(Exists([r:reptiles], And(is_snake(r), housed_in(r) == 5))) ::: (E)"
"# Context:
Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.

# Question:
Each of the following could be true EXCEPT:

# Options:
A) Both Klaus and Harry speak Turkish.
B) Both Klaus and Michael speak French.
C) Both Klaus and Michael speak Russian.
D) Both Klaus and Norma speak French.
E) Both Klaus and Norma speak Spanish.","# Declarations
tourists = EnumSort([Harry, Irene, Klaus, Laura, Michael, Norma])
guides = EnumSort([Valois, Xerxes, Yossarian, Zalamea])
languages = EnumSort([French, Turkish, Spanish, Russian])
assigned = Function([tourists] -> [guides])
speaks = Function([tourists] -> [languages])
# Constraints
ForAll([g:guides], Exists([t:tourists], assigned(t) == g)) ::: at least one tourist assigned to each guide
ForAll([t:tourists], Exists([g:guides], assigned(t) == g)) ::: each tourist is assigned to exactly one guide
assigned(Harry) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Irene) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Laura) == Zalamea ::: at least Laura is assigned to Zalamea
Implies(assigned(Klaus) == Xerxes, speaks(Michael) == French) ::: if Klaus is assigned to Xerxes, then Michael speaks French
ForAll([t:tourists], Implies(assigned(t) == Valois, speaks(t) == French)) ::: Valois speaks only French
ForAll([t:tourists], Implies(assigned(t) == Xerxes, Or(speaks(t) == Turkish, speaks(t) == Spanish))) ::: Xerxes speaks only Turkish and Spanish
ForAll([t:tourists], Implies(assigned(t) == Yossarian, Or(speaks(t) == French, speaks(t) == Turkish))) ::: Yossarian speaks only French and Turkish
ForAll([t:tourists], Implies(assigned(t) == Zalamea, Or(speaks(t) == Spanish, speaks(t) == Russian))) ::: Zalamea speaks only Spanish and Russian
# Options
is_unsat(And(speaks(Klaus) == Turkish, speaks(Harry) == Turkish)) ::: (A)
is_unsat(And(speaks(Klaus) == French, speaks(Michael) == French)) ::: (B)
is_unsat(And(speaks(Klaus) == Russian, speaks(Michael) == Russian)) ::: (C)
is_unsat(And(speaks(Klaus) == French, speaks(Norma) == French)) ::: (D)
is_unsat(And(speaks(Klaus) == Spanish, speaks(Norma) == Spanish)) ::: (E)"
"# Context:
To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.

# Question:
If exactly two of the languages are learned by the historian, then which one of the following must be true?

# Options:
A) The paleontologist does not learn Rundi.
B) The geologist does not learn Swahili.
C) The linguist does not learn Rundi.
D) The historian does not learn Rundi.
E) The paleontologist does not learn Swahili.","# Declarations
researchers = EnumSort([geologist, historian, linguist, paleontologist])
languages = EnumSort([Rundi, Swahili, Tigrinya, Yoruba])
learned = Function([researchers, languages] -> [bool])
# Constraints
Exists([r:researchers], learned(r, Rundi)) ::: Exactly one researcher learns Rundi
Count([r:researchers], learned(r, Swahili)) == 2 ::: Exactly two researchers learn Swahili
Count([r:researchers], learned(r, Tigrinya)) == 2 ::: Exactly two researchers learn Tigrinya
Count([r:researchers], learned(r, Yoruba)) == 3 ::: Exactly three researchers learn Yoruba
ForAll([l:languages], Implies(Or(learned(linguist, l), learned(paleontologist, l)), Not(learned(geologist, l)))) ::: Any language learned by the linguist or paleontologist is not learned by the geologist
ForAll([l:languages], Implies(learned(geologist, l), learned(historian, l))) ::: Any language learned by the geologist is learned by the historian
Count([l:languages], learned(historian, l)) == 2 ::: exactly two of the languages are learned by the historian
# Options
is_valid(Not(learned(paleontologist, Rundi))) ::: (A)
is_valid(Not(learned(geologist, Swahili))) ::: (B)
is_valid(Not(learned(linguist, Rundi))) ::: (C)
is_valid(Not(learned(historian, Rundi))) ::: (D)
is_valid(Not(learned(paleontologist, Swahili))) ::: (E)"
"# Context:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.

# Question:
If Shigeru plays golf, then each of the following are pairs of people who must play the same sport as each other EXCEPT:

# Options:
A) Paulo and Maricella
B) Paulo and Shigeru
C) Kim and Maricella
D) Paulo and Lina
E) Maricella and Shigeru","# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people] -> [sports])
rank = Function([people, people] -> [bool])
# Constraints
plays(Oliver) == tennis ::: Oliver plays tennis
plays(Lina) == golf ::: Lina plays golf
ForAll([p:people], Implies(plays(p) == golf, rank(Lina, p))) ::: There is no golf player ranked higher than Lina
Implies(plays(Maricella) == golf, And(plays(Paulo) == golf, plays(Shigeru) == golf, rank(Maricella, Paulo), rank(Paulo, Shigeru))) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
Implies(plays(Maricella) == tennis, And(plays(Shigeru) == tennis, rank(Oliver, Shigeru), rank(Shigeru, Maricella))) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
Implies(plays(Paulo) == tennis, And(plays(Kim) == tennis, rank(Kim, Oliver), rank(Oliver, Paulo))) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo
plays(Shigeru) == golf ::: Shigeru plays golf
# Options
is_unsat(And(plays(Paulo) == plays(Maricella))) ::: (A)
is_unsat(And(plays(Paulo) == plays(Shigeru))) ::: (B)
is_unsat(And(plays(Kim) == plays(Maricella))) ::: (C)
is_unsat(And(plays(Paulo) == plays(Lina))) ::: (D)
is_unsat(And(plays(Maricella) == plays(Shigeru))) ::: (E)"
"# Context:
Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.

# Question:
Which one of the following could be the assignment of students to benches?

# Options:
A) 1: Frank, Victor; 2: Joan, Gwen; 3: Henry, Wanda; 4: Xavier, Yvette
B) 1: Gwen, Yvette; 2: Frank, Xavier; 3: Joan, Wanda; 4: Henry, Victor
C) 1: Henry, Wanda; 2: Gwen, Xavier; 3: Frank, Victor; 4: Joan, Yvette
D) 1: Henry, Xavier; 2: Joan, Wanda; 3: Frank, Victor; 4: Gwen, Yvette
E) 1: Henry, Yvette; 2: Gwen, Wanda; 3: Frank, Victor, 4: Joan, Xavier","# Declarations
students = EnumSort([Frank, Gwen, Henry, Joan, Victor, Wanda, Xavier, Yvette])
benches = EnumSort([1, 2, 3, 4])
assigned = Function([students] -> [benches])
# Constraints
ForAll([b:benches], Count([s:students], assigned(s) == b) == 2) ::: exactly two students are assigned to each bench
ForAll([b:benches], Exists([s:students], And(Or(s == Frank, s == Gwen, s == Henry, s == Joan), assigned(s) == b))) ::: exactly one major is assigned to each bench
And(assigned(Frank) == assigned(Victor), assigned(Frank) + 1 == assigned(Joan)) ::: Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench, and Frank is assigned to the same bench as Victor
assigned(Gwen) != assigned(Wanda) ::: Gwen is not assigned to the same bench as Wanda
# Options
is_accurate_list([assigned(Frank) == 1, assigned(Victor) == 1, assigned(Joan) == 2, assigned(Gwen) == 2, assigned(Henry) == 3, assigned(Wanda) == 3, assigned(Xavier) == 4, assigned(Yvette) == 4]) ::: (A)
is_accurate_list([assigned(Gwen) == 1, assigned(Yvette) == 1, assigned(Frank) == 2, assigned(Xavier) == 2, assigned(Joan) == 3, assigned(Wanda) == 3, assigned(Henry) == 4, assigned(Victor) == 4]) ::: (B)
is_accurate_list([assigned(Henry) == 1, assigned(Wanda) == 1, assigned(Gwen) == 2, assigned(Xavier) == 2, assigned(Frank) == 3, assigned(Victor) == 3, assigned(Joan) == 4, assigned(Yvette) == 4]) ::: (C)
is_accurate_list([assigned(Henry) == 1, assigned(Xavier) == 1, assigned(Joan) == 2, assigned(Wanda) == 2, assigned(Frank) == 3, assigned(Victor) == 3, assigned(Gwen) == 4, assigned(Yvette) == 4]) ::: (D)
is_accurate_list([assigned(Henry) == 1, assigned(Yvette) == 1, assigned(Gwen) == 2, assigned(Wanda) == 2, assigned(Frank) == 3, assigned(Victor) == 3, assigned(Joan) == 4, assigned(Xavier) == 4]) ::: (E)"
"# Context:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.

# Question:
If pines are in the park, then which one of the following must be true?

# Options:
A) Exactly four kinds of trees are in the park.
B) Exactly five kinds of trees are in the park.
C) Neither firs nor maples are in the park.
D) Neither firs nor oaks are in the park.
E) Neither laurels nor maples are in the park.","# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])
# Constraints
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces
in_park(pines) ::: If pines are in the park
# Options
is_valid(Count([t:trees], in_park(t)) == 4) ::: (A)
is_valid(Count([t:trees], in_park(t)) == 5) ::: (B)
is_valid(And(Not(in_park(firs)), Not(in_park(maples)))) ::: (C)
is_valid(And(Not(in_park(firs)), Not(in_park(oaks)))) ::: (D)
is_valid(And(Not(in_park(laurels)), Not(in_park(maples)))) ::: (E)"
"# Context:
The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.

# Question:
The largest number of members that the planting committee and the trails committee could have in common is

# Options:
A) three
B) four
C) five
D) six
E) seven","# Declarations
volunteers = EnumSort([F, G, H, J, K, L, M])
committees = EnumSort([planting, trails])
assigned = Function([volunteers] -> [committees])
# Constraints
ForAll([c:committees], Count([v:volunteers], assigned(v) == c) >= 3) ::: Each committee must have at least three members
assigned(F) != assigned(K) ::: F cannot be on the same committee as K
Implies(assigned(K) == planting, assigned(J) == planting) ::: If K is on a committee, J must also be on that committee
Implies(assigned(K) == trails, assigned(J) == trails) ::: If K is on a committee, J must also be on that committee
Exists([c:committees], assigned(M) == c) ::: M must be on at least one of the committees
Exists([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) ::: The two committees must have at least one member in common
# Options
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 3) ::: (A)
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 4) ::: (B)
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 5) ::: (C)
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 6) ::: (D)
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 7) ::: (E)"
"# Context:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.

# Question:
Of the eight boats, if Valhalla was the second to arrive, then which one of the following CANNOT be true?

# Options:
A) Jewel was the third to arrive.
B) Jewel was the first to arrive.
C) Kashmir was the third to arrive.
D) Pacific was the third to arrive.
E) Tornado was the third to arrive.","# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrival_order = Function([boats] -> [int])
# Constraints
arrival_order(Tornado) > arrival_order(Jewel) ::: Tornado arrived before Spain but after Jewel
arrival_order(Neptune) < arrival_order(Tornado) ::: Neptune arrived before Tornado
arrival_order(Kashmir) > arrival_order(Jewel) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Kashmir) < arrival_order(Spain) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Spain) < arrival_order(Ojibwa) ::: Spain arrived before Ojibwa
arrival_order(Valhalla) == 2 ::: Valhalla was the second to arrive
# Options
is_unsat(arrival_order(Jewel) == 3) ::: (A)
is_unsat(arrival_order(Jewel) == 1) ::: (B)
is_unsat(arrival_order(Kashmir) == 3) ::: (C)
is_unsat(arrival_order(Pacific) == 3) ::: (D)
is_unsat(arrival_order(Tornado) == 3) ::: (E)"
"# Context:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.

# Question:
Of the eight boats, what is the maximum number that could have arrived before Jewel?

# Options:
A) none
B) one
C) two
D) three
E) four","# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrival_order = Function([boats] -> [int])
# Constraints
arrival_order(Tornado) > arrival_order(Jewel) ::: Tornado arrived before Spain but after Jewel
arrival_order(Neptune) < arrival_order(Tornado) ::: Neptune arrived before Tornado
arrival_order(Kashmir) > arrival_order(Jewel) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Kashmir) < arrival_order(Spain) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Spain) < arrival_order(Ojibwa) ::: Spain arrived before Ojibwa
# Options
is_sat(Count([b:boats], arrival_order(b) < arrival_order(Jewel)) == 0) ::: (A)
is_sat(Count([b:boats], arrival_order(b) < arrival_order(Jewel)) == 1) ::: (B)
is_sat(Count([b:boats], arrival_order(b) < arrival_order(Jewel)) == 2) ::: (C)
is_sat(Count([b:boats], arrival_order(b) < arrival_order(Jewel)) == 3) ::: (D)
is_sat(Count([b:boats], arrival_order(b) < arrival_order(Jewel)) == 4) ::: (E)"
"# Context:
A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.

# Question:
If habitat 3 is empty, and no snake is housed in a habitat that is immediately next to a habitat containing a snake, then which one of the following could be false?

# Options:
A) All snakes are housed in even-numbered habitats.
B) None of the lizards is male.
C) No snake is alone in a habitat.
D) No lizard is housed in a habitat that is immediately next to a habitat containing a lizard.
E) Exactly one habitat contains exactly one reptile.","# Declarations
habitats = EnumSort([1, 2, 3, 4, 5])
reptiles = EnumSort([snake1, snake2, snake3, snake4, lizard1, lizard2, lizard3])
genders = EnumSort([male, female])
species = EnumSort([snake, lizard])
housed = Function([reptiles] -> [habitats])
reptile_gender = Function([reptiles] -> [genders])
reptile_species = Function([reptiles] -> [species])
# Constraints
ForAll([r:reptiles], Exists([h:habitats], housed(r) == h)) ::: Each reptile must be housed in exactly one habitat
ForAll([h:habitats], Count([r:reptiles], housed(r) == h) <= 2) ::: No habitat houses more than two reptiles
ForAll([r1:reptiles, r2:reptiles], Implies(And(reptile_species(r1) == snake, reptile_species(r2) == lizard), housed(r1) != housed(r2))) ::: No habitat houses both a snake and a lizard
ForAll([r1:reptiles, r2:reptiles], Implies(And(reptile_species(r1) == snake, reptile_gender(r1) == female, reptile_species(r2) == lizard, reptile_gender(r2) == male), Abs(housed(r1) - housed(r2)) != 1)) ::: No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard
ForAll([r:reptiles], housed(r) != 3) ::: Habitat 3 is empty
ForAll([r1:reptiles, r2:reptiles], Implies(And(reptile_species(r1) == snake, reptile_species(r2) == snake), Abs(housed(r1) - housed(r2)) != 1)) ::: No snake is housed in a habitat that is immediately next to a habitat containing a snake
# Options
is_unsat(ForAll([r:reptiles], Implies(reptile_species(r) == snake, Or(housed(r) == 2, housed(r) == 4)))) ::: (A) All snakes are housed in even-numbered habitats
is_unsat(ForAll([r:reptiles], Implies(reptile_species(r) == lizard, reptile_gender(r) == female))) ::: (B) None of the lizards is male
is_unsat(ForAll([r:reptiles], Implies(reptile_species(r) == snake, Count([r2:reptiles], housed(r2) == housed(r)) > 1))) ::: (C) No snake is alone in a habitat
is_unsat(ForAll([r1:reptiles, r2:reptiles], Implies(And(reptile_species(r1) == lizard, reptile_species(r2) == lizard), Abs(housed(r1) - housed(r2)) != 1))) ::: (D) No lizard is housed in a habitat that is immediately next to a habitat containing a lizard
is_unsat(Count([h:habitats], Count([r:reptiles], housed(r) == h) == 1) == 1) ::: (E) Exactly one habitat contains exactly one reptile"
"# Context:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.

# Question:
If firs are not in the park, then which one of the following must be true?

# Options:
A) Maples are not in the park.
B) Spruces are not in the park.
C) Yews are not in the park.
D) Pines are in the park.
E) Spruces are in the park.","# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])
# Constraints
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces
ForAll([t:trees], Implies(Not(in_park(firs)), Not(in_park(t)))) ::: If firs are not in the park
# Options
is_valid(Not(in_park(maples))) ::: (A)
is_valid(Not(in_park(spruces))) ::: (B)
is_valid(Not(in_park(yews))) ::: (C)
is_valid(in_park(pines)) ::: (D)
is_valid(in_park(spruces)) ::: (E)"
"# Context:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.

# Question:
Which one of the following could be a complete and accurate list of the people who play tennis, listed in order of rank from highest to lowest?

# Options:
A) Shigeru, Paulo, Oliver
B) Oliver, Paulo, Kim
C) Shigeru, Oliver, Maricella
D) Oliver, Shigeru, Kim, Maricella
E) Paulo, Maricella, Shigeru, Kim","# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people] -> [sports])
rank = Function([people] -> [int])
# Constraints
ForAll([p:people], Exists([s:sports], plays(p) == s)) ::: Each of six people plays exactly one of two sports
plays(Oliver) == tennis ::: Oliver plays tennis
plays(Lina) == golf ::: Lina plays golf
ForAll([p:people], Implies(plays(p) == golf, rank(p) <= rank(Lina))) ::: There is no golf player ranked higher than Lina
Implies(plays(Maricella) == golf, And(plays(Paulo) == golf, plays(Shigeru) == golf, rank(Paulo) < rank(Maricella), rank(Shigeru) < rank(Paulo))) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
Implies(plays(Maricella) == tennis, And(plays(Shigeru) == tennis, rank(Shigeru) < rank(Oliver), rank(Maricella) < rank(Shigeru))) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
Implies(plays(Paulo) == tennis, And(plays(Kim) == tennis, rank(Kim) < rank(Oliver), rank(Paulo) < rank(Kim))) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo
# Options
is_accurate_list([rank(Shigeru) < rank(Paulo), rank(Paulo) < rank(Oliver)]) ::: (A)
is_accurate_list([rank(Oliver) < rank(Paulo), rank(Paulo) < rank(Kim)]) ::: (B)
is_accurate_list([rank(Shigeru) < rank(Oliver), rank(Oliver) < rank(Maricella)]) ::: (C)
is_accurate_list([rank(Oliver) < rank(Shigeru), rank(Shigeru) < rank(Kim), rank(Kim) < rank(Maricella)]) ::: (D)
is_accurate_list([rank(Paulo) < rank(Maricella), rank(Maricella) < rank(Shigeru), rank(Shigeru) < rank(Kim)]) ::: (E)"
"# Context:
A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.

# Question:
Which one of the following is a complete and accurate list of the pieces any of which could be first on the recording?

# Options:
A) G, J, K
B) G, H, J, K
C) G, H, J, L
D) G, J, K, L
E) H, J, K, L, M","# Declarations
pieces = EnumSort([F, G, H, J, K, L, M])
tracks = EnumSort([1, 2, 3, 4, 5, 6, 7])
position = Function([pieces] -> [tracks])
# Constraints
position(F) == 2 ::: F must be second
position(J) != 7 ::: J cannot be seventh
ForAll([t:tracks], Not(And(position(G) == t, position(H) == t + 1))) ::: G can come neither immediately before nor immediately after H
ForAll([t:tracks], Not(And(position(G) == t, position(H) == t - 1))) ::: G can come neither immediately before nor immediately after H
ForAll([t:tracks], Implies(position(H) == t, Exists([t1:tracks], And(t1 < t, position(L) == t1)))) ::: H must be in some track before that of L
ForAll([t:tracks], Implies(position(L) == t, Exists([t1:tracks], And(t1 < t, position(M) == t1)))) ::: L must be in some track before that of M
# Options
is_accurate_list([position(G) == 1, position(J) == 1, position(K) == 1]) ::: (A)
is_accurate_list([position(G) == 1, position(H) == 1, position(J) == 1, position(K) == 1]) ::: (B)
is_accurate_list([position(G) == 1, position(H) == 1, position(J) == 1, position(L) == 1]) ::: (C)
is_accurate_list([position(G) == 1, position(J) == 1, position(K) == 1, position(L) == 1]) ::: (D)
is_accurate_list([position(H) == 1, position(J) == 1, position(K) == 1, position(L) == 1, position(M) == 1]) ::: (E)"
"# Context:
A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.

# Question:
If the seventh song in the sequence is R, which one of the following could be the fifth song?

# Options:
A) F
B) G
C) H
D) V
E) X","# Declarations
songs = EnumSort([F, G, H, R, S, V, X])
sequence = Function([int] -> [songs])
# Constraints
ForAll([i:int], And(i >= 1, i <= 7, Exists([j:int], And(j >= 1, j <= 7, sequence(i) == sequence(j))))) ::: The sequence consists of exactly seven different songs
ForAll([i:int], Implies(And(i >= 1, i <= 6, Or(sequence(i) == R, sequence(i) == S, sequence(i) == V, sequence(i) == X)), Not(Or(sequence(i+1) == R, sequence(i+1) == S, sequence(i+1) == V, sequence(i+1) == X)))) ::: No dance tune can be played immediately after another dance tune
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == H, ForAll([j:int], Implies(And(j >= 1, j <= 7, sequence(j) == V), i < j)))) ::: H must be played earlier in the sequence than V
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == V, Exists([j:int], And(j >= 1, j <= 7, sequence(j) == S, Abs(i - j) == 2)))) ::: V and S must be separated from each other by exactly one song
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == S, Or(sequence(i+1) == F, sequence(i-1) == F))) ::: S must be played immediately before or immediately after F
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == R, Or(sequence(i+1) == F, ForAll([j:int], Implies(And(j >= 1, j <= 7, sequence(j) == G), i < j))))) ::: F must be played immediately after R, unless G is played earlier than R
sequence(7) == R ::: The seventh song in the sequence is R
# Options
is_valid(sequence(5) == F) ::: (A)
is_valid(sequence(5) == G) ::: (B)
is_valid(sequence(5) == H) ::: (C)
is_valid(sequence(5) == V) ::: (D)
is_valid(sequence(5) == X) ::: (E)"
"# Context:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.

# Question:
Which one of the following must be true?

# Options:
A) At least two of the boats arrived before Neptune.
B) At least five of the boats arrived before Pacific.
C) At least four of the boats arrived before Spain.
D) At least three of the boats arrived before Tornado.
E) At least two of the boats arrived before Valhalla.","# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrival_order = Function([boats] -> [int])
# Constraints
arrival_order(Jewel) < arrival_order(Tornado) ::: Tornado arrived before Spain but after Jewel
arrival_order(Neptune) < arrival_order(Tornado) ::: Neptune arrived before Tornado
arrival_order(Jewel) < arrival_order(Kashmir) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Kashmir) < arrival_order(Spain) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Spain) < arrival_order(Ojibwa) ::: Spain arrived before Ojibwa
# Options
is_valid(Count([b:boats], arrival_order(b) < arrival_order(Neptune)) >= 2) ::: (A)
is_valid(Count([b:boats], arrival_order(b) < arrival_order(Pacific)) >= 5) ::: (B)
is_valid(Count([b:boats], arrival_order(b) < arrival_order(Spain)) >= 4) ::: (C)
is_valid(Count([b:boats], arrival_order(b) < arrival_order(Tornado)) >= 3) ::: (D)
is_valid(Count([b:boats], arrival_order(b) < arrival_order(Valhalla)) >= 2) ::: (E)"
"# Context:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.

# Question:
Which one of the following could be true?

# Options:
A) Neither firs nor laurels are in the park.
B) Neither laurels, oaks, nor yews are in the park.
C) Neither laurels nor spruces are in the park.
D) Neither maples nor yews are in the park.
E) Neither oaks nor spruces are in the park.","# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])
# Constraints
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces
# Options
is_sat(And(Not(in_park(firs)), Not(in_park(laurels)))) ::: (A)
is_sat(And(Not(in_park(laurels)), Not(in_park(oaks)), Not(in_park(yews)))) ::: (B)
is_sat(And(Not(in_park(laurels)), Not(in_park(spruces)))) ::: (C)
is_sat(And(Not(in_park(maples)), Not(in_park(yews)))) ::: (D)
is_sat(And(Not(in_park(oaks)), Not(in_park(spruces)))) ::: (E)"
"# Context:
The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.

# Question:
If K is on both committees and L is also on both committees and if the planting committee has exactly three members, then which one of the following must be true?

# Options:
A) F is on the planting committee.
B) F is on the trails committee.
C) G is on the planting committee.
D) M is on the planting committee.
E) M is on the trails committee.","# Declarations
volunteers = EnumSort([F, G, H, J, K, L, M])
committees = EnumSort([planting, trails])
assigned = Function([volunteers] -> [committees])
# Constraints
ForAll([c:committees], Count([v:volunteers], assigned(v) == c) >= 3) ::: Each committee must have at least three members
assigned(F) != assigned(K) ::: F cannot be on the same committee as K
Implies(assigned(K) == c, assigned(J) == c) ::: If K is on a committee, J must also be on that committee
Exists([c:committees], assigned(M) == c) ::: M must be on at least one of the committees
Exists([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) ::: The two committees must have at least one member in common
assigned(K) == planting ::: K is on the planting committee
assigned(L) == planting ::: L is on the planting committee
Count([v:volunteers], assigned(v) == planting) == 3 ::: The planting committee has exactly three members
# Options
is_valid(assigned(F) == planting) ::: (A)
is_valid(assigned(F) == trails) ::: (B)
is_valid(assigned(G) == planting) ::: (C)
is_valid(assigned(M) == planting) ::: (D)
is_valid(assigned(M) == trails) ::: (E)"
"# Context:
Six racehorses—K, L, M, N, O, and P—will be assigned to six positions arranged in a straight line and numbered consecutively 1 through 6. The horses are assigned to the positions, one horse per position, according to the following conditions: K and L must be assigned to positions that are separated from each other by exactly one position. K and N cannot be assigned to positions that are next to each other. N must be assigned to a higher-numbered position than M. P must be assigned to position 3.

# Question:
Which one of the following CANNOT be true?

# Options:
A) K is assigned to position 2.
B) L is assigned to position 2.
C) M is assigned to position 1.
D) M is assigned to position 5.
E) O is assigned to position 2.","# Declarations
horses = EnumSort([K, L, M, N, O, P])
positions = EnumSort([1, 2, 3, 4, 5, 6])
assigned = Function([horses] -> [positions])
# Constraints
Exists([p1:positions, p2:positions], And(p1 != p2, Abs(p1 - p2) == 2, assigned(K) == p1, assigned(L) == p2)) ::: K and L must be assigned to positions that are separated from each other by exactly one position
ForAll([p:positions], Implies(assigned(K) == p, assigned(N) != p + 1)) ::: K and N cannot be assigned to positions that are next to each other
ForAll([p:positions], Implies(assigned(M) == p, assigned(N) > p)) ::: N must be assigned to a higher-numbered position than M
assigned(P) == 3 ::: P must be assigned to position 3
# Options
is_unsat(assigned(K) == 2) ::: (A)
is_unsat(assigned(L) == 2) ::: (B)
is_unsat(assigned(M) == 1) ::: (C)
is_unsat(assigned(M) == 5) ::: (D)
is_unsat(assigned(O) == 2) ::: (E)"
"# Context:
A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.

# Question:
Which one of the following is an order in which the messenger could make the deliveries, from first to seventh?

# Options:
A) L, N, S, O, M, T, P
B) M, T, P, S, L, N, O
C) O, S, L, N, M, T, P
D) P, N, M, S, O, T, L
E) P, T, M, S, L, N, O","# Declarations
packages = EnumSort([L, M, N, O, P, S, T])
delivery_order = Function([packages] -> [int])
# Constraints
Or(delivery_order(P) == 1, delivery_order(P) == 7) ::: P is delivered either first or seventh
delivery_order(N) > delivery_order(L) ::: The messenger delivers N at some time after delivering L
delivery_order(T) > delivery_order(M) ::: The messenger delivers T at some time after delivering M
Exists([p:packages], And(delivery_order(L) < delivery_order(p), delivery_order(p) < delivery_order(O))) ::: The messenger delivers exactly one package between delivering L and delivering O
Exists([p:packages], And(delivery_order(M) < delivery_order(p), delivery_order(p) < delivery_order(P))) ::: The messenger delivers exactly one package between delivering M and delivering P
# Options
is_sat(And(delivery_order(L) == 1, delivery_order(N) == 2, delivery_order(S) == 3, delivery_order(O) == 4, delivery_order(M) == 5, delivery_order(T) == 6, delivery_order(P) == 7)) ::: (A)
is_sat(And(delivery_order(M) == 1, delivery_order(T) == 2, delivery_order(P) == 3, delivery_order(S) == 4, delivery_order(L) == 5, delivery_order(N) == 6, delivery_order(O) == 7)) ::: (B)
is_sat(And(delivery_order(O) == 1, delivery_order(S) == 2, delivery_order(L) == 3, delivery_order(N) == 4, delivery_order(M) == 5, delivery_order(T) == 6, delivery_order(P) == 7)) ::: (C)
is_sat(And(delivery_order(P) == 1, delivery_order(N) == 2, delivery_order(M) == 3, delivery_order(S) == 4, delivery_order(O) == 5, delivery_order(T) == 6, delivery_order(L) == 7)) ::: (D)
is_sat(And(delivery_order(P) == 1, delivery_order(T) == 2, delivery_order(M) == 3, delivery_order(S) == 4, delivery_order(L) == 5, delivery_order(N) == 6, delivery_order(O) == 7)) ::: (E)"
"# Context:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.

# Question:
If Neptune arrived after Kashmir, which one of the following must be false?

# Options:
A) Jewel was the second of the boats to arrive.
B) Kashmir was the fifth of the boats to arrive.
C) Neptune was the third of the boats to arrive.
D) Ojibwa was the sixth of the boats to arrive.
E) Spain was the seventh of the boats to arrive.","# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrival_order = Function([boats] -> [int])
# Constraints
arrival_order(Tornado) > arrival_order(Jewel) ::: Tornado arrived before Spain but after Jewel
arrival_order(Neptune) < arrival_order(Tornado) ::: Neptune arrived before Tornado
arrival_order(Kashmir) > arrival_order(Jewel) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Kashmir) < arrival_order(Spain) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Spain) < arrival_order(Ojibwa) ::: Spain arrived before Ojibwa
arrival_order(Neptune) > arrival_order(Kashmir) ::: Neptune arrived after Kashmir
# Options
is_unsat(arrival_order(Jewel) == 2) ::: (A)
is_unsat(arrival_order(Kashmir) == 5) ::: (B)
is_unsat(arrival_order(Neptune) == 3) ::: (C)
is_unsat(arrival_order(Ojibwa) == 6) ::: (D)
is_unsat(arrival_order(Spain) == 7) ::: (E)"
"# Context:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.

# Question:
Each of the following could be the lowest-ranking tennis player EXCEPT:

# Options:
A) Shigeru
B) Kim
C) Oliver
D) Paulo
E) Maricella","# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people] -> [sports])
rank = Function([people] -> [int])
# Constraints
plays(Oliver) == tennis ::: Oliver plays tennis
plays(Lina) == golf ::: Lina plays golf
ForAll([p:people], Implies(plays(p) == golf, rank(p) >= rank(Lina))) ::: There is no golf player ranked higher than Lina
Implies(plays(Maricella) == golf, And(plays(Paulo) == golf, plays(Shigeru) == golf, rank(Paulo) < rank(Maricella), rank(Shigeru) < rank(Paulo))) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
Implies(plays(Maricella) == tennis, And(plays(Shigeru) == tennis, rank(Shigeru) < rank(Oliver), rank(Maricella) < rank(Shigeru))) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
Implies(plays(Paulo) == tennis, And(plays(Kim) == tennis, rank(Oliver) < rank(Kim), rank(Paulo) < rank(Oliver))) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo
# Options
is_unsat(ForAll([p:people], Implies(plays(p) == tennis, rank(p) > rank(Shigeru)))) ::: (A)
is_unsat(ForAll([p:people], Implies(plays(p) == tennis, rank(p) > rank(Kim)))) ::: (B)
is_unsat(ForAll([p:people], Implies(plays(p) == tennis, rank(p) > rank(Oliver)))) ::: (C)
is_unsat(ForAll([p:people], Implies(plays(p) == tennis, rank(p) > rank(Paulo)))) ::: (D)
is_unsat(ForAll([p:people], Implies(plays(p) == tennis, rank(p) > rank(Maricella)))) ::: (E)"
"# Context:
A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.

# Question:
If M fills some track before that of J and also before that of K on the recording, which one of the following must be true?

# Options:
A) G is first.
B) K is seventh.
C) L is third.
D) H comes either immediately before or immediately after F.
E) L comes either immediately before or immediately after G.","# Declarations
pieces = EnumSort([F, G, H, J, K, L, M])
tracks = EnumSort([1, 2, 3, 4, 5, 6, 7])
position = Function([pieces] -> [tracks])
# Constraints
position(F) == 2 ::: F must be second
position(J) != 7 ::: J cannot be seventh
ForAll([t:tracks], Not(And(position(G) == t, position(H) == t + 1))) ::: G can come neither immediately before nor immediately after H
ForAll([t:tracks], Not(And(position(G) == t, position(H) == t - 1))) ::: G can come neither immediately before nor immediately after H
position(H) < position(L) ::: H must be in some track before that of L
position(L) < position(M) ::: L must be in some track before that of M
position(M) < position(J) ::: M fills some track before that of J
position(M) < position(K) ::: M fills some track before that of K
# Options
is_valid(position(G) == 1) ::: (A)
is_valid(position(K) == 7) ::: (B)
is_valid(position(L) == 3) ::: (C)
is_valid(Or(position(H) == position(F) - 1, position(H) == position(F) + 1)) ::: (D)
is_valid(Or(position(L) == position(G) - 1, position(L) == position(G) + 1)) ::: (E)"
"# Context:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.

# Question:
If neither maples nor spruces are in the park, then which one of the following could be true?

# Options:
A) Exactly four kinds of trees are in the park.
B) Exactly five kinds of trees are in the park.
C) Laurels are not in the park.
D) Oaks are not in the park.
E) Yews are not in the park.","# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])
# Constraints
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces
ForAll([t:trees], Implies(t == maples, Not(in_park(t)))) ::: maples are not in the park
ForAll([t:trees], Implies(t == spruces, Not(in_park(t)))) ::: spruces are not in the park
# Options
is_valid(Count([t:trees], in_park(t)) == 4) ::: (A)
is_valid(Count([t:trees], in_park(t)) == 5) ::: (B)
is_valid(Not(in_park(laurels))) ::: (C)
is_valid(Not(in_park(oaks))) ::: (D)
is_valid(Not(in_park(yews))) ::: (E)"
"# Context:
The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.

# Question:
If the only members of the planting committee are G, H, and L and if the two committees are to have as many members in common as the conditions allow, then which one of the following must be true?

# Options:
A) The trails committee and the planting committee have exactly one member in common.
B) The trails committee and the planting committee have exactly two members in common.
C) The trails committee and the planting committee have an equal number of members.
D) The trails committee has at least one more member than the planting committee.
E) The planting committee has exactly two more members than the trails committee.","# Declarations
volunteers = EnumSort([F, G, H, J, K, L, M])
committees = EnumSort([planting, trails])
assigned = Function([volunteers] -> [committees])
# Constraints
ForAll([c:committees], Count([v:volunteers], assigned(v) == c) >= 3) ::: Each committee must have at least three members
assigned(F) != assigned(K) ::: F cannot be on the same committee as K
Implies(assigned(K) == planting, assigned(J) == planting) ::: If K is on a committee, J must also be on that committee
Or(assigned(M) == planting, assigned(M) == trails) ::: M must be on at least one of the committees
Exists([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) ::: The two committees must have at least one member in common
assigned(G) == planting ::: The only members of the planting committee are G, H, and L
assigned(H) == planting ::: The only members of the planting committee are G, H, and L
assigned(L) == planting ::: The only members of the planting committee are G, H, and L
# Options
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 1) ::: (A) The trails committee and the planting committee have exactly one member in common
is_valid(Count([v:volunteers], And(assigned(v) == planting, assigned(v) == trails)) == 2) ::: (B) The trails committee and the planting committee have exactly two members in common
is_valid(Count([v:volunteers], assigned(v) == planting) == Count([v:volunteers], assigned(v) == trails)) ::: (C) The trails committee and the planting committee have an equal number of members
is_valid(Count([v:volunteers], assigned(v) == trails) > Count([v:volunteers], assigned(v) == planting)) ::: (D) The trails committee has at least one more member than the planting committee
is_valid(Count([v:volunteers], assigned(v) == planting) == Count([v:volunteers], assigned(v) == trails) + 2) ::: (E) The planting committee has exactly two more members than the trails committee"
"# Context:
A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.

# Question:
If the third song in the sequence is S, which one of the following must be the sixth song?

# Options:
A) G
B) H
C) R
D) V
E) X","# Declarations
songs = EnumSort([F, G, H, R, S, V, X])
sequence = Function([int] -> [songs])
# Constraints
ForAll([i:int], And(i >= 1, i <= 7, Exists([s:songs], sequence(i) == s))) ::: The sequence consists of exactly seven different songs
ForAll([i:int], Implies(And(i >= 1, i <= 6, sequence(i) == R), sequence(i+1) != R)) ::: No dance tune can be played immediately after another dance tune
ForAll([i:int], Implies(And(i >= 1, i <= 6, sequence(i) == S), sequence(i+1) != S)) ::: No dance tune can be played immediately after another dance tune
ForAll([i:int], Implies(And(i >= 1, i <= 6, sequence(i) == V), sequence(i+1) != V)) ::: No dance tune can be played immediately after another dance tune
ForAll([i:int], Implies(And(i >= 1, i <= 6, sequence(i) == X), sequence(i+1) != X)) ::: No dance tune can be played immediately after another dance tune
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == H, ForAll([j:int], Implies(And(j >= 1, j <= 7, sequence(j) == V), i < j)))) ::: H must be played earlier in the sequence than V
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == V, Exists([j:int], And(j >= 1, j <= 7, sequence(j) == S, Abs(i - j) == 2)))) ::: V and S must be separated from each other by exactly one song
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == S, Or(sequence(i+1) == F, sequence(i-1) == F))) ::: S must be played immediately before or immediately after F
Exists([i:int], And(i >= 1, i <= 7, sequence(i) == F, Or(sequence(i+1) == R, ForAll([j:int], Implies(And(j >= 1, j <= 7, sequence(j) == R), i < j))))) ::: F must be played immediately after R, unless G is played earlier than R
sequence(3) == S ::: The third song in the sequence is S
# Options
is_valid(sequence(6) == G) ::: (A)
is_valid(sequence(6) == H) ::: (B)
is_valid(sequence(6) == R) ::: (C)
is_valid(sequence(6) == V) ::: (D)
is_valid(sequence(6) == X) ::: (E)"
"# Context:
A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.

# Question:
Which one of the following could be the order, from first to seventh, of the pieces on the recording?

# Options:
A) F, K, G, J, H, L, M
B) G, F, H, K, L, J, M
C) G, F, H, K, L, M, J
D) K, F, G, H, J, L, M
E) K, F, L, J, H, M, G","# Declarations
pieces = EnumSort([F, G, H, J, K, L, M])
tracks = EnumSort([1, 2, 3, 4, 5, 6, 7])
position = Function([pieces] -> [tracks])
# Constraints
position(F) == 2 ::: F must be second
position(J) != 7 ::: J cannot be seventh
ForAll([t:tracks], Implies(position(G) == t, And(position(H) != t - 1, position(H) != t + 1))) ::: G can come neither immediately before nor immediately after H
ForAll([t:tracks], Implies(position(H) == t, position(L) < t)) ::: H must be in some track before that of L
ForAll([t:tracks], Implies(position(L) == t, position(M) < t)) ::: L must be in some track before that of M
# Options
is_sat(And(position(F) == 1, position(K) == 2, position(G) == 3, position(J) == 4, position(H) == 5, position(L) == 6, position(M) == 7)) ::: (A)
is_sat(And(position(G) == 1, position(F) == 2, position(H) == 3, position(K) == 4, position(L) == 5, position(J) == 6, position(M) == 7)) ::: (B)
is_sat(And(position(G) == 1, position(F) == 2, position(H) == 3, position(K) == 4, position(L) == 5, position(M) == 6, position(J) == 7)) ::: (C)
is_sat(And(position(K) == 1, position(F) == 2, position(G) == 3, position(H) == 4, position(J) == 5, position(L) == 6, position(M) == 7)) ::: (D)
is_sat(And(position(K) == 1, position(F) == 2, position(L) == 3, position(J) == 4, position(H) == 5, position(M) == 6, position(G) == 7)) ::: (E)"
"# Context:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.

# Question:
Which one of the following could be true?

# Options:
A) Maricella plays tennis and Shigeru plays golf.
B) Paulo plays tennis and Kim plays golf.
C) Kim plays tennis and Paulo plays golf.
D) Paulo and Oliver play tennis, Paulo ranking higher than Oliver.
E) Maricella and Shigeru play tennis, Maricella ranking higher than Shigeru.","# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people] -> [sports])
ranks = Function([people, people] -> [bool])
# Constraints
plays(Oliver) == tennis ::: Oliver plays tennis
plays(Lina) == golf ::: Lina plays golf
ForAll([p:people], Implies(plays(p) == golf, ranks(Lina, p))) ::: There is no golf player ranked higher than Lina
Implies(plays(Maricella) == golf, And(plays(Paulo) == golf, plays(Shigeru) == golf, ranks(Maricella, Paulo), ranks(Paulo, Shigeru))) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
Implies(plays(Maricella) == tennis, And(plays(Shigeru) == tennis, ranks(Oliver, Shigeru), ranks(Shigeru, Maricella))) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
Implies(plays(Paulo) == tennis, And(plays(Kim) == tennis, ranks(Kim, Oliver), ranks(Oliver, Paulo))) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo
# Options
is_valid(And(plays(Maricella) == tennis, plays(Shigeru) == golf)) ::: (A)
is_valid(And(plays(Paulo) == tennis, plays(Kim) == golf)) ::: (B)
is_valid(And(plays(Kim) == tennis, plays(Paulo) == golf)) ::: (C)
is_valid(And(plays(Paulo) == tennis, plays(Oliver) == tennis, ranks(Paulo, Oliver))) ::: (D)
is_valid(And(plays(Maricella) == tennis, plays(Shigeru) == tennis, ranks(Maricella, Shigeru))) ::: (E)"
"# Context:
A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.

# Question:
Which one of the following could be a complete and accurate list of the kinds of trees in the park?

# Options:
A) firs, maples
B) firs, laurels, oaks
C) firs, laurels, pines, spruces
D) firs, laurels, spruces, yews
E) firs, maples, oaks, spruces, yews","# Declarations
trees = EnumSort([firs, laurels, maples, oaks, pines, spruces, yews])
in_park = Function([trees] -> [bool])
# Constraints
Implies(in_park(maples), Not(in_park(yews))) ::: If maples are in the park, yews are not
Implies(in_park(firs), Not(in_park(pines))) ::: If firs are in the park, pines are not
Implies(Not(in_park(yews)), Or(in_park(laurels), in_park(oaks))) ::: If yews are not in the park, then either laurels or oaks, but not both, are in the park
Implies(Not(And(in_park(laurels), in_park(oaks))), And(in_park(firs), in_park(spruces))) ::: If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces
Count([t:trees], in_park(t)) <= 5 ::: A park contains at most five of seven kinds of trees
# Options
is_accurate_list([in_park(firs), in_park(maples)]) ::: (A)
is_accurate_list([in_park(firs), in_park(laurels), in_park(oaks)]) ::: (B)
is_accurate_list([in_park(firs), in_park(laurels), in_park(pines), in_park(spruces)]) ::: (C)
is_accurate_list([in_park(firs), in_park(laurels), in_park(spruces), in_park(yews)]) ::: (D)
is_accurate_list([in_park(firs), in_park(maples), in_park(oaks), in_park(spruces), in_park(yews)]) ::: (E)"
"# Context:
The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.

# Question:
If the planting committee consists of F, H, L, and M, and if the trails committee consists of G, H, and J, then K could replace which one of the following committee members on a committee without violating any of the conditions governing the composition of the committees?

# Options:
A) F
B) G
C) H
D) L
E) M","# Declarations
volunteers = EnumSort([F, G, H, J, K, L, M])
committees = EnumSort([planting, trails])
member = Function([volunteers] -> [committees])
# Constraints
ForAll([c:committees], Count([v:volunteers], member(v) == c) >= 3) ::: Each committee must have at least three members
member(F) != member(K) ::: F cannot be on the same committee as K
Implies(member(K) == planting, member(J) == planting) ::: If K is on the planting committee, J must also be on that committee
Implies(member(K) == trails, member(J) == trails) ::: If K is on the trails committee, J must also be on that committee
Or(member(M) == planting, member(M) == trails) ::: M must be on at least one of the committees
Exists([v:volunteers], And(member(v) == planting, member(v) == trails)) ::: The two committees must have at least one member in common
member(F) == planting ::: The planting committee consists of F, H, L, and M
member(H) == planting ::: The planting committee consists of F, H, L, and M
member(L) == planting ::: The planting committee consists of F, H, L, and M
member(M) == planting ::: The planting committee consists of F, H, L, and M
member(G) == trails ::: The trails committee consists of G, H, and J
member(H) == trails ::: The trails committee consists of G, H, and J
member(J) == trails ::: The trails committee consists of G, H, and J
# Options
is_valid(member(K) == planting) ::: (A)
is_valid(member(K) == trails) ::: (B)
is_valid(member(K) == trails) ::: (C)
is_valid(member(K) == planting) ::: (D)
is_valid(member(K) == planting) ::: (E)"
"# Context:
Five candidates for mayor—Q, R, S, T, and U—will each speak exactly once at each of three town meetings—meetings 1, 2, and 3. At each meeting, each candidate will speak in one of five consecutive time slots. No two candidates will speak in the same time slot as each other at any meeting. The order in which the candidates will speak will meet the following conditions: Each candidate must speak either first or second at at least one of the meetings. Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings. No candidate can speak fourth at more than one of the meetings.

# Question:
Which one of the following could be the order, from first to fifth, in which the candidates speak at the meetings?

# Options:
A) meeting 1: Q, U, R, T, S meeting 2: S, T, R, U, Q meeting 3: T, U, Q, R, S
B) meeting 1: R, S, Q, T, U meeting 2: U, T, S, R, Q meeting 3: Q, R, T, U, S
C) meeting 1: S, Q, U, T, R meeting 2: U, T, Q, R, S meeting 3: R, Q, S, T, U
D) meeting 1: T, R, S, U, Q meeting 2: Q, R, S, T, U meeting 3: U, S, R, Q, T
E) meeting 1: U, T, R, S, Q meeting 2: Q, R, S, T, U meeting 3: S, T, U, Q, R","# Declarations
candidates = EnumSort([Q, R, S, T, U])
meetings = EnumSort([meeting1, meeting2, meeting3])
time_slots = EnumSort([first, second, third, fourth, fifth])
speaks_at = Function([candidates, meetings] -> [time_slots])
# Constraints
ForAll([m:meetings], ForAll([c1:candidates, c2:candidates], Implies(c1 != c2, speaks_at(c1, m) != speaks_at(c2, m)))) ::: No two candidates will speak in the same time slot as each other at any meeting
ForAll([c:candidates], Or(Exists([m:meetings], speaks_at(c, m) == first), Exists([m:meetings], speaks_at(c, m) == second))) ::: Each candidate must speak either first or second at at least one of the meetings
ForAll([c:candidates], Implies(Or(speaks_at(c, meeting1) == fifth, speaks_at(c, meeting2) == fifth, speaks_at(c, meeting3) == fifth), Or(Exists([m:meetings], speaks_at(c, m) == first), Exists([m:meetings], speaks_at(c, m) == second)))) ::: Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings
ForAll([c:candidates], Count([m:meetings], speaks_at(c, m) == fourth) <= 1) ::: No candidate can speak fourth at more than one of the meetings
# Options
is_sat(And(speaks_at(Q, meeting1) == first, speaks_at(U, meeting1) == second, speaks_at(R, meeting1) == third, speaks_at(T, meeting1) == fourth, speaks_at(S, meeting1) == fifth, speaks_at(S, meeting2) == first, speaks_at(T, meeting2) == second, speaks_at(R, meeting2) == third, speaks_at(U, meeting2) == fourth, speaks_at(Q, meeting2) == fifth, speaks_at(T, meeting3) == first, speaks_at(U, meeting3) == second, speaks_at(Q, meeting3) == third, speaks_at(R, meeting3) == fourth, speaks_at(S, meeting3) == fifth)) ::: (A)
is_sat(And(speaks_at(R, meeting1) == first, speaks_at(S, meeting1) == second, speaks_at(Q, meeting1) == third, speaks_at(T, meeting1) == fourth, speaks_at(U, meeting1) == fifth, speaks_at(U, meeting2) == first, speaks_at(T, meeting2) == second, speaks_at(S, meeting2) == third, speaks_at(R, meeting2) == fourth, speaks_at(Q, meeting2) == fifth, speaks_at(Q, meeting3) == first, speaks_at(R, meeting3) == second, speaks_at(T, meeting3) == third, speaks_at(U, meeting3) == fourth, speaks_at(S, meeting3) == fifth)) ::: (B)
is_sat(And(speaks_at(S, meeting1) == first, speaks_at(Q, meeting1) == second, speaks_at(U, meeting1) == third, speaks_at(T, meeting1) == fourth, speaks_at(R, meeting1) == fifth, speaks_at(U, meeting2) == first, speaks_at(T, meeting2) == second, speaks_at(Q, meeting2) == third, speaks_at(R, meeting2) == fourth, speaks_at(S, meeting2) == fifth, speaks_at(R, meeting3) == first, speaks_at(Q, meeting3) == second, speaks_at(S, meeting3) == third, speaks_at(T, meeting3) == fourth, speaks_at(U, meeting3) == fifth)) ::: (C)
is_sat(And(speaks_at(T, meeting1) == first, speaks_at(R, meeting1) == second, speaks_at(S, meeting1) == third, speaks_at(U, meeting1) == fourth, speaks_at(Q, meeting1) == fifth, speaks_at(Q, meeting2) == first, speaks_at(R, meeting2) == second, speaks_at(S, meeting2) == third, speaks_at(T, meeting2) == fourth, speaks_at(U, meeting2) == fifth, speaks_at(U, meeting3) == first, speaks_at(S, meeting3) == second, speaks_at(R, meeting3) == third, speaks_at(Q, meeting3) == fourth, speaks_at(T, meeting3) == fifth)) ::: (D)
is_sat(And(speaks_at(U, meeting1) == first, speaks_at(T, meeting1) == second, speaks_at(R, meeting1) == third, speaks_at(S, meeting1) == fourth, speaks_at(Q, meeting1) == fifth, speaks_at(Q, meeting2) == first, speaks_at(R, meeting2) == second, speaks_at(S, meeting2) == third, speaks_at(T, meeting2) == fourth, speaks_at(U, meeting2) == fifth, speaks_at(S, meeting3) == first, speaks_at(T, meeting3) == second, speaks_at(U, meeting3) == third, speaks_at(Q, meeting3) == fourth, speaks_at(R, meeting3) == fifth)) ::: (E)"
"# Context:
Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.

# Question:
Which one of the following statements must be false?

# Options:
A) Car 2 is green.
B) Car 4 is orange.
C) Car 5 is purple.
D) Car 6 is orange.
E) Car 6 is green.","# Declarations
cars = EnumSort([1, 2, 3, 4, 5, 6])
colors = EnumSort([green, orange, purple])
color = Function([cars] -> [colors])
# Constraints
ForAll([c:cars], Implies(c != 6, color(c) != color(c + 1))) ::: No car can be the same color as any car next to it in line
Or(color(5) == purple, color(6) == purple) ::: Either car 5 or car 6 must be purple
color(1) != orange ::: Car 1 cannot be orange
color(4) != green ::: Car 4 cannot be green
Count([c:cars], color(c) == green) == 2 ::: There are exactly two green cars
Count([c:cars], color(c) == orange) == 2 ::: There are exactly two orange cars
Count([c:cars], color(c) == purple) == 2 ::: There are exactly two purple cars
# Options
is_unsat(color(2) == green) ::: (A)
is_unsat(color(4) == orange) ::: (B)
is_unsat(color(5) == purple) ::: (C)
is_unsat(color(6) == orange) ::: (D)
is_unsat(color(6) == green) ::: (E)"
"# Context:
In a certain recipe contest, each contestant submits two recipes, one for an appetizer and one for a main dish. Together the two recipes must include exactly seven flavorings—fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, and turmeric—with no flavoring included in more than one of the two recipes. Each contestant's recipes must satisfy the following conditions: The appetizer recipe includes at most three of the flavorings. Fenugreek is not included in the same recipe as nutmeg. Saffron is not included in the same recipe as turmeric. Ginger is included in the same recipe as nutmeg.

# Question:
Which one of the following could be a list of all of the flavorings included in one contestant's appetizer recipe?

# Options:
A) fenugreek, saffron
B) ginger, nutmeg
C) fenugreek, nutmeg, turmeric
D) lemongrass, nutmeg, saffron
E) fenugreek, lemongrass, paprika, turmeric","# Declarations
flavorings = EnumSort([fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, turmeric])
appetizer = Function([flavorings] -> [bool])
main_dish = Function([flavorings] -> [bool])
# Constraints
ForAll([f:flavorings], Or(appetizer(f), main_dish(f))) ::: Together the two recipes must include exactly seven flavorings
ForAll([f:flavorings], Not(And(appetizer(f), main_dish(f)))) ::: No flavoring included in more than one of the two recipes
Count([f:flavorings], appetizer(f)) <= 3 ::: The appetizer recipe includes at most three of the flavorings
Not(And(appetizer(fenugreek), appetizer(nutmeg))) ::: Fenugreek is not included in the same recipe as nutmeg
Not(And(appetizer(saffron), appetizer(turmeric))) ::: Saffron is not included in the same recipe as turmeric
And(appetizer(ginger), appetizer(nutmeg)) ::: Ginger is included in the same recipe as nutmeg
# Options
is_sat(And(appetizer(fenugreek), appetizer(saffron))) ::: (A)
is_sat(And(appetizer(ginger), appetizer(nutmeg))) ::: (B)
is_sat(And(appetizer(fenugreek), appetizer(nutmeg), appetizer(turmeric))) ::: (C)
is_sat(And(appetizer(lemongrass), appetizer(nutmeg), appetizer(saffron))) ::: (D)
is_sat(And(appetizer(fenugreek), appetizer(lemongrass), appetizer(paprika), appetizer(turmeric))) ::: (E)"
"# Context:
Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.

# Question:
If the condition that exactly two persons go to a soccer game is changed to require that exactly three persons go to a soccer game, but all other conditions remain the same, then which one of the following persons must participate in an activity other than going to a soccer game?

# Options:
A) Nguyen
B) Olson
C) Pike
D) Tyner
E) Valdez","# Declarations
persons = EnumSort([Nguyen, Olson, Pike, Tyner, Valdez])
activities = EnumSort([movie, soccer, restaurant])
participates = Function([persons] -> [activities])
# Constraints
ForAll([p:persons], Exists([a:activities], participates(p) == a)) ::: Each person participates in exactly one activity
participates(Nguyen) != participates(Olson) ::: Nguyen and Olson do not participate in the same activity as each other
participates(Nguyen) != participates(Pike) ::: Nguyen does not participate in the same activity as Pike
participates(Olson) != participates(Pike) ::: Olson does not participate in the same activity as Pike
Count([p:persons], participates(p) == soccer) == 3 ::: Exactly three persons go to a soccer game
participates(Tyner) != participates(Pike) ::: Tyner and Pike do not participate in the same activity as each other
Implies(Or(participates(Nguyen) == movie, participates(Valdez) == movie), And(participates(Nguyen) == movie, participates(Valdez) == movie)) ::: If Nguyen or Valdez goes to a movie, they both go to a movie
# Options
is_valid(participates(Nguyen) != soccer) ::: (A)
is_valid(participates(Olson) != soccer) ::: (B)
is_valid(participates(Pike) != soccer) ::: (C)
is_valid(participates(Tyner) != soccer) ::: (D)
is_valid(participates(Valdez) != soccer) ::: (E)"
"# Context:
Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.

# Question:
If G is assigned to team 1, which one of the following is a pair of jugglers who could also be assigned to team 1?

# Options:
A) H and N
B) K and L
C) K and P
D) L and N
E) L and Q","# Declarations
jugglers = EnumSort([G, H, K, L, N, P, Q])
positions = EnumSort([front, middle, rear])
teams = EnumSort([team1, team2])
assigned_team = Function([jugglers] -> [teams])
assigned_position = Function([jugglers] -> [positions])
# Constraints
ForAll([t:teams], And(Exists([j:jugglers], assigned_team(j) == t), ForAll([p:positions], Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == p))))) ::: For each team, exactly one juggler must be assigned to each position
Implies(Or(assigned_team(G) != None, assigned_team(H) != None), And(assigned_position(G) == front, assigned_position(H) == front)) ::: If either G or H or both are assigned to teams, they are assigned to front positions
Implies(assigned_team(K) != None, assigned_position(K) == middle) ::: If assigned to a team, K is assigned to a middle position
Implies(assigned_team(L) != None, assigned_team(L) == team1) ::: If assigned to a team, L is assigned to team 1
And(assigned_team(P) != assigned_team(N), assigned_team(K) != assigned_team(N)) ::: Neither P nor K is on the same team as N
assigned_team(P) != assigned_team(Q) ::: P is not on the same team as Q
Implies(assigned_team(H) == team2, And(assigned_team(Q) == team1, assigned_position(Q) == middle)) ::: If H is on team 2, then Q is assigned to the middle position on team 1
assigned_team(G) == team1 ::: If G is assigned to team 1
# Options
is_valid(And(assigned_team(H) == team1, assigned_team(N) == team1)) ::: (A)
is_valid(And(assigned_team(K) == team1, assigned_team(L) == team1)) ::: (B)
is_valid(And(assigned_team(K) == team1, assigned_team(P) == team1)) ::: (C)
is_valid(And(assigned_team(L) == team1, assigned_team(N) == team1)) ::: (D)
is_valid(And(assigned_team(L) == team1, assigned_team(Q) == team1)) ::: (E)"
"# Context:
Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.

# Question:
If G is assigned to team 1 and K is assigned to team 2, which one of the following must be assigned the rear position on team 2?

# Options:
A) H
B) L
C) N
D) P
E) Q","# Declarations
jugglers = EnumSort([G, H, K, L, N, P, Q])
positions = EnumSort([front, middle, rear])
teams = EnumSort([team1, team2])
assigned_team = Function([jugglers] -> [teams])
assigned_position = Function([jugglers] -> [positions])
# Constraints
ForAll([t:teams], And(Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == front)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == middle)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == rear)))) ::: For each team, exactly one juggler must be assigned to each position
Implies(Or(assigned_team(G) != None, assigned_team(H) != None), And(assigned_position(G) == front, assigned_position(H) == front)) ::: If either G or H or both are assigned to teams, they are assigned to front positions
Implies(assigned_team(K) != None, assigned_position(K) == middle) ::: If assigned to a team, K is assigned to a middle position
Implies(assigned_team(L) != None, assigned_team(L) == team1) ::: If assigned to a team, L is assigned to team 1
And(assigned_team(P) != assigned_team(N), assigned_team(K) != assigned_team(N)) ::: Neither P nor K is on the same team as N
assigned_team(P) != assigned_team(Q) ::: P is not on the same team as Q
Implies(assigned_team(H) == team2, And(assigned_team(Q) == team1, assigned_position(Q) == middle)) ::: If H is on team 2, then Q is assigned to the middle position on team 1
assigned_team(G) == team1 ::: G is assigned to team 1
assigned_team(K) == team2 ::: K is assigned to team 2
# Options
is_valid(And(assigned_team(H) == team2, assigned_position(H) == rear)) ::: (A)
is_valid(And(assigned_team(L) == team2, assigned_position(L) == rear)) ::: (B)
is_valid(And(assigned_team(N) == team2, assigned_position(N) == rear)) ::: (C)
is_valid(And(assigned_team(P) == team2, assigned_position(P) == rear)) ::: (D)
is_valid(And(assigned_team(Q) == team2, assigned_position(Q) == rear)) ::: (E)"
"# Context:
Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.

# Question:
Of the boats, what are, respectively, the minimum number and the maximum number that could have arrived before Kashmir?

# Options:
A) one, five
B) two, five
C) three, five
D) one, six
E) two, six","# Declarations
boats = EnumSort([Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, Valhalla])
arrival_order = Function([boats] -> [int])
# Constraints
arrival_order(Tornado) > arrival_order(Jewel) ::: Tornado arrived before Spain but after Jewel
arrival_order(Neptune) < arrival_order(Tornado) ::: Neptune arrived before Tornado
arrival_order(Kashmir) > arrival_order(Jewel) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Kashmir) < arrival_order(Spain) ::: Kashmir arrived after Jewel but before Spain
arrival_order(Spain) < arrival_order(Ojibwa) ::: Spain arrived before Ojibwa
ForAll([b1:boats, b2:boats], Implies(b1 != b2, arrival_order(b1) != arrival_order(b2))) ::: No boat arrived at the same time as any other boat
# Options
is_accurate_list([Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 1, Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 5]) ::: (A)
is_accurate_list([Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 2, Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 5]) ::: (B)
is_accurate_list([Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 3, Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 5]) ::: (C)
is_accurate_list([Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 1, Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 6]) ::: (D)
is_accurate_list([Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 2, Count([b:boats], arrival_order(b) < arrival_order(Kashmir)) == 6]) ::: (E)"
"# Context:
Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.

# Question:
If Harry, Irene, Michael, and Norma all speak the same language as each other, then which one of the following could be true?

# Options:
A) Klaus speaks Russian.
B) Exactly two of the tourists speak Russian.
C) Exactly three of the tourists speak Spanish.
D) Exactly two of the tourists speak Turkish.
E) Klaus speaks French.","# Declarations
tourists = EnumSort([Harry, Irene, Klaus, Laura, Michael, Norma])
guides = EnumSort([Valois, Xerxes, Yossarian, Zalamea])
languages = EnumSort([French, Turkish, Spanish, Russian])
assigned = Function([tourists] -> [guides])
speaks = Function([tourists] -> [languages])
# Constraints
ForAll([g:guides], Exists([t:tourists], assigned(t) == g)) ::: at least one tourist assigned to each guide
ForAll([t:tourists], Exists([g:guides], assigned(t) == g)) ::: each tourist is assigned to exactly one guide
assigned(Harry) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Irene) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Laura) == Zalamea ::: at least Laura is assigned to Zalamea
Implies(assigned(Klaus) == Xerxes, speaks(Michael) == French) ::: if Klaus is assigned to Xerxes, then Michael speaks French
ForAll([t:tourists], speaks(t) == French) ::: Harry, Irene, Michael, and Norma all speak the same language as each other
# Options
is_valid(speaks(Klaus) == Russian) ::: (A)
is_valid(Count([t:tourists], speaks(t) == Russian) == 2) ::: (B)
is_valid(Count([t:tourists], speaks(t) == Spanish) == 3) ::: (C)
is_valid(Count([t:tourists], speaks(t) == Turkish) == 2) ::: (D)
is_valid(speaks(Klaus) == French) ::: (E)"
"# Context:
Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.

# Question:
If Nguyen goes to a soccer game, then which one of the following is a complete and accurate list of the persons any one of whom could go to a movie?

# Options:
A) Olson
B) Pike, Valdez
C) Olson, Tyner
D) Pike, Tyner, Valdez
E) Olson, Pike, Tyner","# Declarations
persons = EnumSort([Nguyen, Olson, Pike, Tyner, Valdez])
activities = EnumSort([movie, soccer, restaurant])
participates = Function([persons] -> [activities])
# Constraints
ForAll([p:persons], Exists([a:activities], participates(p) == a)) ::: Each person participates in exactly one activity
participates(Nguyen) != participates(Olson) ::: Nguyen and Olson do not participate in the same activity as each other
participates(Nguyen) != participates(Pike) ::: Nguyen does not participate in the same activity as Pike
participates(Olson) != participates(Pike) ::: Olson does not participate in the same activity as Pike
Count([p:persons], participates(p) == soccer) == 2 ::: Exactly two persons go to a soccer game
participates(Tyner) != participates(Pike) ::: Tyner and Pike do not participate in the same activity as each other
Implies(Or(participates(Nguyen) == movie, participates(Valdez) == movie), And(participates(Nguyen) == movie, participates(Valdez) == movie)) ::: If Nguyen or Valdez goes to a movie, they both go to a movie
participates(Nguyen) == soccer ::: If Nguyen goes to a soccer game
# Options
is_accurate_list([participates(Olson) == movie]) ::: (A)
is_accurate_list([participates(Pike) == movie, participates(Valdez) == movie]) ::: (B)
is_accurate_list([participates(Olson) == movie, participates(Tyner) == movie]) ::: (C)
is_accurate_list([participates(Pike) == movie, participates(Tyner) == movie, participates(Valdez) == movie]) ::: (D)
is_accurate_list([participates(Olson) == movie, participates(Pike) == movie, participates(Tyner) == movie]) ::: (E)"
"# Context:
Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.

# Question:
If car 4 is purple, which one of the following must be true?

# Options:
A) Car 1 is orange.
B) Car 2 is green.
C) Car 3 is orange.
D) Car 5 is green.
E) Car 6 is purple.","# Declarations
cars = EnumSort([car1, car2, car3, car4, car5, car6])
colors = EnumSort([green, orange, purple])
color = Function([cars] -> [colors])
# Constraints
Count([c:cars], color(c) == green) == 2 ::: two cars are green
Count([c:cars], color(c) == orange) == 2 ::: two cars are orange
Count([c:cars], color(c) == purple) == 2 ::: two cars are purple
ForAll([c:cars], Implies(c != car1, color(c) != color(car1))) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], Implies(c != car2, color(c) != color(car2))) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], Implies(c != car3, color(c) != color(car3))) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], Implies(c != car4, color(c) != color(car4))) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], Implies(c != car5, color(c) != color(car5))) ::: No car can be the same color as any car next to it in line
ForAll([c:cars], Implies(c != car6, color(c) != color(car6))) ::: No car can be the same color as any car next to it in line
Or(color(car5) == purple, color(car6) == purple) ::: Either car 5 or car 6 must be purple
color(car1) != orange ::: Car 1 cannot be orange
color(car4) != green ::: Car 4 cannot be green
color(car4) == purple ::: If car 4 is purple
# Options
is_valid(color(car1) == orange) ::: (A)
is_valid(color(car2) == green) ::: (B)
is_valid(color(car3) == orange) ::: (C)
is_valid(color(car5) == green) ::: (D)
is_valid(color(car6) == purple) ::: (E)"
"# Context:
The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.

# Question:
Which one of the following represents an acceptable selection of volunteers for the committees?

# Options:
A) planting: F, G, H; trails: G, J, K, L
B) planting: F, H, J; trails: G, H, L, M
C) planting: F, H, M; trails: G, K, L, M
D) planting: F, G, L, M; trails: F, H
E) planting: F, H, J, K; trails: H, L, M","# Declarations
volunteers = EnumSort([F, G, H, J, K, L, M])
committees = EnumSort([planting, trails])
member = Function([volunteers, committees] -> [bool])
# Constraints
ForAll([c:committees], Count([v:volunteers], member(v, c)) >= 3) ::: Each committee must have at least three members
Not(And(member(F, planting), member(K, planting))) ::: F cannot be on the same committee as K
Not(And(member(F, trails), member(K, trails))) ::: F cannot be on the same committee as K
Implies(member(K, planting), member(J, planting)) ::: If K is on a committee, J must also be on that committee
Implies(member(K, trails), member(J, trails)) ::: If K is on a committee, J must also be on that committee
Or(member(M, planting), member(M, trails)) ::: M must be on at least one of the committees
Exists([v:volunteers], And(member(v, planting), member(v, trails))) ::: The two committees must have at least one member in common
# Options
is_sat(And(member(F, planting), member(G, planting), member(H, planting), member(G, trails), member(J, trails), member(K, trails), member(L, trails))) ::: (A)
is_sat(And(member(F, planting), member(H, planting), member(J, planting), member(G, trails), member(H, trails), member(L, trails), member(M, trails))) ::: (B)
is_sat(And(member(F, planting), member(H, planting), member(M, planting), member(G, trails), member(K, trails), member(L, trails), member(M, trails))) ::: (C)
is_sat(And(member(F, planting), member(G, planting), member(L, planting), member(M, planting), member(F, trails), member(H, trails))) ::: (D)
is_sat(And(member(F, planting), member(H, planting), member(J, planting), member(K, planting), member(H, trails), member(L, trails), member(M, trails))) ::: (E)"
"# Context:
At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.

# Question:
Which one of the following must be true about the program?

# Options:
A) George performs X.
B) Helen performs O.
C) Helen performs T.
D) Leslie performs P.
E) Leslie performs X.","# Declarations
songs = EnumSort([O, P, T, X, Y, Z])
vocalists = EnumSort([George, Helen, Leslie])
performed = Function([songs] -> [vocalists])
order = Function([songs] -> [int])
# Constraints
ForAll([s:songs], Exists([v:vocalists], performed(s) == v)) ::: Each song will be performed exactly once
ForAll([s:songs], Exists([i:int], order(s) == i)) ::: Each song will be performed in a specific order
ForAll([s1:songs, s2:songs], Implies(order(s1) < order(s2), order(s1) != order(s2))) ::: Songs will be performed consecutively
order(Y) < order(T) ::: Y must be performed earlier than T
order(Y) < order(O) ::: Y must be performed earlier than O
order(P) < order(Z) ::: P must be performed earlier than Z
order(O) < order(P) ::: P must be performed later than O
ForAll([s:songs], Implies(performed(s) == George, Or(s == X, s == Y, s == Z))) ::: George can perform only X, Y, and Z
ForAll([s:songs], Implies(performed(s) == Helen, Or(s == T, s == P, s == X))) ::: Helen can perform only T, P, and X
ForAll([s:songs], Implies(performed(s) == Leslie, Or(s == O, s == P, s == X))) ::: Leslie can perform only O, P, and X
performed(songs[0]) != performed(songs[5]) ::: The vocalist who performs first must be different from the vocalist who performs last
# Options
is_valid(performed(X) == George) ::: (A)
is_valid(performed(O) == Helen) ::: (B)
is_valid(performed(T) == Helen) ::: (C)
is_valid(performed(P) == Leslie) ::: (D)
is_valid(performed(X) == Leslie) ::: (E)"
"# Context:
Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.

# Question:
If Wanda is assigned to a lower-numbered bench than is Joan, then Henry must be assigned to a

# Options:
A) lower-numbered bench than is Frank
B) lower-numbered bench than is Gwen
C) lower-numbered bench than is Xavier
D) higher-numbered bench than is Victor
E) higher-numbered bench than is Yvette","# Declarations
students = EnumSort([Frank, Gwen, Henry, Joan, Victor, Wanda, Xavier, Yvette])
majors = EnumSort([Frank, Gwen, Henry, Joan])
nonmajors = EnumSort([Victor, Wanda, Xavier, Yvette])
benches = EnumSort([1, 2, 3, 4])
assigned = Function([students] -> [benches])
# Constraints
ForAll([b:benches], Count([s:students], assigned(s) == b) == 2) ::: exactly two students are assigned to each bench
ForAll([b:benches], Count([m:majors], assigned(m) == b) == 1) ::: exactly one major is assigned to each bench
assigned(Frank) == assigned(Victor) ::: Frank is assigned to the same bench as Victor
assigned(Gwen) != assigned(Wanda) ::: Gwen is not assigned to the same bench as Wanda
assigned(Frank) == assigned(Joan) - 1 ::: Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench
assigned(Wanda) < assigned(Joan) ::: Wanda is assigned to a lower-numbered bench than is Joan
# Options
is_valid(assigned(Henry) < assigned(Frank)) ::: (A)
is_valid(assigned(Henry) < assigned(Gwen)) ::: (B)
is_valid(assigned(Henry) < assigned(Xavier)) ::: (C)
is_valid(assigned(Henry) > assigned(Victor)) ::: (D)
is_valid(assigned(Henry) > assigned(Yvette)) ::: (E)"
"# Context:
A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.

# Question:
Which one of the following CANNOT be the complete housing arrangement for habitats 1 and 2?

# Options:
A) 1: one female snake, one male snake; 2: one male snake
B) 1: one male lizard; 2: one male snake
C) 1: two female lizards; 2: one female snake
D) 1: one male snake; 2: empty
E) 1: empty; 2: one female lizard","# Declarations
habitats = EnumSort([1, 2, 3, 4, 5])
reptiles = EnumSort([snake1, snake2, snake3, snake4, lizard1, lizard2, lizard3])
genders = EnumSort([male, female])
species = EnumSort([snake, lizard])
housed = Function([reptiles] -> [habitats])
reptile_gender = Function([reptiles] -> [genders])
reptile_species = Function([reptiles] -> [species])
# Constraints
ForAll([h:habitats], Count([r:reptiles], housed(r) == h) <= 2) ::: No habitat houses more than two reptiles
ForAll([h:habitats], ForAll([r1:reptiles, r2:reptiles], Implies(And(housed(r1) == h, housed(r2) == h, reptile_species(r1) != reptile_species(r2)), r1 == r2))) ::: No habitat houses both a snake and a lizard
ForAll([r:reptiles], Implies(And(reptile_species(r) == snake, reptile_gender(r) == female), ForAll([h:habitats], Implies(housed(r) == h, And(ForAll([r2:reptiles], Implies(And(reptile_species(r2) == lizard, reptile_gender(r2) == male, Or(housed(r2) == h + 1, housed(r2) == h - 1)), False)), ForAll([r3:reptiles], Implies(And(reptile_species(r3) == lizard, reptile_gender(r3) == male, Or(housed(r3) == h + 1, housed(r3) == h - 1)), False))))))) ::: No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard
# Options
is_unsat(And(Count([r:reptiles], And(housed(r) == 1, reptile_gender(r) == female, reptile_species(r) == snake)) == 1, Count([r:reptiles], And(housed(r) == 1, reptile_gender(r) == male, reptile_species(r) == snake)) == 1, Count([r:reptiles], And(housed(r) == 2, reptile_gender(r) == male, reptile_species(r) == snake)) == 1)) ::: (A)
is_unsat(And(Count([r:reptiles], And(housed(r) == 1, reptile_gender(r) == male, reptile_species(r) == lizard)) == 1, Count([r:reptiles], And(housed(r) == 2, reptile_gender(r) == male, reptile_species(r) == snake)) == 1)) ::: (B)
is_unsat(And(Count([r:reptiles], And(housed(r) == 1, reptile_gender(r) == female, reptile_species(r) == lizard)) == 2, Count([r:reptiles], And(housed(r) == 2, reptile_gender(r) == female, reptile_species(r) == snake)) == 1)) ::: (C)
is_unsat(And(Count([r:reptiles], And(housed(r) == 1, reptile_gender(r) == male, reptile_species(r) == snake)) == 1, Count([r:reptiles], housed(r) == 2) == 0)) ::: (D)
is_unsat(And(Count([r:reptiles], housed(r) == 1) == 0, Count([r:reptiles], And(housed(r) == 2, reptile_gender(r) == female, reptile_species(r) == lizard)) == 1)) ::: (E)"
"# Context:
Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.

# Question:
Each of the following statements must be false EXCEPT:

# Options:
A) Only Olson goes to a restaurant.
B) Only Pike goes to a restaurant.
C) Only Tyner goes to a restaurant.
D) Only Valdez goes to a restaurant.
E) Tyner and Valdez go to a restaurant together.","# Declarations
persons = EnumSort([Nguyen, Olson, Pike, Tyner, Valdez])
activities = EnumSort([movie, soccer, restaurant])
participates = Function([persons] -> [activities])
# Constraints
ForAll([p:persons], Exists([a:activities], participates(p) == a)) ::: Each person participates in exactly one activity
participates(Nguyen) != participates(Olson) ::: Nguyen and Olson do not participate in the same activity as each other
participates(Nguyen) != participates(Pike) ::: Nguyen does not participate in the same activity as Pike
participates(Olson) != participates(Pike) ::: Olson does not participate in the same activity as Pike
Count([p:persons], participates(p) == soccer) == 2 ::: Exactly two persons go to a soccer game
participates(Tyner) != participates(Pike) ::: Tyner and Pike do not participate in the same activity as each other
Implies(Or(participates(Nguyen) == movie, participates(Valdez) == movie), And(participates(Nguyen) == movie, participates(Valdez) == movie)) ::: If Nguyen or Valdez goes to a movie, they both go to a movie
# Options
is_unsat(ForAll([p:persons], Implies(p != Olson, participates(p) != restaurant))) ::: (A) Only Olson goes to a restaurant
is_unsat(ForAll([p:persons], Implies(p != Pike, participates(p) != restaurant))) ::: (B) Only Pike goes to a restaurant
is_unsat(ForAll([p:persons], Implies(p != Tyner, participates(p) != restaurant))) ::: (C) Only Tyner goes to a restaurant
is_unsat(ForAll([p:persons], Implies(p != Valdez, participates(p) != restaurant))) ::: (D) Only Valdez goes to a restaurant
is_sat(And(participates(Tyner) == restaurant, participates(Valdez) == restaurant)) ::: (E) Tyner and Valdez go to a restaurant together"
"# Context:
Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.

# Question:
If car 2 is the same color as car 4, then which one of the following statements must be true?

# Options:
A) Car 1 is purple.
B) Car 2 is orange.
C) Car 3 is green.
D) Car 5 is purple.
E) Car 6 is green","# Declarations
cars = EnumSort([1, 2, 3, 4, 5, 6])
colors = EnumSort([green, orange, purple])
color = Function([cars] -> [colors])
# Constraints
Count([c:cars], color(c) == green) == 2 ::: two cars are green
Count([c:cars], color(c) == orange) == 2 ::: two cars are orange
Count([c:cars], color(c) == purple) == 2 ::: two cars are purple
ForAll([c:cars], Implies(c != 6, color(c) != color(c + 1))) ::: No car can be the same color as any car next to it in line
Or(color(5) == purple, color(6) == purple) ::: Either car 5 or car 6 must be purple
color(1) != orange ::: Car 1 cannot be orange
color(4) != green ::: Car 4 cannot be green
color(2) == color(4) ::: If car 2 is the same color as car 4
# Options
is_valid(color(1) == purple) ::: (A)
is_valid(color(2) == orange) ::: (B)
is_valid(color(3) == green) ::: (C)
is_valid(color(5) == purple) ::: (D)
is_valid(color(6) == green) ::: (E)"
"# Context:
Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.

# Question:
The cars in which one of the following pairs CANNOT be the same color as each other?

# Options:
A) cars 1 and 4
B) cars 1 and 5
C) cars 3 and 5
D) cars 3 and 6
E) cars 4 and 6","# Declarations
cars = EnumSort([car1, car2, car3, car4, car5, car6])
colors = EnumSort([green, orange, purple])
color = Function([cars] -> [colors])
# Constraints
ForAll([c:cars], Exists([c1:cars], And(c1 != c, color(c1) != color(c)))) ::: No car can be the same color as any car next to it in line
Or(color(car5) == purple, color(car6) == purple) ::: Either car 5 or car 6 must be purple
color(car1) != orange ::: Car 1 cannot be orange
color(car4) != green ::: Car 4 cannot be green
# Options
is_unsat(color(car1) == color(car4)) ::: (A)
is_unsat(color(car1) == color(car5)) ::: (B)
is_unsat(color(car3) == color(car5)) ::: (C)
is_unsat(color(car3) == color(car6)) ::: (D)
is_unsat(color(car4) == color(car6)) ::: (E)"
"# Context:
Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.

# Question:
If exactly two tourists are assigned to Xerxes, then which one of the following could be true?

# Options:
A) Norma speaks Russian and Laura speaks Russian.
B) Norma speaks French and Michael speaks French.
C) Norma speaks French and Klaus speaks Turkish.
D) Michael speaks Spanish and Klaus speaks Spanish.
E) Michael speaks French and Klaus speaks Spanish.","# Declarations
tourists = EnumSort([Harry, Irene, Klaus, Laura, Michael, Norma])
guides = EnumSort([Valois, Xerxes, Yossarian, Zalamea])
languages = EnumSort([French, Turkish, Spanish, Russian])
assigned = Function([tourists] -> [guides])
speaks = Function([tourists] -> [languages])
# Constraints
ForAll([g:guides], Exists([t:tourists], assigned(t) == g)) ::: at least one tourist assigned to each guide
ForAll([t:tourists], Exists([g:guides], assigned(t) == g)) ::: each tourist is assigned to exactly one guide
assigned(Harry) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Irene) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Laura) == Zalamea ::: at least Laura is assigned to Zalamea
Implies(assigned(Klaus) == Xerxes, speaks(Michael) == French) ::: if Klaus is assigned to Xerxes, then Michael speaks French
ForAll([t:tourists], Implies(assigned(t) == Valois, speaks(t) == French)) ::: Valois speaks only French
ForAll([t:tourists], Implies(assigned(t) == Xerxes, Or(speaks(t) == Turkish, speaks(t) == Spanish))) ::: Xerxes speaks only Turkish and Spanish
ForAll([t:tourists], Implies(assigned(t) == Yossarian, Or(speaks(t) == French, speaks(t) == Turkish))) ::: Yossarian speaks only French and Turkish
ForAll([t:tourists], Implies(assigned(t) == Zalamea, Or(speaks(t) == Spanish, speaks(t) == Russian))) ::: Zalamea speaks only Spanish and Russian
Count([t:tourists], assigned(t) == Xerxes) == 2 ::: exactly two tourists are assigned to Xerxes
# Options
is_valid(And(speaks(Norma) == Russian, speaks(Laura) == Russian)) ::: (A)
is_valid(And(speaks(Norma) == French, speaks(Michael) == French)) ::: (B)
is_valid(And(speaks(Norma) == French, speaks(Klaus) == Turkish)) ::: (C)
is_valid(And(speaks(Michael) == Spanish, speaks(Klaus) == Spanish)) ::: (D)
is_valid(And(speaks(Michael) == French, speaks(Klaus) == Spanish)) ::: (E)"
"# Context:
At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.

# Question:
Which one of the following is an acceptable schedule for the performance of the songs, in order from the first to last song performed?

# Options:
A) X, T, Y, O, P, Z
B) X, Z, Y, T, O, P
C) Y, O, P, X, T, Z
D) Y, P, O, Z, T, X
E) Y, X, O, P, Z, T","# Declarations
songs = EnumSort([O, P, T, X, Y, Z])
vocalists = EnumSort([George, Helen, Leslie])
perform = Function([songs] -> [vocalists])
order = Function([songs] -> [int])
# Constraints
ForAll([s:songs], Exists([s1:songs], And(s1 != s, order(s1) < order(s)))) ::: The songs will be sung consecutively as solos, and each will be performed exactly once
order(Y) < order(T) ::: Y must be performed earlier than T
order(Y) < order(O) ::: Y must be performed earlier than O
order(P) < order(Z) ::: P must be performed earlier than Z
order(O) < order(P) ::: P must be performed later than O
ForAll([s:songs], Or(perform(s) == George, perform(s) == Helen, perform(s) == Leslie)) ::: Each song is performed by one of the three vocalists
ForAll([s:songs], Implies(perform(s) == George, Or(s == X, s == Y, s == Z))) ::: George can perform only X, Y, and Z
ForAll([s:songs], Implies(perform(s) == Helen, Or(s == T, s == P, s == X))) ::: Helen can perform only T, P, and X
ForAll([s:songs], Implies(perform(s) == Leslie, Or(s == O, s == P, s == X))) ::: Leslie can perform only O, P, and X
perform(songs[0]) != perform(songs[5]) ::: The vocalist who performs first must be different from the vocalist who performs last
# Options
is_sat(And(order(X) == 0, order(T) == 1, order(Y) == 2, order(O) == 3, order(P) == 4, order(Z) == 5)) ::: (A)
is_sat(And(order(X) == 0, order(Z) == 1, order(Y) == 2, order(T) == 3, order(O) == 4, order(P) == 5)) ::: (B)
is_sat(And(order(Y) == 0, order(O) == 1, order(P) == 2, order(X) == 3, order(T) == 4, order(Z) == 5)) ::: (C)
is_sat(And(order(Y) == 0, order(P) == 1, order(O) == 2, order(Z) == 3, order(T) == 4, order(X) == 5)) ::: (D)
is_sat(And(order(Y) == 0, order(X) == 1, order(O) == 2, order(P) == 3, order(Z) == 4, order(T) == 5)) ::: (E)"
"# Context:
Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.

# Question:
Which one of the following is an acceptable list of assignments of jugglers to team 1?

# Options:
A) front: G; middle: K; rear: L
B) front: G; middle: K; rear: P
C) front: L; middle: K; rear: Q
D) front: Q; middle: K; rear: P
E) front: Q; middle: L; rear: N","# Declarations
jugglers = EnumSort([G, H, K, L, N, P, Q])
positions = EnumSort([front, middle, rear])
teams = EnumSort([team1, team2])
assigned_position = Function([jugglers] -> [positions])
assigned_team = Function([jugglers] -> [teams])
# Constraints
ForAll([t:teams], And(Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == front)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == middle)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == rear)))) ::: For each team, exactly one juggler must be assigned to each position
Implies(Or(assigned_team(G) != None, assigned_team(H) != None), And(assigned_position(G) == front, assigned_position(H) == front)) ::: If either G or H or both are assigned to teams, they are assigned to front positions
Implies(assigned_team(K) != None, assigned_position(K) == middle) ::: If assigned to a team, K is assigned to a middle position
Implies(assigned_team(L) != None, assigned_team(L) == team1) ::: If assigned to a team, L is assigned to team 1
And(assigned_team(P) != assigned_team(N), assigned_team(K) != assigned_team(N)) ::: Neither P nor K is on the same team as N
assigned_team(P) != assigned_team(Q) ::: P is not on the same team as Q
Implies(assigned_team(H) == team2, And(assigned_team(Q) == team1, assigned_position(Q) == middle)) ::: If H is on team 2, then Q is assigned to the middle position on team 1
# Options
is_accurate_list([And(assigned_team(G) == team1, assigned_position(G) == front), And(assigned_team(K) == team1, assigned_position(K) == middle), And(assigned_team(L) == team1, assigned_position(L) == rear)]) ::: (A)
is_accurate_list([And(assigned_team(G) == team1, assigned_position(G) == front), And(assigned_team(K) == team1, assigned_position(K) == middle), And(assigned_team(P) == team1, assigned_position(P) == rear)]) ::: (B)
is_accurate_list([And(assigned_team(L) == team1, assigned_position(L) == front), And(assigned_team(K) == team1, assigned_position(K) == middle), And(assigned_team(Q) == team1, assigned_position(Q) == rear)]) ::: (C)
is_accurate_list([And(assigned_team(Q) == team1, assigned_position(Q) == front), And(assigned_team(K) == team1, assigned_position(K) == middle), And(assigned_team(P) == team1, assigned_position(P) == rear)]) ::: (D)
is_accurate_list([And(assigned_team(Q) == team1, assigned_position(Q) == front), And(assigned_team(L) == team1, assigned_position(L) == middle), And(assigned_team(N) == team1, assigned_position(N) == rear)]) ::: (E)"
"# Context:
Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.

# Question:
Which one of the following is a pair of persons who could go to a movie together?

# Options:
A) Nguyen and Tyner
B) Olson and Tyner
C) Olson and Valdez
D) Pike and Olson
E) Pike and Tyner","# Declarations
persons = EnumSort([Nguyen, Olson, Pike, Tyner, Valdez])
activities = EnumSort([movie, soccer, restaurant])
participates = Function([persons] -> [activities])
# Constraints
ForAll([p:persons], Exists([a:activities], participates(p) == a)) ::: Each person participates in exactly one activity
participates(Nguyen) != participates(Olson) ::: Nguyen and Olson do not participate in the same activity as each other
participates(Nguyen) != participates(Pike) ::: Nguyen does not participate in the same activity as Pike
participates(Olson) != participates(Pike) ::: Olson does not participate in the same activity as Pike
Count([p:persons], participates(p) == soccer) == 2 ::: Exactly two persons go to a soccer game
participates(Tyner) != participates(Pike) ::: Tyner and Pike do not participate in the same activity as each other
Implies(Or(participates(Nguyen) == movie, participates(Valdez) == movie), And(participates(Nguyen) == movie, participates(Valdez) == movie)) ::: If Nguyen or Valdez goes to a movie, they both go to a movie
# Options
is_sat(And(participates(Nguyen) == movie, participates(Tyner) == movie)) ::: (A)
is_sat(And(participates(Olson) == movie, participates(Tyner) == movie)) ::: (B)
is_sat(And(participates(Olson) == movie, participates(Valdez) == movie)) ::: (C)
is_sat(And(participates(Pike) == movie, participates(Olson) == movie)) ::: (D)
is_sat(And(participates(Pike) == movie, participates(Tyner) == movie)) ::: (E)"
"# Context:
Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.

# Question:
If G presents product P on Wednesday, then any of the following could be true EXCEPT:

# Options:
A) H presents product O.
B) I presents product N.
C) I presents product O.
D) F makes a presentation on Monday.
E) F makes a presentation on Wednesday.","# Declarations
salespeople = EnumSort([F, G, H, I, J])
products = EnumSort([L, M, N, O, P])
days = EnumSort([Monday, Tuesday, Wednesday])
presents = Function([salespeople] -> [products])
scheduled = Function([products] -> [days])
# Constraints
Count([p:products], scheduled(p) == Monday) == 2 ::: Exactly two products will be presented on Monday
Count([p:products], scheduled(p) == Tuesday) == 1 ::: Exactly one product will be presented on Tuesday
Count([p:products], scheduled(p) == Wednesday) == 2 ::: Exactly two products will be presented on Wednesday
ForAll([s:salespeople], ForAll([s1:salespeople], Implies(s != s1, presents(s) != presents(s1)))) ::: Each salesperson presents a different product
ForAll([s:salespeople], ForAll([s1:salespeople], Implies(s != s1, scheduled(presents(s)) != scheduled(presents(s1))))) ::: Each salesperson presents on a different day
scheduled(presents(G)) == Wednesday ::: G presents product P on Wednesday
scheduled(presents(G)) == scheduled(O) ::: G must present a product on the day that product O is presented
Or(scheduled(N) == Tuesday, scheduled(N) == Wednesday) ::: Either I or else J must present product N on Tuesday
ForAll([s:salespeople], Implies(s == I, scheduled(N) == Tuesday)) ::: Either I or else J must present product N on Tuesday
ForAll([s:salespeople], Implies(s == J, scheduled(N) == Tuesday)) ::: Either I or else J must present product N on Tuesday
ForAll([s:salespeople], Implies(s == F, scheduled(presents(F)) != scheduled(presents(H)))) ::: F cannot present a product on the same day as H
# Options
is_unsat(scheduled(O) == scheduled(presents(H))) ::: (A)
is_unsat(scheduled(N) == scheduled(presents(I))) ::: (B)
is_unsat(scheduled(O) == scheduled(presents(I))) ::: (C)
is_unsat(scheduled(presents(F)) == Monday) ::: (D)
is_unsat(scheduled(presents(F)) == Wednesday) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
Which one of the following is an acceptable selection of rugs for the exhibition?

# Options:
A) one oval silk rug, one oval wool rug, and two rectangular wool rugs
B) one oval silk rug, one rectangular wool rug, and two rectangular silk rugs
C) two oval wool rugs, one rectangular silk rug, and two rectangular wool rugs
D) two oval wool rugs, one rectangular silk rug, and one rectangular wool rug
E) two rectangular silk rugs and three rectangular wool rugs","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rect_wool1, rect_wool2, rect_wool3, oval_silk, rect_silk1, rect_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: The coordinator will select at least four rugs
Count([r:rugs], selected(r)) <= 6 ::: The coordinator will select at most six rugs
Count([r:rugs], And(r == oval_wool1, selected(r))) + Count([r:rugs], And(r == oval_wool2, selected(r))) >= 2 ::: At least two oval rugs must be selected
Count([r:rugs], And(Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3), selected(r))) >= 2 ::: The number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3), selected(r))) <= 3 ::: The number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Count([r:rugs], And(Or(r == rect_silk1, r == rect_silk2), selected(r))) >= 1) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected
# Options
is_sat(And(selected(oval_silk), selected(oval_wool1), selected(rect_wool1), selected(rect_wool2))) ::: (A)
is_sat(And(selected(oval_silk), selected(rect_wool1), selected(rect_silk1), selected(rect_silk2))) ::: (B)
is_sat(And(selected(oval_wool1), selected(oval_wool2), selected(rect_silk1), selected(rect_wool1), selected(rect_wool2))) ::: (C)
is_sat(And(selected(oval_wool1), selected(oval_wool2), selected(rect_silk1), selected(rect_wool1))) ::: (D)
is_sat(And(selected(rect_silk1), selected(rect_silk2), selected(rect_wool1), selected(rect_wool2), selected(rect_wool3))) ::: (E)"
"# Context:
Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.

# Question:
If every applicant that is interviewed is hired, and if Lee is hired, then each of the following applicants must be interviewed EXCEPT:

# Options:
A) Fu
B) Jackson
C) Kowalski
D) Mayer
E) Ordoveza","# Declarations
applicants = EnumSort([Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, Ordoveza])
interviewed = Function([applicants] -> [bool])
hired = Function([applicants] -> [bool])
# Constraints
Implies(interviewed(Gunsel), interviewed(Jackson)) ::: If Gunsel is interviewed, Jackson is interviewed
Implies(interviewed(Jackson), interviewed(Lee)) ::: If Jackson is interviewed, Lee is interviewed
interviewed(Fu) ::: Fu is interviewed
Implies(Not(interviewed(Kowalski)), Not(hired(Fu))) ::: Fu is not hired, unless Kowalski is interviewed
Implies(Not(interviewed(Mayer)), Not(hired(Kowalski))) ::: Kowalski is not hired, unless Mayer is interviewed
Implies(And(hired(Mayer), interviewed(Lee)), hired(Ordoveza)) ::: If Mayer is hired, and Lee is interviewed, Ordoveza is hired
ForAll([a:applicants], Implies(interviewed(a), hired(a))) ::: every applicant that is interviewed is hired
hired(Lee) ::: Lee is hired
# Options
is_unsat(interviewed(Fu)) ::: (A)
is_unsat(interviewed(Jackson)) ::: (B)
is_unsat(interviewed(Kowalski)) ::: (C)
is_unsat(interviewed(Mayer)) ::: (D)
is_unsat(interviewed(Ordoveza)) ::: (E)"
"# Context:
Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.

# Question:
If Valdez goes to a soccer game, then each of the following could be true EXCEPT:

# Options:
A) Olson goes to a movie.
B) Nguyen goes to a restaurant.
C) Nguyen goes to a soccer game.
D) Tyner goes to a soccer game.
E) Tyner goes to a movie.","# Declarations
persons = EnumSort([Nguyen, Olson, Pike, Tyner, Valdez])
activities = EnumSort([movie, soccer, restaurant])
participates = Function([persons] -> [activities])
# Constraints
ForAll([p:persons], Exists([a:activities], participates(p) == a)) ::: Each person participates in exactly one activity
participates(Nguyen) != participates(Olson) ::: Nguyen and Olson do not participate in the same activity as each other
participates(Nguyen) != participates(Pike) ::: Nguyen does not participate in the same activity as Pike
participates(Olson) != participates(Pike) ::: Olson does not participate in the same activity as Pike
Count([p:persons], participates(p) == soccer) == 2 ::: Exactly two persons go to a soccer game
participates(Tyner) != participates(Pike) ::: Tyner and Pike do not participate in the same activity as each other
Implies(Or(participates(Nguyen) == movie, participates(Valdez) == movie), And(participates(Nguyen) == movie, participates(Valdez) == movie)) ::: If Nguyen or Valdez goes to a movie, they both go to a movie
participates(Valdez) == soccer ::: Valdez goes to a soccer game
# Options
is_unsat(participates(Olson) == movie) ::: (A)
is_unsat(participates(Nguyen) == restaurant) ::: (B)
is_unsat(participates(Nguyen) == soccer) ::: (C)
is_unsat(participates(Tyner) == soccer) ::: (D)
is_unsat(participates(Tyner) == movie) ::: (E)"
"# Context:
Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.

# Question:
If Franklin is on the same team as Marquez, which one of the following could be true?

# Options:
A) Jones is on team 1.
B) Rice is on team 1.
C) Samuels is on team 2.
D) Both Neil and Osborne are on team 1.
E) Both Neil and Osborne are on team 2.","# Declarations
researchers = EnumSort([Franklin, Jones, Marquez, Neil, Osborne, Rice, Samuels])
teams = EnumSort([team1, team2])
included = Function([researchers] -> [teams])
# Constraints
ForAll([t:teams], Exists([r:researchers], included(r) == t)) ::: Each team must include at least one researcher
ForAll([t:teams], Exists([a:researchers], And(a == Franklin, included(a) == t))) ::: Each team must include at least one anthropologist
ForAll([t:teams], Exists([l:researchers], And(l == Neil, included(l) == t))) ::: Each team must include at least one linguist
ForAll([r:researchers], Count([t:teams], included(r) == t) <= 1) ::: No researcher will be included in more than one team
included(Franklin) != included(Samuels) ::: Neither team includes both Franklin and Samuels
included(Neil) != included(Rice) ::: Neither team includes both Neil and Rice
Implies(included(Marquez) == team1, And(included(Rice) != team1, included(Samuels) != team1)) ::: If a team includes Marquez, it includes neither Rice nor Samuels
Implies(included(Jones) == team1, included(Rice) == team2) ::: If team 1 includes Jones, team 2 includes Rice
included(Franklin) == included(Marquez) ::: Franklin is on the same team as Marquez
# Options
is_valid(included(Jones) == team1) ::: (A)
is_valid(included(Rice) == team1) ::: (B)
is_valid(included(Samuels) == team2) ::: (C)
is_valid(And(included(Neil) == team1, included(Osborne) == team1)) ::: (D)
is_valid(And(included(Neil) == team2, included(Osborne) == team2)) ::: (E)"
"# Context:
On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.

# Question:
If W has appointment 2 and P has appointment 5, then which one of the following must be true?

# Options:
A) R has appointment 6.
B) S has appointment 4.
C) S has appointment 7.
D) U has appointment 1.
E) U has appointment 4.","# Declarations
patients = EnumSort([P, Q, R, S, T, U, W])
appointments = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([patients] -> [appointments])
# Constraints
ForAll([p:patients], Exists([a:appointments], scheduled(p) == a)) ::: each patient has exactly one appointment
ForAll([a:appointments], Exists([p:patients], scheduled(p) == a)) ::: each appointment is scheduled for exactly one patient
scheduled(Q) < scheduled(W) ::: Q's appointment is at some time before W's appointment
scheduled(U) < scheduled(P) ::: U's appointment is at some time before P's appointment
Or(scheduled(R) == 3, scheduled(T) == 3) ::: Either R or T has appointment 3
Or(scheduled(S) == scheduled(R) - 1, scheduled(S) == scheduled(R) + 1) ::: S's appointment is either the appointment immediately before or the appointment immediately after R's appointment
scheduled(W) == 2 ::: W has appointment 2
scheduled(P) == 5 ::: P has appointment 5
# Options
is_valid(scheduled(R) == 6) ::: (A)
is_valid(scheduled(S) == 4) ::: (B)
is_valid(scheduled(S) == 7) ::: (C)
is_valid(scheduled(U) == 1) ::: (D)
is_valid(scheduled(U) == 4) ::: (E)"
"# Context:
Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.

# Question:
If Gunsel and five other applicants are the only applicants interviewed, and if exactly three applicants are hired, then which one of the following could be an accurate list of the applicants hired?

# Options:
A) Fu, Lee, Mayer
B) Fu, Kowalski, Mayer
C) Kowalski, Lee, Ordoveza
D) Gunsel, Jackson, Mayer
E) Gunsel, Jackson, Lee","# Declarations
applicants = EnumSort([Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, Ordoveza])
interviewed = Function([applicants] -> [bool])
hired = Function([applicants] -> [bool])
# Constraints
Implies(interviewed(Gunsel), interviewed(Jackson)) ::: If Gunsel is interviewed, Jackson is interviewed
Implies(interviewed(Jackson), interviewed(Lee)) ::: If Jackson is interviewed, Lee is interviewed
interviewed(Fu) ::: Fu is interviewed
Implies(Not(interviewed(Kowalski)), Not(hired(Fu))) ::: Fu is not hired, unless Kowalski is interviewed
Implies(Not(interviewed(Mayer)), Not(hired(Kowalski))) ::: Kowalski is not hired, unless Mayer is interviewed
Implies(And(hired(Mayer), interviewed(Lee)), hired(Ordoveza)) ::: If Mayer is hired, and Lee is interviewed, Ordoveza is hired
Count([a:applicants], interviewed(a)) == 6 ::: Gunsel and five other applicants are the only applicants interviewed
Count([a:applicants], hired(a)) == 3 ::: exactly three applicants are hired
# Options
is_accurate_list([hired(Fu), hired(Lee), hired(Mayer)]) ::: (A)
is_accurate_list([hired(Fu), hired(Kowalski), hired(Mayer)]) ::: (B)
is_accurate_list([hired(Kowalski), hired(Lee), hired(Ordoveza)]) ::: (C)
is_accurate_list([hired(Gunsel), hired(Jackson), hired(Mayer)]) ::: (D)
is_accurate_list([hired(Gunsel), hired(Jackson), hired(Lee)]) ::: (E)"
"# Context:
Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.

# Question:
If Henry and Yvette are both assigned to bench 1, which one of the following could be true?

# Options:
A) Gwen is assigned to bench 3.
B) Joan is assigned to bench 2.
C) Wanda is assigned to bench 2.
D) Wanda is assigned to bench 3.
E) Xavier is assigned to bench 3.","# Declarations
students = EnumSort([Frank, Gwen, Henry, Joan, Victor, Wanda, Xavier, Yvette])
benches = EnumSort([1, 2, 3, 4])
assigned = Function([students] -> [benches])
# Constraints
ForAll([b:benches], Count([s:students], assigned(s) == b) == 2) ::: exactly two students are assigned to each bench
ForAll([b:benches], Exists([s:students], And(Or(s == Frank, s == Gwen, s == Henry, s == Joan), assigned(s) == b))) ::: exactly one major is assigned to each bench
assigned(Frank) == assigned(Victor) ::: Frank is assigned to the same bench as Victor
assigned(Gwen) != assigned(Wanda) ::: Gwen is not assigned to the same bench as Wanda
assigned(Frank) == assigned(Joan) - 1 ::: Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench
assigned(Henry) == 1 ::: Henry is assigned to bench 1
assigned(Yvette) == 1 ::: Yvette is assigned to bench 1
# Options
is_valid(assigned(Gwen) == 3) ::: (A)
is_valid(assigned(Joan) == 2) ::: (B)
is_valid(assigned(Wanda) == 2) ::: (C)
is_valid(assigned(Wanda) == 3) ::: (D)
is_valid(assigned(Xavier) == 3) ::: (E)"
"# Context:
Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.

# Question:
If Klaus and Laura speak the same language as each other, then which one of the following must be true?

# Options:
A) At least one of Michael and Norma speaks Spanish.
B) At least two tourists speak Russian.
C) Klaus and Laura speak Russian.
D) At least two tourists speak French.
E) At least one of Michael and Norma speaks French.","# Declarations
tourists = EnumSort([Harry, Irene, Klaus, Laura, Michael, Norma])
guides = EnumSort([Valois, Xerxes, Yossarian, Zalamea])
languages = EnumSort([French, Turkish, Spanish, Russian])
assigned = Function([tourists] -> [guides])
speaks = Function([tourists] -> [languages])
# Constraints
ForAll([g:guides], Exists([t:tourists], assigned(t) == g)) ::: at least one tourist assigned to each guide
ForAll([t:tourists], Exists([g:guides], assigned(t) == g)) ::: each tourist is assigned to exactly one guide
assigned(Harry) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Irene) == Yossarian ::: at least Harry and Irene are assigned to Yossarian
assigned(Laura) == Zalamea ::: at least Laura is assigned to Zalamea
Implies(assigned(Klaus) == Xerxes, speaks(Michael) == French) ::: if Klaus is assigned to Xerxes, then Michael speaks French
ForAll([t:tourists], Implies(assigned(t) == Valois, speaks(t) == French)) ::: Valois speaks only French
ForAll([t:tourists], Implies(assigned(t) == Xerxes, Or(speaks(t) == Turkish, speaks(t) == Spanish))) ::: Xerxes speaks only Turkish and Spanish
ForAll([t:tourists], Implies(assigned(t) == Yossarian, Or(speaks(t) == French, speaks(t) == Turkish))) ::: Yossarian speaks only French and Turkish
ForAll([t:tourists], Implies(assigned(t) == Zalamea, Or(speaks(t) == Spanish, speaks(t) == Russian))) ::: Zalamea speaks only Spanish and Russian
speaks(Klaus) == speaks(Laura) ::: Klaus and Laura speak the same language as each other
# Options
is_valid(Or(speaks(Michael) == Spanish, speaks(Norma) == Spanish)) ::: (A)
is_valid(Count([t:tourists], speaks(t) == Russian) >= 2) ::: (B)
is_valid(And(speaks(Klaus) == Russian, speaks(Laura) == Russian)) ::: (C)
is_valid(Count([t:tourists], speaks(t) == French) >= 2) ::: (D)
is_valid(Or(speaks(Michael) == French, speaks(Norma) == French)) ::: (E)"
"# Context:
Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.

# Question:
If salespeople H and I present products on Monday, which one of the following must be true?

# Options:
A) F presents product M.
B) G presents product L.
C) I presents product N.
D) Product O is presented on Wednesday.
E) Product P is presented on Wednesday.","# Declarations
salespeople = EnumSort([F, G, H, I, J])
products = EnumSort([L, M, N, O, P])
days = EnumSort([Monday, Tuesday, Wednesday])
presents = Function([salespeople] -> [products])
scheduled = Function([products] -> [days])
# Constraints
Count([p:products], scheduled(p) == Monday) == 2 ::: Exactly two products will be presented on Monday
Count([p:products], scheduled(p) == Tuesday) == 1 ::: Exactly one product will be presented on Tuesday
Count([p:products], scheduled(p) == Wednesday) == 2 ::: Exactly two products will be presented on Wednesday
ForAll([s:salespeople], Exists([p:products], presents(s) == p)) ::: Each salesperson presents exactly one product
ForAll([p:products], Exists([s:salespeople], presents(s) == p)) ::: Each product is presented by exactly one salesperson
ForAll([s:salespeople], scheduled(presents(s)) == scheduled(presents(H))) ::: F cannot present a product on the same day as H
Or(presents(I) == N, presents(J) == N) ::: Either I or else J must present product N on Tuesday
scheduled(N) == Tuesday ::: Either I or else J must present product N on Tuesday
ForAll([p:products], Implies(scheduled(p) == scheduled(O), scheduled(presents(G)) == scheduled(O))) ::: G must present a product on the day that product O is presented
scheduled(presents(H)) == Monday ::: salespeople H and I present products on Monday
scheduled(presents(I)) == Monday ::: salespeople H and I present products on Monday
# Options
is_valid(presents(F) == M) ::: (A)
is_valid(presents(G) == L) ::: (B)
is_valid(presents(I) == N) ::: (C)
is_valid(scheduled(O) == Wednesday) ::: (D)
is_valid(scheduled(P) == Wednesday) ::: (E)"
"# Context:
Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.

# Question:
If H is assigned to team 2, which one of the following is an acceptable assignment of jugglers to team 1?

# Options:
A) front: G; middle: K; rear: L
B) front: G; middle: K; rear: N
C) front: L; middle: K; rear: P
D) front: L; middle: Q; rear: G
E) front: L; middle: Q; rear: N","# Declarations
jugglers = EnumSort([G, H, K, L, N, P, Q])
positions = EnumSort([front, middle, rear])
teams = EnumSort([team1, team2])
assigned_team = Function([jugglers] -> [teams])
assigned_position = Function([jugglers] -> [positions])
# Constraints
ForAll([t:teams], And(Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == front)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == middle)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == rear)))) ::: For each team, exactly one juggler must be assigned to each position
Implies(Or(assigned_team(G) != None, assigned_team(H) != None), And(assigned_position(G) == front, assigned_position(H) == front)) ::: If either G or H or both are assigned to teams, they are assigned to front positions
Implies(assigned_team(K) != None, assigned_position(K) == middle) ::: If assigned to a team, K is assigned to a middle position
Implies(assigned_team(L) != None, assigned_team(L) == team1) ::: If assigned to a team, L is assigned to team 1
And(assigned_team(P) != assigned_team(N), assigned_team(K) != assigned_team(N)) ::: Neither P nor K is on the same team as N
assigned_team(P) != assigned_team(Q) ::: P is not on the same team as Q
Implies(assigned_team(H) == team2, And(assigned_team(Q) == team1, assigned_position(Q) == middle)) ::: If H is on team 2, then Q is assigned to the middle position on team 1
assigned_team(H) == team2 ::: If H is assigned to team 2
# Options
is_valid(And(assigned_team(G) == team1, assigned_position(G) == front, assigned_team(K) == team1, assigned_position(K) == middle, assigned_team(L) == team1, assigned_position(L) == rear)) ::: (A)
is_valid(And(assigned_team(G) == team1, assigned_position(G) == front, assigned_team(K) == team1, assigned_position(K) == middle, assigned_team(N) == team1, assigned_position(N) == rear)) ::: (B)
is_valid(And(assigned_team(L) == team1, assigned_position(L) == front, assigned_team(K) == team1, assigned_position(K) == middle, assigned_team(P) == team1, assigned_position(P) == rear)) ::: (C)
is_valid(And(assigned_team(L) == team1, assigned_position(L) == front, assigned_team(Q) == team1, assigned_position(Q) == middle, assigned_team(G) == team1, assigned_position(G) == rear)) ::: (D)
is_valid(And(assigned_team(L) == team1, assigned_position(L) == front, assigned_team(Q) == team1, assigned_position(Q) == middle, assigned_team(N) == team1, assigned_position(N) == rear)) ::: (E)"
"# Context:
Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.

# Question:
If Marquez is on team 2, which one of the following must also be on team 2?

# Options:
A) Franklin
B) Jones
C) Osborne
D) Rice
E) Samuels","# Declarations
researchers = EnumSort([Franklin, Jones, Marquez, Neil, Osborne, Rice, Samuels])
teams = EnumSort([team1, team2])
included = Function([researchers] -> [teams])
# Constraints
ForAll([r:researchers], Exists([t:teams], included(r) == t)) ::: No researcher will be included in more than one team
ForAll([t:teams], And(Exists([r:researchers], And(included(r) == t, Or(r == Franklin, r == Jones, r == Marquez))), Exists([r:researchers], And(included(r) == t, Or(r == Neil, r == Osborne, r == Rice, r == Samuels))))) ::: Each team must include at least one anthropologist and at least one linguist
ForAll([t:teams], And(included(Franklin) != t, included(Samuels) != t)) ::: Neither team includes both Franklin and Samuels
ForAll([t:teams], And(included(Neil) != t, included(Rice) != t)) ::: Neither team includes both Neil and Rice
Implies(included(Marquez) == team1, And(included(Rice) != team1, included(Samuels) != team1)) ::: If a team includes Marquez, it includes neither Rice nor Samuels
Implies(included(Jones) == team1, included(Rice) == team2) ::: If team 1 includes Jones, team 2 includes Rice
included(Marquez) == team2 ::: Marquez is on team 2
# Options
is_valid(included(Franklin) == team2) ::: (A)
is_valid(included(Jones) == team2) ::: (B)
is_valid(included(Osborne) == team2) ::: (C)
is_valid(included(Rice) == team2) ::: (D)
is_valid(included(Samuels) == team2) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
If F and G are not assigned rooms that are next to each other, which one of the following CANNOT be assigned room 107?

# Options:
A) W
B) V
C) S
D) R
E) Q","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m1:members, m2:members], Implies(m1 != m2, assigned(m1) != assigned(m2))) ::: each member is assigned a different room
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([p:members], Implies(Or(p == F, p == G), Abs(assigned(m) - assigned(p)) > 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([p:members], Implies(Or(p == F, p == G), And(assigned(p) != 101, assigned(p) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
Implies(Abs(assigned(G) - assigned(R)) == 1, False) ::: G is not assigned a room next to R's room
Implies(Abs(assigned(W) - assigned(V)) == 1, Abs(assigned(R) - assigned(V)) == 1) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
Implies(Abs(assigned(F) - assigned(G)) == 1, False) ::: F and G are not assigned rooms that are next to each other
# Options
is_unsat(assigned(W) == 107) ::: (A)
is_unsat(assigned(V) == 107) ::: (B)
is_unsat(assigned(S) == 107) ::: (C)
is_unsat(assigned(R) == 107) ::: (D)
is_unsat(assigned(Q) == 107) ::: (E)"
"# Context:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.

# Question:
If Wendy eats poached eggs for breakfast, then which one of the following statements cannot be true?

# Options:
A) Vladimir eats fish for lunch.
B) Vladimir eats hot cakes for lunch.
C) Vladimir eats macaroni for dinner.
D) Wendy eats hot cakes for dinner.
E) Wendy eats macaroni for dinner.","# Declarations
persons = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([hot_cakes, poached_eggs, omelet, fish, macaroni])
eats = Function([persons, meals] -> [foods])
# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:persons], ForAll([m1:meals], ForAll([m2:meals], Implies(m1 != m2, eats(p, m1) != eats(p, m2))))) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:persons], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:persons], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch
eats(Wendy, breakfast) == poached_eggs ::: Wendy eats poached eggs for breakfast
# Options
is_unsat(eats(Vladimir, lunch) == fish) ::: (A)
is_unsat(eats(Vladimir, lunch) == hot_cakes) ::: (B)
is_unsat(eats(Vladimir, dinner) == macaroni) ::: (C)
is_unsat(eats(Wendy, dinner) == hot_cakes) ::: (D)
is_unsat(eats(Wendy, dinner) == macaroni) ::: (E)"
"# Context:
Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.

# Question:
Suppose that the condition is added that Shigeru and Paulo do not play the same sport as each other. If all the other conditions remain in effect, then each of the following could be true EXCEPT:

# Options:
A) Maricella and Kim play the same sport as each other.
B) Paulo and Kim play the same sport as each other.
C) Paulo and Maricella play the same sport as each other.
D) Kim and Paulo do not play the same sport as each other.
E) Maricella and Kim do not play the same sport as each other.","# Declarations
people = EnumSort([Kim, Lina, Maricella, Oliver, Paulo, Shigeru])
sports = EnumSort([golf, tennis])
plays = Function([people] -> [sports])
rank = Function([people, people] -> [bool])
# Constraints
plays(Oliver) == tennis ::: Oliver plays tennis
plays(Lina) == golf ::: Lina plays golf
ForAll([p:people], Implies(plays(p) == golf, rank(Lina, p))) ::: There is no golf player ranked higher than Lina
Implies(plays(Maricella) == golf, And(plays(Paulo) == golf, plays(Shigeru) == golf, rank(Maricella, Paulo), rank(Paulo, Shigeru))) ::: If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru
Implies(plays(Maricella) == tennis, And(plays(Shigeru) == tennis, rank(Oliver, Shigeru), rank(Shigeru, Maricella))) ::: If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella
Implies(plays(Paulo) == tennis, And(plays(Kim) == tennis, rank(Kim, Oliver), rank(Oliver, Paulo))) ::: If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo
plays(Shigeru) != plays(Paulo) ::: Shigeru and Paulo do not play the same sport as each other
# Options
is_unsat(And(plays(Maricella) == plays(Kim))) ::: (A)
is_unsat(And(plays(Paulo) == plays(Kim))) ::: (B)
is_unsat(And(plays(Paulo) == plays(Maricella))) ::: (C)
is_unsat(plays(Kim) != plays(Paulo)) ::: (D)
is_unsat(plays(Maricella) != plays(Kim)) ::: (E)"
"# Context:
On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.

# Question:
Which one of the following is an acceptable schedule of appointments in order from 1 to 7?

# Options:
A) Q, S, R, P, W, U, T
B) Q, U, W, S, R, T, P
C) S, Q, R, T, W, U, P
D) T, U, R, S, W, P, Q
E) U, Q, T, P, R, S, W","# Declarations
patients = EnumSort([P, Q, R, S, T, U, W])
appointments = EnumSort([1, 2, 3, 4, 5, 6, 7])
schedule = Function([appointments] -> [patients])
# Constraints
ForAll([a:appointments], Exists([p:patients], schedule(a) == p)) ::: each appointment is assigned to exactly one patient
ForAll([p:patients], Exists([a:appointments], schedule(a) == p)) ::: each patient has exactly one appointment
Exists([a:appointments], And(a < 7, schedule(a) == Q, schedule(a + 1) == W)) ::: Q's appointment is at some time before W's appointment
Exists([a:appointments], And(a < 7, schedule(a) == U, schedule(a + 1) == P)) ::: U's appointment is at some time before P's appointment
Or(schedule(3) == R, schedule(3) == T) ::: Either R or T has appointment 3
Exists([a:appointments], And(a > 1, a < 7, Or(And(schedule(a) == R, schedule(a - 1) == S), And(schedule(a) == R, schedule(a + 1) == S)))) ::: S's appointment is either the appointment immediately before or the appointment immediately after R's appointment
# Options
is_sat(And(schedule(1) == Q, schedule(2) == S, schedule(3) == R, schedule(4) == P, schedule(5) == W, schedule(6) == U, schedule(7) == T)) ::: (A)
is_sat(And(schedule(1) == Q, schedule(2) == U, schedule(3) == W, schedule(4) == S, schedule(5) == R, schedule(6) == T, schedule(7) == P)) ::: (B)
is_sat(And(schedule(1) == S, schedule(2) == Q, schedule(3) == R, schedule(4) == T, schedule(5) == W, schedule(6) == U, schedule(7) == P)) ::: (C)
is_sat(And(schedule(1) == T, schedule(2) == U, schedule(3) == R, schedule(4) == S, schedule(5) == W, schedule(6) == P, schedule(7) == Q)) ::: (D)
is_sat(And(schedule(1) == U, schedule(2) == Q, schedule(3) == T, schedule(4) == P, schedule(5) == R, schedule(6) == S, schedule(7) == W)) ::: (E)"
"# Context:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.

# Question:
If F is assigned to boat 2, which one of the following is a pair of people who could be assigned to the same boat as each other?

# Options:
A) F and Y
B) G and H
C) G and Y
D) V and W
E) Y and Z","# Declarations
boats = EnumSort([boat1, boat2])
people = EnumSort([F, G, H, V, W, X, Y, Z])
assigned = Function([people] -> [boats])
# Constraints
Count([p:people], assigned(p) == boat1) == 4 ::: Each boat is assigned exactly four people
Count([p:people], assigned(p) == boat2) == 4 ::: Each boat is assigned exactly four people
ForAll([b:boats], Exists([p:people], And(Or(p == F, p == G, p == H), assigned(p) == b))) ::: Each boat is assigned at least one adult
Implies(assigned(F) == boat2, assigned(G) == boat2) ::: If F is assigned to boat 2, G is assigned to boat 2
Implies(assigned(V) == boat1, assigned(W) == boat2) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(X) != assigned(Z) ::: X and Z are assigned to different boats
assigned(F) == boat2 ::: F is assigned to boat 2
# Options
is_valid(And(assigned(F) == assigned(Y), assigned(F) == boat2)) ::: (A)
is_valid(And(assigned(G) == assigned(H), assigned(G) == boat2)) ::: (B)
is_valid(And(assigned(G) == assigned(Y), assigned(G) == boat2)) ::: (C)
is_valid(And(assigned(V) == assigned(W), assigned(V) == boat1)) ::: (D)
is_valid(And(assigned(Y) == assigned(Z), assigned(Y) == boat2)) ::: (E)"
"# Context:
Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.

# Question:
Each of the following could be true of the assignment of tourists to guides EXCEPT:

# Options:
A) It assigns Klaus to Valois and Michael to Xerxes.
B) It assigns Klaus to Yossarian and Norma to Zalamea.
C) It assigns Laura to Zalamea and Michael to Zalamea.
D) It assigns Michael to Valois and Klaus to Zalamea.
E) It assigns Michael to Xerxes and Klaus to Zalamea.","# Declarations
tourists = EnumSort([Harry, Irene, Klaus, Laura, Michael, Norma])
guides = EnumSort([Valois, Xerxes, Yossarian, Zalamea])
languages = EnumSort([French, Turkish, Spanish, Russian])
assigned = Function([tourists] -> [guides])
speaks = Function([tourists] -> [languages])
guide_languages = Function([guides] -> [languages])
# Constraints
ForAll([g:guides], Exists([t:tourists], assigned(t) == g)) ::: at least one tourist assigned to each guide
ForAll([t:tourists], Exists([g:guides], assigned(t) == g)) ::: each tourist is assigned to exactly one guide
guide_languages(Valois) == French ::: Valois speaks only French
guide_languages(Xerxes) == Turkish ::: Xerxes speaks only Turkish and Spanish
guide_languages(Yossarian) == French ::: Yossarian speaks only French and Turkish
guide_languages(Zalamea) == Spanish ::: Zalamea speaks only Spanish and Russian
ForAll([t:tourists], Exists([l:languages], And(speaks(t) == l, guide_languages(assigned(t)) == l))) ::: each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language
Or(assigned(Harry) == Yossarian, assigned(Irene) == Yossarian) ::: at least Harry and Irene are assigned to Yossarian
assigned(Laura) == Zalamea ::: at least Laura is assigned to Zalamea
Implies(assigned(Klaus) == Xerxes, speaks(Michael) == French) ::: if Klaus is assigned to Xerxes, then Michael speaks French
# Options
is_unsat(And(assigned(Klaus) == Valois, assigned(Michael) == Xerxes)) ::: (A)
is_unsat(And(assigned(Klaus) == Yossarian, assigned(Norma) == Zalamea)) ::: (B)
is_unsat(And(assigned(Laura) == Zalamea, assigned(Michael) == Zalamea)) ::: (C)
is_unsat(And(assigned(Michael) == Valois, assigned(Klaus) == Zalamea)) ::: (D)
is_unsat(And(assigned(Michael) == Xerxes, assigned(Klaus) == Zalamea)) ::: (E)"
"# Context:
Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.

# Question:
Which one of the following is an acceptable list of assignments of jugglers to team 2?

# Options:
A) front: Q; middle: K; rear: N
B) front: H; middle: P; rear: K
C) front: H; middle: L; near: N
D) front: G; middle: Q; rear: P
E) front: G; middle: Q; rear: N","# Declarations
jugglers = EnumSort([G, H, K, L, N, P, Q])
positions = EnumSort([front, middle, rear])
teams = EnumSort([team1, team2])
assigned_position = Function([jugglers] -> [positions])
assigned_team = Function([jugglers] -> [teams])
# Constraints
ForAll([t:teams], And(Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == front)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == middle)), Exists([j:jugglers], And(assigned_team(j) == t, assigned_position(j) == rear)))) ::: For each team, exactly one juggler must be assigned to each position
Implies(Or(assigned_team(G) != None, assigned_team(H) != None), And(assigned_position(G) == front, assigned_position(H) == front)) ::: If either G or H or both are assigned to teams, they are assigned to front positions
Implies(assigned_team(K) != None, assigned_position(K) == middle) ::: If assigned to a team, K is assigned to a middle position
Implies(assigned_team(L) != None, assigned_team(L) == team1) ::: If assigned to a team, L is assigned to team 1
And(assigned_team(P) != assigned_team(N), assigned_team(K) != assigned_team(N)) ::: Neither P nor K is on the same team as N
assigned_team(P) != assigned_team(Q) ::: P is not on the same team as Q
Implies(assigned_team(H) == team2, And(assigned_team(Q) == team1, assigned_position(Q) == middle)) ::: If H is on team 2, then Q is assigned to the middle position on team 1
# Options
is_accurate_list([And(assigned_team(Q) == team2, assigned_position(Q) == front), And(assigned_team(K) == team2, assigned_position(K) == middle), And(assigned_team(N) == team2, assigned_position(N) == rear)]) ::: (A)
is_accurate_list([And(assigned_team(H) == team2, assigned_position(H) == front), And(assigned_team(P) == team2, assigned_position(P) == middle), And(assigned_team(K) == team2, assigned_position(K) == rear)]) ::: (B)
is_accurate_list([And(assigned_team(H) == team2, assigned_position(H) == front), And(assigned_team(L) == team2, assigned_position(L) == middle), And(assigned_team(N) == team2, assigned_position(N) == rear)]) ::: (C)
is_accurate_list([And(assigned_team(G) == team2, assigned_position(G) == front), And(assigned_team(Q) == team2, assigned_position(Q) == middle), And(assigned_team(P) == team2, assigned_position(P) == rear)]) ::: (D)
is_accurate_list([And(assigned_team(G) == team2, assigned_position(G) == front), And(assigned_team(Q) == team2, assigned_position(Q) == middle), And(assigned_team(N) == team2, assigned_position(N) == rear)]) ::: (E)"
"# Context:
Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.

# Question:
If Mayer is not interviewed, which one of the following must be true?

# Options:
A) Kowalski is not interviewed.
B) Kowalski is interviewed but not hired.
C) Fu is not hired.
D) Fu is hired but Kowalski is not hired.
E) Fu is interviewed but Kowalski is not hired.","# Declarations
applicants = EnumSort([Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, Ordoveza])
interviewed = Function([applicants] -> [bool])
hired = Function([applicants] -> [bool])
# Constraints
Implies(interviewed(Gunsel), interviewed(Jackson)) ::: If Gunsel is interviewed, Jackson is interviewed
Implies(interviewed(Jackson), interviewed(Lee)) ::: If Jackson is interviewed, Lee is interviewed
interviewed(Fu) ::: Fu is interviewed
Implies(Not(interviewed(Kowalski)), Not(hired(Fu))) ::: Fu is not hired, unless Kowalski is interviewed
Implies(Not(interviewed(Mayer)), Not(hired(Kowalski))) ::: Kowalski is not hired, unless Mayer is interviewed
Implies(And(hired(Mayer), interviewed(Lee)), hired(Ordoveza)) ::: If Mayer is hired, and Lee is interviewed, Ordoveza is hired
Not(interviewed(Mayer)) ::: Mayer is not interviewed
# Options
is_valid(Not(interviewed(Kowalski))) ::: (A)
is_valid(And(interviewed(Kowalski), Not(hired(Kowalski)))) ::: (B)
is_valid(Not(hired(Fu))) ::: (C)
is_valid(And(hired(Fu), Not(hired(Kowalski)))) ::: (D)
is_valid(And(interviewed(Fu), Not(interviewed(Kowalski)))) ::: (E)"
"# Context:
Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.

# Question:
Which one of the following could be true?

# Options:
A) Franklin is on team 1 and Neil is on team 2.
B) Franklin is on team 2 and Jones is not on any team.
C) Franklin is on team 2 and Marquez is on team 2.
D) Franklin is not on any team and Jones is on team 1.
E) Jones is on team 1 and Neil is on team 2.","# Declarations
researchers = EnumSort([Franklin, Jones, Marquez, Neil, Osborne, Rice, Samuels])
teams = EnumSort([team1, team2])
included = Function([researchers] -> [teams])
# Constraints
ForAll([t:teams], Exists([r:researchers], included(r) == t)) ::: No researcher will be included in more than one team
ForAll([t:teams], And(Exists([r:researchers], And(included(r) == t, Or(r == Franklin, r == Jones, r == Marquez))), Exists([r:researchers], And(included(r) == t, Or(r == Neil, r == Osborne, r == Rice, r == Samuels))))) ::: Each team must include at least one anthropologist and at least one linguist
ForAll([t:teams], And(included(Franklin) != t, included(Samuels) != t)) ::: Neither team includes both Franklin and Samuels
ForAll([t:teams], And(included(Neil) != t, included(Rice) != t)) ::: Neither team includes both Neil and Rice
ForAll([t:teams], Implies(included(Marquez) == t, And(included(Rice) != t, included(Samuels) != t))) ::: If a team includes Marquez, it includes neither Rice nor Samuels
Implies(included(Jones) == team1, included(Rice) == team2) ::: If team 1 includes Jones, team 2 includes Rice
# Options
is_sat(And(included(Franklin) == team1, included(Neil) == team2)) ::: (A)
is_sat(And(included(Franklin) == team2, included(Jones) == None)) ::: (B)
is_sat(And(included(Franklin) == team2, included(Marquez) == team2)) ::: (C)
is_sat(And(included(Franklin) == None, included(Jones) == team1)) ::: (D)
is_sat(And(included(Jones) == team1, included(Neil) == team2)) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
If no two faculty members of the same rank are assigned adjacent rooms, which one of the following must be true?

# Options:
A) F is assigned either room 103 or else room 104.
B) Q is assigned either room 102 or else room 106.
C) R is assigned either room 102 or else room 105.
D) S is assigned either room 104 or else room 105.
E) V is assigned either room 101 or else room 107.","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m:members], ForAll([m1:members], Implies(m != m1, assigned(m) != assigned(m1)))) ::: each member is assigned a different room
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([m1:members], Implies(Or(m1 == F, m1 == G), Abs(assigned(m) - assigned(m1)) != 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([m:members], Implies(Or(m == F, m == G), And(assigned(m) != 101, assigned(m) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:members], Implies(m == G, Abs(assigned(G) - assigned(R)) != 1)) ::: G is not assigned a room next to R's room
ForAll([m:members], Implies(And(m == W, Abs(assigned(W) - assigned(V)) == 1), Abs(assigned(R) - assigned(V)) == 1)) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
ForAll([m:members], ForAll([m1:members], Implies(And(m != m1, Or(And(m == F, m1 == G), And(m == G, m1 == F), And(m == Q, m1 == R), And(m == R, m1 == Q), And(m == S, m1 == R), And(m == R, m1 == S), And(m == V, m1 == W), And(m == W, m1 == V))), Abs(assigned(m) - assigned(m1)) != 1))) ::: no two faculty members of the same rank are assigned adjacent rooms
# Options
is_valid(Or(assigned(F) == 103, assigned(F) == 104)) ::: (A)
is_valid(Or(assigned(Q) == 102, assigned(Q) == 106)) ::: (B)
is_valid(Or(assigned(R) == 102, assigned(R) == 105)) ::: (C)
is_valid(Or(assigned(S) == 104, assigned(S) == 105)) ::: (D)
is_valid(Or(assigned(V) == 101, assigned(V) == 107)) ::: (E)"
"# Context:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.

# Question:
Which one of the following is an acceptable assignment of people to boat I ?

# Options:
A) F, G, H, X
B) F, H, W, Y
C) F, H, Y, Z
D) F, V, W, X
E) G, H, X, Y","# Declarations
people = EnumSort([F, G, H, V, W, X, Y, Z])
boats = EnumSort([boat1, boat2])
assigned = Function([people] -> [boats])
# Constraints
Count([p:people], assigned(p) == boat1) == 4 ::: boat 1 will be assigned exactly four people
Count([p:people], assigned(p) == boat2) == 4 ::: boat 2 will be assigned exactly four people
Exists([p:people], And(p != V, p != W, p != X, p != Y, p != Z, assigned(p) == boat1)) ::: Each boat is assigned at least one adult
Exists([p:people], And(p != V, p != W, p != X, p != Y, p != Z, assigned(p) == boat2)) ::: Each boat is assigned at least one adult
Implies(assigned(F) == boat2, assigned(G) == boat2) ::: If F is assigned to boat 2, G is assigned to boat 2
Implies(assigned(V) == boat1, assigned(W) == boat2) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(X) != assigned(Z) ::: X and Z are assigned to different boats
# Options
is_sat(And(assigned(F) == boat1, assigned(G) == boat1, assigned(H) == boat1, assigned(X) == boat1)) ::: (A)
is_sat(And(assigned(F) == boat1, assigned(H) == boat1, assigned(W) == boat1, assigned(Y) == boat1)) ::: (B)
is_sat(And(assigned(F) == boat1, assigned(H) == boat1, assigned(Y) == boat1, assigned(Z) == boat1)) ::: (C)
is_sat(And(assigned(F) == boat1, assigned(V) == boat1, assigned(W) == boat1, assigned(X) == boat1)) ::: (D)
is_sat(And(assigned(G) == boat1, assigned(H) == boat1, assigned(X) == boat1, assigned(Y) == boat1)) ::: (E)"
"# Context:
Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.

# Question:
Each of the following is a pair of researchers that could be on team 2 together EXCEPT:

# Options:
A) Franklin and Jones
B) Franklin and Marquez
C) Franklin and Rice
D) Jones and Marquez
E) Jones and Rice","# Declarations
researchers = EnumSort([Franklin, Jones, Marquez, Neil, Osborne, Rice, Samuels])
teams = EnumSort([team1, team2])
included = Function([researchers] -> [teams])
# Constraints
ForAll([r:researchers], Exists([t:teams], included(r) == t)) ::: No researcher will be included in more than one team
ForAll([t:teams], And(Exists([r:researchers], And(included(r) == t, Or(r == Franklin, r == Jones, r == Marquez))), Exists([r:researchers], And(included(r) == t, Or(r == Neil, r == Osborne, r == Rice, r == Samuels))))) ::: Each team must include at least one anthropologist and at least one linguist
ForAll([t:teams], And(included(Franklin) != t, included(Samuels) != t)) ::: Neither team includes both Franklin and Samuels
ForAll([t:teams], And(included(Neil) != t, included(Rice) != t)) ::: Neither team includes both Neil and Rice
ForAll([t:teams], Implies(included(Marquez) == t, And(included(Rice) != t, included(Samuels) != t))) ::: If a team includes Marquez, it includes neither Rice nor Samuels
Implies(included(Jones) == team1, included(Rice) == team2) ::: If team 1 includes Jones, team 2 includes Rice
# Options
is_unsat(And(included(Franklin) == team2, included(Jones) == team2)) ::: (A)
is_unsat(And(included(Franklin) == team2, included(Marquez) == team2)) ::: (B)
is_unsat(And(included(Franklin) == team2, included(Rice) == team2)) ::: (C)
is_unsat(And(included(Jones) == team2, included(Marquez) == team2)) ::: (D)
is_unsat(And(included(Jones) == team2, included(Rice) == team2)) ::: (E)"
"# Context:
A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.

# Question:
If both L and S are reduced, which one of the following could be a pair of areas of expenditure both of which are reduced?

# Options:
A) G, M
B) G, P
C) N, R
D) N, W
E) P, S","# Declarations
areas = EnumSort([G, L, M, N, P, R, S, W])
reduced = Function([areas] -> [bool])
# Constraints
Count([a:areas], reduced(a)) == 5 ::: The committee must reduce exactly five of eight areas of expenditure
Implies(And(reduced(G), reduced(S)), reduced(W)) ::: If both G and S are reduced, W is also reduced
Implies(reduced(N), And(Not(reduced(R)), Not(reduced(S)))) ::: If N is reduced, neither R nor S is reduced
Implies(reduced(P), Not(reduced(L))) ::: If P is reduced, L is not reduced
Count([a:areas], Or(a == L, a == M, a == R)) == 2 ::: Of the three areas L, M, and R, exactly two are reduced
And(reduced(L), reduced(S)) ::: If both L and S are reduced
# Options
is_valid(And(reduced(G), reduced(M))) ::: (A)
is_valid(And(reduced(G), reduced(P))) ::: (B)
is_valid(And(reduced(N), reduced(R))) ::: (C)
is_valid(And(reduced(N), reduced(W))) ::: (D)
is_valid(And(reduced(P), reduced(S))) ::: (E)"
"# Context:
A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.

# Question:
If R is not reduced, which one of the following must be true?

# Options:
A) G is reduced.
B) N is not reduced.
C) P is reduced.
D) S is reduced.
E) W is not reduced.","# Declarations
areas = EnumSort([G, L, M, N, P, R, S, W])
reduced = Function([areas] -> [bool])
# Constraints
Count([a:areas], reduced(a)) == 5 ::: The committee must reduce exactly five of eight areas
Implies(And(reduced(G), reduced(S)), reduced(W)) ::: If both G and S are reduced, W is also reduced
Implies(reduced(N), And(Not(reduced(R)), Not(reduced(S)))) ::: If N is reduced, neither R nor S is reduced
Implies(reduced(P), Not(reduced(L))) ::: If P is reduced, L is not reduced
Count([a:areas], And(a != R, reduced(a))) == 2 ::: Of the three areas L, M, and R, exactly two are reduced
Not(reduced(R)) ::: If R is not reduced
# Options
is_valid(reduced(G)) ::: (A)
is_valid(Not(reduced(N))) ::: (B)
is_valid(reduced(P)) ::: (C)
is_valid(reduced(S)) ::: (D)
is_valid(Not(reduced(W))) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
Which one of the following CANNOT be assigned room 104?

# Options:
A) F
B) G
C) Q
D) S
E) V","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m1:members, m2:members], Implies(m1 != m2, assigned(m1) != assigned(m2))) ::: each member is assigned a different room
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([p:members], Implies(Or(p == F, p == G), Abs(assigned(m) - assigned(p)) > 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([p:members], Implies(Or(p == F, p == G), And(assigned(p) != 101, assigned(p) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:members], Implies(m == G, Abs(assigned(m) - assigned(R)) > 1)) ::: G is not assigned a room next to R's room
ForAll([m:members], Implies(And(m == W, Abs(assigned(m) - assigned(V)) == 1), Abs(assigned(R) - assigned(V)) == 1)) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
# Options
is_unsat(assigned(F) == 104) ::: (A)
is_unsat(assigned(G) == 104) ::: (B)
is_unsat(assigned(Q) == 104) ::: (C)
is_unsat(assigned(S) == 104) ::: (D)
is_unsat(assigned(V) == 104) ::: (E)"
"# Context:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.

# Question:
If Wendy does not eat macaroni on Tuesday, then which one of the following statements could be true?

# Options:
A) Vladimir eats poached eggs for breakfast.
B) Vladimir eats fish for lunch.
C) Vladimir eats hot cakes for lunch.
D) Wendy eats hot cakes for breakfast.
E) Wendy eats fish for dinner.","# Declarations
persons = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([hot_cakes, poached_eggs, omelet, fish, macaroni])
eats = Function([persons, meals] -> [foods])
# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:persons, m1:meals, m2:meals], Implies(m1 != m2, eats(p, m1) != eats(p, m2))) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:persons], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:persons], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch
ForAll([m:meals], eats(Wendy, m) != macaroni) ::: Wendy does not eat macaroni on Tuesday
# Options
is_valid(eats(Vladimir, breakfast) == poached_eggs) ::: (A)
is_valid(eats(Vladimir, lunch) == fish) ::: (B)
is_valid(eats(Vladimir, lunch) == hot_cakes) ::: (C)
is_valid(eats(Wendy, breakfast) == hot_cakes) ::: (D)
is_valid(eats(Wendy, dinner) == fish) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
What is the greatest number of rooms that could be between the rooms to which F and G are assigned?

# Options:
A) one
B) two
C) three
D) four
E) five","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m1:members, m2:members], Implies(m1 != m2, assigned(m1) != assigned(m2))) ::: each member is assigned a different room
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([p:members], Implies(Or(p == F, p == G), Abs(assigned(m) - assigned(p)) > 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([p:members], Implies(Or(p == F, p == G), And(assigned(p) != 101, assigned(p) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
Implies(Abs(assigned(G) - assigned(R)) == 1, False) ::: G is not assigned a room next to R's room
Implies(Abs(assigned(W) - assigned(V)) == 1, Abs(assigned(R) - assigned(V)) == 1) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
# Options
is_valid(Abs(assigned(F) - assigned(G)) == 2) ::: (A)
is_valid(Abs(assigned(F) - assigned(G)) == 3) ::: (B)
is_valid(Abs(assigned(F) - assigned(G)) == 4) ::: (C)
is_valid(Abs(assigned(F) - assigned(G)) == 5) ::: (D)
is_valid(Abs(assigned(F) - assigned(G)) == 6) ::: (E)"
"# Context:
Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.

# Question:
Which one of the following could be a complete and accurate list of the applicants that are interviewed?

# Options:
A) Fu, Gunsel
B) Fu, Jackson
C) Fu, Lee
D) Fu, Gunsel, Lee
E) Fu, Gunsel, Jackson","# Declarations
applicants = EnumSort([Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, Ordoveza])
interviewed = Function([applicants] -> [bool])
hired = Function([applicants] -> [bool])
# Constraints
Implies(interviewed(Gunsel), interviewed(Jackson)) ::: If Gunsel is interviewed, Jackson is interviewed
Implies(interviewed(Jackson), interviewed(Lee)) ::: If Jackson is interviewed, Lee is interviewed
interviewed(Fu) ::: Fu is interviewed
Implies(Not(interviewed(Kowalski)), Not(hired(Fu))) ::: Fu is not hired, unless Kowalski is interviewed
Implies(Not(interviewed(Mayer)), Not(hired(Kowalski))) ::: Kowalski is not hired, unless Mayer is interviewed
Implies(And(hired(Mayer), interviewed(Lee)), hired(Ordoveza)) ::: If Mayer is hired, and Lee is interviewed, Ordoveza is hired
# Options
is_accurate_list([interviewed(Fu), interviewed(Gunsel)]) ::: (A)
is_accurate_list([interviewed(Fu), interviewed(Jackson)]) ::: (B)
is_accurate_list([interviewed(Fu), interviewed(Lee)]) ::: (C)
is_accurate_list([interviewed(Fu), interviewed(Gunsel), interviewed(Lee)]) ::: (D)
is_accurate_list([interviewed(Fu), interviewed(Gunsel), interviewed(Jackson)]) ::: (E)"
"# Context:
Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.

# Question:
If Kenji and Paul are both assigned to the Recycling panel, which one of the following could be true?

# Options:
A) Faith is assigned to the Wetlands panel.
B) Gregory is assigned to the Recycling panel.
C) Harlan is assigned to the Oceans panel.
D) Jennifer is assigned to the Wetlands panel.
E) Lisa is assigned to the Recycling panel.","# Declarations
students = EnumSort([Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, Paul])
panels = EnumSort([Oceans, Recycling, Wetlands])
assigned = Function([students] -> [panels])
# Constraints
ForAll([p:panels], Count([s:students], assigned(s) == p) == 3) ::: Exactly three students will be assigned to each panel
assigned(Faith) == assigned(Gregory) ::: Faith is assigned to the same panel as Gregory
assigned(Kenji) == assigned(Marcus) ::: Kenji is assigned to the same panel as Marcus
assigned(Faith) != assigned(Paul) ::: Faith is not assigned to the same panel as Paul
assigned(Gregory) != assigned(Harlan) ::: Gregory is not assigned to the same panel as Harlan
assigned(Jennifer) != assigned(Kenji) ::: Jennifer is not assigned to the same panel as Kenji
Implies(assigned(Paul) != Oceans, assigned(Harlan) != Oceans) ::: Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel
assigned(Kenji) == Recycling ::: Kenji is assigned to the Recycling panel
assigned(Paul) == Recycling ::: Paul is assigned to the Recycling panel
# Options
is_valid(assigned(Faith) == Wetlands) ::: (A)
is_valid(assigned(Gregory) == Recycling) ::: (B)
is_valid(assigned(Harlan) == Oceans) ::: (C)
is_valid(assigned(Jennifer) == Wetlands) ::: (D)
is_valid(assigned(Lisa) == Recycling) ::: (E)"
"# Context:
A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.

# Question:
If W is reduced, which one of the following could be a complete and accurate list of the four other areas of expenditure to be reduced?

# Options:
A) G, M, P, S
B) L, M, N, R
C) L, M, P, S
D) M, N, P, S
E) M, P, R, S","# Declarations
areas = EnumSort([G, L, M, N, P, R, S, W])
reduced = Function([areas] -> [bool])
# Constraints
Count([a:areas], reduced(a)) == 5 ::: The committee must reduce exactly five of eight areas of expenditure
Implies(And(reduced(G), reduced(S)), reduced(W)) ::: If both G and S are reduced, W is also reduced
Implies(reduced(N), And(Not(reduced(R)), Not(reduced(S)))) ::: If N is reduced, neither R nor S is reduced
Implies(reduced(P), Not(reduced(L))) ::: If P is reduced, L is not reduced
Count([a:areas], And(Or(a == L, a == M, a == R), reduced(a))) == 2 ::: Of the three areas L, M, and R, exactly two are reduced
reduced(W) ::: If W is reduced
# Options
is_accurate_list([reduced(G), reduced(M), reduced(P), reduced(S)]) ::: (A)
is_accurate_list([reduced(L), reduced(M), reduced(N), reduced(R)]) ::: (B)
is_accurate_list([reduced(L), reduced(M), reduced(P), reduced(S)]) ::: (C)
is_accurate_list([reduced(M), reduced(N), reduced(P), reduced(S)]) ::: (D)
is_accurate_list([reduced(M), reduced(P), reduced(R), reduced(S)]) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
If exactly six rugs are selected, they must include

# Options:
A) exactly one of the oval rugs
B) the two oval wool rugs
C) the two rectangular silk rugs
D) exactly three of the rectangular rugs
E) all three rectangular wool rugs","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rectangular_wool1, rectangular_wool2, rectangular_wool3, oval_silk, rectangular_silk1, rectangular_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: At least four rugs must be selected
Count([r:rugs], selected(r)) <= 6 ::: At most six rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == oval_silk))) >= 2 ::: At least two oval rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) >= 2 ::: The number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) <= 3 ::: The number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Exists([r:rugs], And(r != oval_silk, Or(r == rectangular_silk1, r == rectangular_silk2), selected(r)))) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected
Count([r:rugs], selected(r)) == 6 ::: Exactly six rugs are selected
# Options
is_valid(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == oval_silk))) == 1) ::: (A)
is_valid(And(selected(oval_wool1), selected(oval_wool2))) ::: (B)
is_valid(And(selected(rectangular_silk1), selected(rectangular_silk2))) ::: (C)
is_valid(Count([r:rugs], And(selected(r), Or(r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3, r == rectangular_silk1, r == rectangular_silk2))) == 3) ::: (D)
is_valid(And(selected(rectangular_wool1), selected(rectangular_wool2), selected(rectangular_wool3))) ::: (E)"
"# Context:
Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.

# Question:
Each of the following is a pair of students who could be assigned to the same panel as each other EXCEPT:

# Options:
A) Gregory and Kenji
B) Gregory and Lisa
C) Kenji and Nari
D) Lisa and Marcus
E) Lisa and Paul","# Declarations
students = EnumSort([Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, Paul])
panels = EnumSort([Oceans, Recycling, Wetlands])
assigned = Function([students] -> [panels])
# Constraints
Count([s:students], assigned(s) == Oceans) == 3 ::: Exactly three students will be assigned to each panel
Count([s:students], assigned(s) == Recycling) == 3 ::: Exactly three students will be assigned to each panel
Count([s:students], assigned(s) == Wetlands) == 3 ::: Exactly three students will be assigned to each panel
assigned(Faith) == assigned(Gregory) ::: Faith is assigned to the same panel as Gregory
assigned(Kenji) == assigned(Marcus) ::: Kenji is assigned to the same panel as Marcus
assigned(Faith) != assigned(Paul) ::: Faith is not assigned to the same panel as Paul
assigned(Gregory) != assigned(Harlan) ::: Gregory is not assigned to the same panel as Harlan
assigned(Jennifer) != assigned(Kenji) ::: Jennifer is not assigned to the same panel as Kenji
Implies(assigned(Paul) != Oceans, assigned(Harlan) != Oceans) ::: Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel
# Options
is_unsat(assigned(Gregory) == assigned(Kenji)) ::: (A)
is_unsat(assigned(Gregory) == assigned(Lisa)) ::: (B)
is_unsat(assigned(Kenji) == assigned(Nari)) ::: (C)
is_unsat(assigned(Lisa) == assigned(Marcus)) ::: (D)
is_unsat(assigned(Lisa) == assigned(Paul)) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
If R is assigned room 104, which one of the following must be assigned either room 103 or else room 105?

# Options:
A) F
B) G
C) Q
D) V
E) W","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m1:members, m2:members], Implies(m1 != m2, assigned(m1) != assigned(m2))) ::: each member is assigned a different room
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([p:members], Implies(Or(p == F, p == G), Abs(assigned(m) - assigned(p)) != 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([p:members], Implies(Or(p == F, p == G), And(assigned(p) != 101, assigned(p) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:members], Implies(m == G, Abs(assigned(m) - assigned(R)) != 1)) ::: G is not assigned a room next to R's room
ForAll([m:members], Implies(m == W, Implies(Abs(assigned(m) - assigned(V)) == 1, Abs(assigned(R) - assigned(V)) == 1))) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
assigned(R) == 104 ::: R is assigned room 104
# Options
is_valid(Or(assigned(F) == 103, assigned(F) == 105)) ::: (A)
is_valid(Or(assigned(G) == 103, assigned(G) == 105)) ::: (B)
is_valid(Or(assigned(Q) == 103, assigned(Q) == 105)) ::: (C)
is_valid(Or(assigned(V) == 103, assigned(V) == 105)) ::: (D)
is_valid(Or(assigned(W) == 103, assigned(W) == 105)) ::: (E)"
"# Context:
A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.

# Question:
If G is to come immediately before H but all the other conditions remain in effect, any of the following could be true EXCEPT:

# Options:
A) J comes immediately before F.
B) K comes immediately before G.
C) J comes immediately after L.
D) J comes immediately after K.
E) K comes immediately after M.","# Declarations
pieces = EnumSort([F, G, H, J, K, L, M])
tracks = EnumSort([1, 2, 3, 4, 5, 6, 7])
position = Function([pieces] -> [tracks])
# Constraints
position(F) == 2 ::: F must be second
position(J) != 7 ::: J cannot be seventh
ForAll([t:tracks], Not(And(position(G) == t, position(H) == t + 1))) ::: G can come neither immediately before nor immediately after H
ForAll([t:tracks], Not(And(position(G) == t, position(H) == t - 1))) ::: G can come neither immediately before nor immediately after H
position(H) < position(L) ::: H must be in some track before that of L
position(L) < position(M) ::: L must be in some track before that of M
position(G) == position(H) - 1 ::: G is to come immediately before H
# Options
is_unsat(And(position(J) == position(F) - 1)) ::: (A)
is_unsat(And(position(K) == position(G) - 1)) ::: (B)
is_unsat(And(position(J) == position(L) + 1)) ::: (C)
is_unsat(And(position(J) == position(K) + 1)) ::: (D)
is_unsat(And(position(K) == position(M) + 1)) ::: (E)"
"# Context:
At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.

# Question:
Each of the following is an acceptable schedule for the performance of the songs, in order from the first to last song performed, EXCEPT:

# Options:
A) Y, O, P, T, Z, X
B) Y, T, O, P, X, Z
C) Y, X, O, P, Z, T
D) X, Y, O, P, Z, T
E) X, Y, O, T, P, Z","# Declarations
songs = EnumSort([O, P, T, X, Y, Z])
vocalists = EnumSort([George, Helen, Leslie])
performed = Function([songs] -> [vocalists])
order = Function([songs] -> [int])
# Constraints
ForAll([s:songs], Exists([s1:songs], And(s1 != s, order(s1) < order(s)))) ::: The songs will be sung consecutively as solos, and each will be performed exactly once
order(Y) < order(T) ::: Y must be performed earlier than T
order(Y) < order(O) ::: Y must be performed earlier than O
order(P) < order(Z) ::: P must be performed earlier than Z
order(O) < order(P) ::: P must be performed later than O
ForAll([s:songs], Or(And(performed(s) == George, Or(s == X, s == Y, s == Z)), And(performed(s) == Helen, Or(s == T, s == P, s == X)), And(performed(s) == Leslie, Or(s == O, s == P, s == X)))) ::: George can perform only X, Y, and Z; Helen can perform only T, P, and X; Leslie can perform only O, P, and X
Exists([s:songs], And(order(s) == 1, performed(s) != performed(s1), order(s1) == 6)) ::: The vocalist who performs first must be different from the vocalist who performs last
# Options
is_unsat(And(order(Y) == 1, order(O) == 2, order(P) == 3, order(T) == 4, order(Z) == 5, order(X) == 6)) ::: (A)
is_unsat(And(order(Y) == 1, order(T) == 2, order(O) == 3, order(P) == 4, order(X) == 5, order(Z) == 6)) ::: (B)
is_unsat(And(order(Y) == 1, order(X) == 2, order(O) == 3, order(P) == 4, order(Z) == 5, order(T) == 6)) ::: (C)
is_unsat(And(order(X) == 1, order(Y) == 2, order(O) == 3, order(P) == 4, order(Z) == 5, order(T) == 6)) ::: (D)
is_unsat(And(order(X) == 1, order(Y) == 2, order(O) == 3, order(T) == 4, order(P) == 5, order(Z) == 6)) ::: (E)"
"# Context:
A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.

# Question:
Which one of the following could be a complete and accurate list of the areas of expenditure reduced by the committee?

# Options:
A) G, L, M, N, W
B) G, L, M, P, W
C) G, M, N, R, W
D) G, M, P, R, S
E) L, M, R, S, W","# Declarations
areas = EnumSort([G, L, M, N, P, R, S, W])
reduced = Function([areas] -> [bool])
# Constraints
Count([a:areas], reduced(a)) == 5 ::: The committee must reduce exactly five of eight areas of expenditure
Implies(And(reduced(G), reduced(S)), reduced(W)) ::: If both G and S are reduced, W is also reduced
Implies(reduced(N), And(Not(reduced(R)), Not(reduced(S)))) ::: If N is reduced, neither R nor S is reduced
Implies(reduced(P), Not(reduced(L))) ::: If P is reduced, L is not reduced
Count([a:areas], And(Or(a == L, a == M, a == R), reduced(a))) == 2 ::: Of the three areas L, M, and R, exactly two are reduced
# Options
is_accurate_list([reduced(G), reduced(L), reduced(M), reduced(N), reduced(W)]) ::: (A)
is_accurate_list([reduced(G), reduced(L), reduced(M), reduced(P), reduced(W)]) ::: (B)
is_accurate_list([reduced(G), reduced(M), reduced(N), reduced(R), reduced(W)]) ::: (C)
is_accurate_list([reduced(G), reduced(M), reduced(P), reduced(R), reduced(S)]) ::: (D)
is_accurate_list([reduced(L), reduced(M), reduced(R), reduced(S), reduced(W)]) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
If all three silk rugs are selected, then each of the following could be a complete and accurate list of the other rugs selected EXCEPT:

# Options:
A) one oval wool rug
B) two oval wool rugs
C) one oval wool rug and one rectangular wool rug
D) one oval wool rug and two rectangular wool rugs
E) two oval wool rugs and one rectangular wool rug","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rectangular_wool1, rectangular_wool2, rectangular_wool3, oval_silk, rectangular_silk1, rectangular_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: The coordinator will select at least four rugs
Count([r:rugs], selected(r)) <= 6 ::: The coordinator will select at most six rugs
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) >= 2 ::: At least two oval rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) >= 2 ::: The number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) <= 3 ::: The number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Count([r:rugs], And(selected(r), Or(r == rectangular_silk1, r == rectangular_silk2))) >= 1) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected
selected(oval_silk) ::: All three silk rugs are selected
selected(rectangular_silk1) ::: All three silk rugs are selected
selected(rectangular_silk2) ::: All three silk rugs are selected
# Options
is_accurate_list([selected(oval_wool1)]) ::: (A)
is_accurate_list([selected(oval_wool1), selected(oval_wool2)]) ::: (B)
is_accurate_list([selected(oval_wool1), selected(rectangular_wool1)]) ::: (C)
is_accurate_list([selected(oval_wool1), selected(rectangular_wool1), selected(rectangular_wool2)]) ::: (D)
is_accurate_list([selected(oval_wool1), selected(oval_wool2), selected(rectangular_wool1)]) ::: (E)"
"# Context:
Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.

# Question:
Which one of the following is a pair of students who could be assigned to the same panel as each other?

# Options:
A) Faith and Harlan
B) Gregory and Paul
C) Harlan and Marcus
D) Faith and Marcus
E) Jennifer and Marcus","# Declarations
students = EnumSort([Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, Paul])
panels = EnumSort([Oceans, Recycling, Wetlands])
assigned = Function([students] -> [panels])
# Constraints
ForAll([p:panels], Count([s:students], assigned(s) == p) == 3) ::: Exactly three students will be assigned to each panel
assigned(Faith) == assigned(Gregory) ::: Faith is assigned to the same panel as Gregory
assigned(Kenji) == assigned(Marcus) ::: Kenji is assigned to the same panel as Marcus
assigned(Faith) != assigned(Paul) ::: Faith is not assigned to the same panel as Paul
assigned(Gregory) != assigned(Harlan) ::: Gregory is not assigned to the same panel as Harlan
assigned(Jennifer) != assigned(Kenji) ::: Jennifer is not assigned to the same panel as Kenji
Implies(assigned(Paul) != Oceans, assigned(Harlan) != Oceans) ::: Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel
# Options
is_valid(assigned(Faith) == assigned(Harlan)) ::: (A)
is_valid(assigned(Gregory) == assigned(Paul)) ::: (B)
is_valid(assigned(Harlan) == assigned(Marcus)) ::: (C)
is_valid(assigned(Faith) == assigned(Marcus)) ::: (D)
is_valid(assigned(Jennifer) == assigned(Marcus)) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
Which one of the following is a possible assignment of rooms for members R, V, and W?

# Options:
A) 101: V; 102: W; 103: R
B) 101: V; 102: W, 104: R
C) 101: V; 103: W; 104: R
D) 103: W; 104: V; 106: R
E) 105: R; 106: W; 107: V","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m:members], Exists([r:rooms], assigned(m) == r)) ::: Each member is assigned a different room
ForAll([m:members], ForAll([r:rooms], Implies(assigned(m) == r, ForAll([m2:members], Implies(m2 != m, assigned(m2) != r))))) ::: Each room is assigned to exactly one member
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([m2:members], Implies(Or(m2 == F, m2 == G), Abs(assigned(m) - assigned(m2)) != 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([m:members], Implies(Or(m == F, m == G), And(assigned(m) != 101, assigned(m) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:members], Implies(m == G, ForAll([m2:members], Implies(m2 == R, Abs(assigned(m) - assigned(m2)) != 1)))) ::: G is not assigned a room next to R's room
ForAll([m:members], Implies(m == W, Implies(Abs(assigned(m) - assigned(V)) == 1, Abs(assigned(R) - assigned(V)) == 1))) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
# Options
is_sat(And(assigned(V) == 101, assigned(W) == 102, assigned(R) == 103)) ::: (A)
is_sat(And(assigned(V) == 101, assigned(W) == 102, assigned(R) == 104)) ::: (B)
is_sat(And(assigned(V) == 101, assigned(W) == 103, assigned(R) == 104)) ::: (C)
is_sat(And(assigned(W) == 103, assigned(V) == 104, assigned(R) == 106)) ::: (D)
is_sat(And(assigned(R) == 105, assigned(W) == 106, assigned(V) == 107)) ::: (E)"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
Which one of the following CANNOT be true?

# Options:
A) F and G are each assigned to exactly one committee.
B) F and H are each assigned to exactly one committee.
C) G and H are each assigned to exactly one committee.
D) F and M are both assigned to the Sales Committee.
E) G and K are both assigned to the Quality Committee.","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees, committees] -> [bool])
# Constraints
ForAll([c:committees], Exists([e:employees], And(assigned(e, c), Or(e == F, e == G, e == H)))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e, c))) ::: Each employee must be assigned to at least one committee
ForAll([e:employees], Implies(Or(e == F, e == G, e == H), assigned(e, Policy))) ::: All three officers must be assigned to the Policy Committee
ForAll([c:committees], Implies(And(assigned(G, c), assigned(L, c)), False)) ::: G cannot be assigned to the same committee as L
ForAll([e:employees], assigned(K, Sales)) ::: K must be assigned to the Sales Committee
# Options
is_unsat(And(Count([c:committees], assigned(F, c)) == 1, Count([c:committees], assigned(G, c)) == 1)) ::: (A)
is_unsat(And(Count([c:committees], assigned(F, c)) == 1, Count([c:committees], assigned(H, c)) == 1)) ::: (B)
is_unsat(And(Count([c:committees], assigned(G, c)) == 1, Count([c:committees], assigned(H, c)) == 1)) ::: (C)
is_unsat(And(assigned(F, Sales), assigned(M, Sales))) ::: (D)
is_unsat(And(assigned(G, Quality), assigned(K, Quality))) ::: (E)"
"# Context:
Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.

# Question:
Which one of the following is a pair of travelers who could be assigned to seats 2 and 8, respectively?

# Options:
A) Norris, Semonelli
B) Oribe, Underwood
C) Paulsen, Oribe
D) Rosen, Semonelli
E) Underwood, Tan","# Declarations
travelers = EnumSort([Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, Underwood])
seats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
assigned = Function([travelers] -> [seats])
# Constraints
assigned(Oribe) == 7 or assigned(Oribe) == 8 or assigned(Oribe) == 9 ::: Oribe's seat is in the last row
Or(And(assigned(Paulsen) == assigned(Rosen) + 1, assigned(Paulsen) % 3 != 0), And(assigned(Paulsen) == assigned(Rosen) - 1, assigned(Paulsen) % 3 != 1)) ::: Paulsen's seat is immediately beside Rosen's seat
Or(And(assigned(Paulsen) == 1, assigned(Rosen) == 2), And(assigned(Paulsen) == 2, assigned(Rosen) == 1), And(assigned(Paulsen) == 2, assigned(Rosen) == 3), And(assigned(Paulsen) == 3, assigned(Rosen) == 2), And(assigned(Paulsen) == 4, assigned(Rosen) == 5), And(assigned(Paulsen) == 5, assigned(Rosen) == 4), And(assigned(Paulsen) == 5, assigned(Rosen) == 6), And(assigned(Paulsen) == 6, assigned(Rosen) == 5), And(assigned(Paulsen) == 7, assigned(Rosen) == 8), And(assigned(Paulsen) == 8, assigned(Rosen) == 7), And(assigned(Paulsen) == 8, assigned(Rosen) == 9), And(assigned(Paulsen) == 9, assigned(Rosen) == 8)) ::: Paulsen's seat is immediately beside an unassigned seat
assigned(Rosen) == assigned(Norris) + 3 or assigned(Rosen) == assigned(Norris) - 3 ::: Rosen's seat is in the row immediately behind the row in which Norris' seat is located
ForAll([t:travelers], Implies(Or(t == Semonelli, t == Underwood), Not(Or(assigned(t) == assigned(Norris) + 1, assigned(t) == assigned(Norris) - 1, assigned(t) == assigned(Norris) + 3, assigned(t) == assigned(Norris) - 3)))) ::: Neither Semonelli nor Underwood is seated immediately beside Norris
# Options
is_valid(And(assigned(Norris) == 2, assigned(Semonelli) == 8)) ::: (A)
is_valid(And(assigned(Oribe) == 2, assigned(Underwood) == 8)) ::: (B)
is_valid(And(assigned(Paulsen) == 2, assigned(Oribe) == 8)) ::: (C)
is_valid(And(assigned(Rosen) == 2, assigned(Semonelli) == 8)) ::: (D)
is_valid(And(assigned(Underwood) == 2, assigned(Tan) == 8)) ::: (E)"
"# Context:
At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.

# Question:
Which one of the following is a list of all and only those sponsors any one of whom could be among the sponsors assigned to table 3?

# Options:
A) P, Q
B) Q, Z
C) P, Q, Z
D) Q, V, Z
E) P, Q, V, Z","# Declarations
sponsors = EnumSort([K, L, M, P, Q, V, Z])
tables = EnumSort([1, 2, 3])
seated = Function([sponsors] -> [tables])
honors = Function([sponsors] -> [bool])
speeches = Function([sponsors] -> [bool])
# Constraints
ForAll([t:tables], Count([s:sponsors], seated(s) == t) >= 2) ::: Each table has at least two sponsors seated at it
ForAll([s:sponsors], Exists([t:tables], seated(s) == t)) ::: Each sponsor is seated at exactly one table
ForAll([s:sponsors], Implies(honors(s), Or(seated(s) == 1, seated(s) == 2))) ::: Any sponsor receiving honors is seated at table 1 or table 2
seated(L) == seated(V) ::: L is seated at the same table as V
# Options
is_accurate_list([seated(P) == 3, seated(Q) == 3]) ::: (A)
is_accurate_list([seated(Q) == 3, seated(Z) == 3]) ::: (B)
is_accurate_list([seated(P) == 3, seated(Q) == 3, seated(Z) == 3]) ::: (C)
is_accurate_list([seated(Q) == 3, seated(V) == 3, seated(Z) == 3]) ::: (D)
is_accurate_list([seated(P) == 3, seated(Q) == 3, seated(V) == 3, seated(Z) == 3]) ::: (E)"
"# Context:
Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.

# Question:
If Oribe is assigned to a seat immediately beside one of the unassigned seats, which one of the following must be true?

# Options:
A) Oribe is assigned to seat 8.
B) Tan is assigned to seat 2.
C) Underwood is assigned to seat 1.
D) Seat 4 is unassigned.
E) Seat 9 is unassigned.","# Declarations
travelers = EnumSort([Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, Underwood])
seats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
assigned = Function([travelers] -> [seats])
unassigned = Function([seats] -> [bool])
# Constraints
assigned(Oribe) == 7 or assigned(Oribe) == 8 or assigned(Oribe) == 9 ::: Oribe's seat is in the last row
Or(And(assigned(Paulsen) == assigned(Rosen) + 1, assigned(Paulsen) % 3 != 0), And(assigned(Paulsen) == assigned(Rosen) - 1, assigned(Paulsen) % 3 != 1)) ::: Paulsen's seat is immediately beside Rosen's seat
Exists([s:seats], And(unassigned(s), Or(assigned(Paulsen) == s + 1, assigned(Paulsen) == s - 1))) ::: Paulsen's seat is immediately beside an unassigned seat
assigned(Rosen) == assigned(Norris) + 3 or assigned(Rosen) == assigned(Norris) - 3 ::: Rosen's seat is in the row immediately behind the row in which Norris' seat is located
ForAll([t:travelers], Implies(Or(t == Semonelli, t == Underwood), Not(Or(assigned(t) == assigned(Norris) + 1, assigned(t) == assigned(Norris) - 1)))) ::: Neither Semonelli nor Underwood is seated immediately beside Norris
Or(assigned(Oribe) == 7, assigned(Oribe) == 8) ::: Oribe is assigned to a seat immediately beside one of the unassigned seats
# Options
is_valid(assigned(Oribe) == 8) ::: (A)
is_valid(assigned(Tan) == 2) ::: (B)
is_valid(assigned(Underwood) == 1) ::: (C)
is_valid(unassigned(4)) ::: (D)
is_valid(unassigned(9)) ::: (E)"
"# Context:
Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.

# Question:
If Marcus and Paul are both assigned to the Wetlands panel, which one of the following must be true?

# Options:
A) Harlan is assigned to the Recycling panel.
B) Jennifer is assigned to the Oceans panel.
C) Kenji is assigned to the Recycling panel.
D) Lisa is assigned to the Wetlands panel.
E) Nari is assigned to the Oceans panel.","# Declarations
students = EnumSort([Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, Paul])
panels = EnumSort([Oceans, Recycling, Wetlands])
assigned = Function([students] -> [panels])
# Constraints
ForAll([p:panels], Count([s:students], assigned(s) == p) == 3) ::: Exactly three of the students will be assigned to each panel
assigned(Faith) == assigned(Gregory) ::: Faith is assigned to the same panel as Gregory
assigned(Kenji) == assigned(Marcus) ::: Kenji is assigned to the same panel as Marcus
assigned(Faith) != assigned(Paul) ::: Faith is not assigned to the same panel as Paul
assigned(Gregory) != assigned(Harlan) ::: Gregory is not assigned to the same panel as Harlan
assigned(Jennifer) != assigned(Kenji) ::: Jennifer is not assigned to the same panel as Kenji
Implies(assigned(Paul) != Oceans, assigned(Harlan) != Oceans) ::: Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel
assigned(Marcus) == Wetlands ::: Marcus is assigned to the Wetlands panel
assigned(Paul) == Wetlands ::: Paul is assigned to the Wetlands panel
# Options
is_valid(assigned(Harlan) == Recycling) ::: (A)
is_valid(assigned(Jennifer) == Oceans) ::: (B)
is_valid(assigned(Kenji) == Recycling) ::: (C)
is_valid(assigned(Lisa) == Wetlands) ::: (D)
is_valid(assigned(Nari) == Oceans) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
If exactly four rugs are selected, then the rugs selected could be

# Options:
A) one oval rug and three rectangular wool rugs
B) two oval rugs and two rectangular wool rugs
C) three oval rugs and one rectangular silk rug
D) three oval rugs and one rectangular wool rug
E) two rectangular silk rugs and two rectangular wool rugs","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rect_wool1, rect_wool2, rect_wool3, oval_silk, rect_silk1, rect_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: at least four rugs must be selected
Count([r:rugs], selected(r)) <= 6 ::: at most six rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) >= 2 ::: at least two oval rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3))) >= 2 ::: the number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3))) <= 3 ::: the number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Count([r:rugs], And(selected(r), Or(r == rect_silk1, r == rect_silk2))) >= 1) ::: if the oval silk rug is selected, at least one rectangular silk rug must be selected
Count([r:rugs], selected(r)) == 4 ::: exactly four rugs are selected
# Options
is_accurate_list([selected(oval_wool1), selected(rect_wool1), selected(rect_wool2), selected(rect_wool3)]) ::: (A)
is_accurate_list([selected(oval_wool1), selected(oval_wool2), selected(rect_wool1), selected(rect_wool2)]) ::: (B)
is_accurate_list([selected(rect_silk1), selected(rect_silk2), selected(rect_wool1), selected(rect_wool2)]) ::: (E)"
"# Context:
In a theater company, four two-day workshops—Lighting, Production, Rehearsals, and Staging—are conducted over the course of five days, Monday through Friday. The workshops are conducted in a manner consistent with the following constraints: The two days on which a given workshop is in session are consecutive. On each of the five days, at least one, but no more than two, of the workshops are in session. The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of the workshop on Lighting.

# Question:
Which one of the following could be true?

# Options:
A) The workshop on Lighting is in session on Wednesday, and the workshop on Rehearsals is in session on Tuesday.
B) The workshop on Lighting is in session on Wednesday, and the only workshop in session on Thursday is the workshop on Rehearsals.
C) The workshop on Lighting is in session on Wednesday, and the only workshop in session on Monday is the workshop on Staging.
D) The workshop on Lighting is in session on Monday, and the only workshop in session on Thursday is the workshop on Staging.
E) The workshops on Lighting and Production are both in session on Wednesday.","# Declarations
workshops = EnumSort([Lighting, Production, Rehearsals, Staging])
days = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])
in_session = Function([workshops, days] -> [bool])
# Constraints
ForAll([w:workshops], Exists([d:days], in_session(w, d))) ::: Each workshop is in session on at least one day
# Options"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
If L is assigned to exactly two committees, which of the following must be true?

# Options:
A) F is assigned to the Sales Committee.
B) G is assigned to the Sales Committee.
C) H is assigned to the Quality Committee.
D) K is assigned to the Quality Committee.
E) M is assigned to the Quality Committee.","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees, committees] -> [bool])
# Constraints
ForAll([c:committees], Exists([e:employees], assigned(e, c))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e, c))) ::: Each employee must be assigned to at least one committee
ForAll([e:employees], Implies(Or(e == F, e == G, e == H), assigned(e, Policy))) ::: All three officers must be assigned to the Policy Committee
ForAll([c:committees], Implies(assigned(G, c), Not(assigned(L, c)))) ::: G cannot be assigned to the same committee as L
ForAll([c:committees], Implies(c == Sales, assigned(K, c))) ::: K must be assigned to the Sales Committee
Count([c:committees], assigned(L, c)) == 2 ::: L is assigned to exactly two committees
# Options
is_valid(assigned(F, Sales)) ::: (A)
is_valid(assigned(G, Sales)) ::: (B)
is_valid(assigned(H, Quality)) ::: (C)
is_valid(assigned(K, Quality)) ::: (D)
is_valid(assigned(M, Quality)) ::: (E)"
"# Context:
Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.

# Question:
If the seat to which Tan is assigned is immediately beside a seat assigned to another traveler and also immediately beside one of the unassigned seats, which one of the following must be true?

# Options:
A) Tan is assigned to a seat in the front row.
B) Tan is assigned to a seat in the last row.
C) Oribe is assigned to a seat immediately beside Semonelli.
D) Oribe is assigned to a seat immediately beside Tan.
E) Semonelli is assigned to a seat immediately beside Underwood.","# Declarations
travelers = EnumSort([Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, Underwood])
seats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9])
assigned = Function([travelers] -> [seats])
# Constraints
assigned(Oribe) >= 7 ::: Oribe's seat is in the last row
Or(And(assigned(Paulsen) == assigned(Rosen) + 1, assigned(Paulsen) % 3 != 0), And(assigned(Paulsen) == assigned(Rosen) - 1, assigned(Paulsen) % 3 != 1)) ::: Paulsen's seat is immediately beside Rosen's seat
Or(And(assigned(Paulsen) == 3, assigned(Rosen) != 2), And(assigned(Paulsen) == 6, assigned(Rosen) != 5), And(assigned(Paulsen) == 9, assigned(Rosen) != 8)) ::: Paulsen's seat is immediately beside an unassigned seat
assigned(Rosen) == assigned(Norris) + 3 ::: Rosen's seat is in the row immediately behind the row in which Norris' seat is located
ForAll([t:travelers], Implies(t != Semonelli, Not(Or(assigned(t) == assigned(Norris) + 1, assigned(t) == assigned(Norris) - 1)))) ::: Neither Semonelli nor Underwood is seated immediately beside Norris
ForAll([t:travelers], Implies(t != Underwood, Not(Or(assigned(t) == assigned(Norris) + 1, assigned(t) == assigned(Norris) - 1)))) ::: Neither Semonelli nor Underwood is seated immediately beside Norris
Exists([t:travelers], And(t != Tan, Or(assigned(Tan) == assigned(t) + 1, assigned(Tan) == assigned(t) - 1))) ::: Tan's seat is immediately beside a seat assigned to another traveler
Or(And(assigned(Tan) == 3, assigned(Tan) != 2), And(assigned(Tan) == 6, assigned(Tan) != 5), And(assigned(Tan) == 9, assigned(Tan) != 8)) ::: Tan's seat is immediately beside one of the unassigned seats
# Options
is_valid(assigned(Tan) <= 3) ::: (A)
is_valid(assigned(Tan) >= 7) ::: (B)
is_valid(Or(assigned(Oribe) == assigned(Semonelli) + 1, assigned(Oribe) == assigned(Semonelli) - 1)) ::: (C)
is_valid(Or(assigned(Oribe) == assigned(Tan) + 1, assigned(Oribe) == assigned(Tan) - 1)) ::: (D)
is_valid(Or(assigned(Semonelli) == assigned(Underwood) + 1, assigned(Semonelli) == assigned(Underwood) - 1)) ::: (E)"
"# Context:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.

# Question:
If both Vladimir and Wendy eat macaroni on Tuesday, then which one of the following statements could be true?

# Options:
A) Vladimir eats fish for lunch.
B) Vladimir eats hot cakes for lunch.
C) Vladimir eats macaroni for dinner.
D) Wendy eats hot cakes for breakfast.
E) Wendy eats hot cakes for dinner.","# Declarations
persons = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([hot_cakes, poached_eggs, omelet, fish, macaroni])
eats = Function([persons, meals] -> [foods])
# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:persons, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:persons], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:persons], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch
eats(Vladimir, lunch) == macaroni ::: Vladimir eats macaroni for lunch
eats(Wendy, dinner) == macaroni ::: Wendy eats macaroni for dinner
# Options
is_valid(eats(Vladimir, lunch) == fish) ::: (A)
is_valid(eats(Vladimir, lunch) == hot_cakes) ::: (B)
is_valid(eats(Vladimir, dinner) == macaroni) ::: (C)
is_valid(eats(Wendy, breakfast) == hot_cakes) ::: (D)
is_valid(eats(Wendy, dinner) == hot_cakes) ::: (E)"
"# Context:
The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.

# Question:
If F and G are assigned rooms that have exactly one room between them, which one of the following is the list of department members each of whom could be assigned to the intervening room?

# Options:
A) Q, R
B) Q, S
C) Q, V
D) R, W
E) S, V","# Declarations
members = EnumSort([F, G, Q, R, S, V, W])
rooms = EnumSort([101, 102, 103, 104, 105, 106, 107])
assigned = Function([members] -> [rooms])
# Constraints
ForAll([m1:members, m2:members], Implies(m1 != m2, assigned(m1) != assigned(m2))) ::: each member is assigned a different room
ForAll([m:members], Implies(Or(m == V, m == W), ForAll([p:members], Implies(Or(p == F, p == G), Abs(assigned(m) - assigned(p)) != 1)))) ::: Neither instructor is assigned a room next to a professor's room
ForAll([p:members], Implies(Or(p == F, p == G), And(assigned(p) != 101, assigned(p) != 107))) ::: Neither professor is assigned room 101 and neither professor is assigned room 107
ForAll([m:members], Implies(m == G, Abs(assigned(m) - assigned(R)) != 1)) ::: G is not assigned a room next to R's room
ForAll([m:members], Implies(And(m == W, Abs(assigned(m) - assigned(V)) == 1), Abs(assigned(R) - assigned(V)) == 1)) ::: W is not assigned a room next to V's room unless R is also assigned a room next to V's room
Exists([r:rooms], And(Abs(assigned(F) - assigned(G)) == 2, r == (assigned(F) + assigned(G)) / 2)) ::: F and G are assigned rooms that have exactly one room between them
# Options
is_accurate_list([assigned(Q) == (assigned(F) + assigned(G)) / 2, assigned(R) == (assigned(F) + assigned(G)) / 2]) ::: (A)
is_accurate_list([assigned(Q) == (assigned(F) + assigned(G)) / 2, assigned(S) == (assigned(F) + assigned(G)) / 2]) ::: (B)
is_accurate_list([assigned(Q) == (assigned(F) + assigned(G)) / 2, assigned(V) == (assigned(F) + assigned(G)) / 2]) ::: (C)
is_accurate_list([assigned(R) == (assigned(F) + assigned(G)) / 2, assigned(W) == (assigned(F) + assigned(G)) / 2]) ::: (D)
is_accurate_list([assigned(S) == (assigned(F) + assigned(G)) / 2, assigned(V) == (assigned(F) + assigned(G)) / 2]) ::: (E)"
"# Context:
Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.

# Question:
Which one of the following is an acceptable assignment of students to the panels?

# Options:
A) Oceans: Faith, Gregory, Jennifer Recycling: Kenji, Lisa, Nari Wetlands: Harlan, Marcus, Paul
B) Oceans: Faith, Jennifer, Lisa Recycling: Harlan, Kenji, Marcus Wetlands: Gregory, Nari, Paul
C) Oceans: Harlan, Kenji, Marcus Recycling: Faith, Gregory, Jennifer Wetlands: Lisa, Nari, Paul
D) Oceans: Jennifer, Kenji, Marcus Recycling: Faith, Gregory, Nari Wetlands: Harlan, Lisa, Paul
E) Oceans: Kenji, Marcus, Paul Recycling: Harlan, Jennifer, Nari Wetlands: Faith, Gregory, Lisa","# Declarations
students = EnumSort([Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, Paul])
panels = EnumSort([Oceans, Recycling, Wetlands])
assigned = Function([students] -> [panels])
# Constraints
ForAll([p:panels], Count([s:students], assigned(s) == p) == 3) ::: Exactly three of the students will be assigned to each panel
assigned(Faith) == assigned(Gregory) ::: Faith is assigned to the same panel as Gregory
assigned(Kenji) == assigned(Marcus) ::: Kenji is assigned to the same panel as Marcus
assigned(Faith) != assigned(Paul) ::: Faith is not assigned to the same panel as Paul
assigned(Gregory) != assigned(Harlan) ::: Gregory is not assigned to the same panel as Harlan
assigned(Jennifer) != assigned(Kenji) ::: Jennifer is not assigned to the same panel as Kenji
Implies(assigned(Paul) != Oceans, assigned(Harlan) != Oceans) ::: Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel
# Options
is_sat(And(assigned(Faith) == Oceans, assigned(Gregory) == Oceans, assigned(Jennifer) == Oceans, assigned(Kenji) == Recycling, assigned(Lisa) == Recycling, assigned(Nari) == Recycling, assigned(Harlan) == Wetlands, assigned(Marcus) == Wetlands, assigned(Paul) == Wetlands)) ::: (A)
is_sat(And(assigned(Faith) == Oceans, assigned(Jennifer) == Oceans, assigned(Lisa) == Oceans, assigned(Harlan) == Recycling, assigned(Kenji) == Recycling, assigned(Marcus) == Recycling, assigned(Gregory) == Wetlands, assigned(Nari) == Wetlands, assigned(Paul) == Wetlands)) ::: (B)
is_sat(And(assigned(Harlan) == Oceans, assigned(Kenji) == Oceans, assigned(Marcus) == Oceans, assigned(Faith) == Recycling, assigned(Gregory) == Recycling, assigned(Jennifer) == Recycling, assigned(Lisa) == Wetlands, assigned(Nari) == Wetlands, assigned(Paul) == Wetlands)) ::: (C)
is_sat(And(assigned(Jennifer) == Oceans, assigned(Kenji) == Oceans, assigned(Marcus) == Oceans, assigned(Faith) == Recycling, assigned(Gregory) == Recycling, assigned(Nari) == Recycling, assigned(Harlan) == Wetlands, assigned(Lisa) == Wetlands, assigned(Paul) == Wetlands)) ::: (D)
is_sat(And(assigned(Kenji) == Oceans, assigned(Marcus) == Oceans, assigned(Paul) == Oceans, assigned(Harlan) == Recycling, assigned(Jennifer) == Recycling, assigned(Nari) == Recycling, assigned(Faith) == Wetlands, assigned(Gregory) == Wetlands, assigned(Lisa) == Wetlands)) ::: (E)"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
Which one of the following is a group of three employees who can be assigned together to the Quality Committee?

# Options:
A) F, G, and H
B) F, G, and K
C) G, H, and K
D) G, K, and L
E) H, L, and M","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees] -> [committees])
# Constraints
ForAll([c:committees], Exists([e:employees], And(assigned(e) == c, Or(e == F, e == G, e == H)))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e) == c)) ::: Each employee must be assigned to at least one committee
ForAll([e:employees], Implies(Or(e == F, e == G, e == H), assigned(e) == Policy)) ::: All three officers must be assigned to the Policy Committee
assigned(G) != assigned(L) ::: G cannot be assigned to the same committee as L
assigned(K) == Sales ::: K must be assigned to the Sales Committee
# Options
is_accurate_list([assigned(F) == Quality, assigned(G) == Quality, assigned(H) == Quality]) ::: (A)
is_accurate_list([assigned(F) == Quality, assigned(G) == Quality, assigned(K) == Quality]) ::: (B)
is_accurate_list([assigned(G) == Quality, assigned(H) == Quality, assigned(K) == Quality]) ::: (C)
is_accurate_list([assigned(G) == Quality, assigned(K) == Quality, assigned(L) == Quality]) ::: (D)
is_accurate_list([assigned(H) == Quality, assigned(L) == Quality, assigned(M) == Quality]) ::: (E)"
"# Context:
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.

# Question:
Vladimir must eat which one of the following foods?

# Options:
A) fish
B) hot cakes
C) macaroni
D) omelet
E) poached eggs","# Declarations
persons = EnumSort([Vladimir, Wendy])
meals = EnumSort([breakfast, lunch, dinner, snack])
foods = EnumSort([hot_cakes, poached_eggs, omelet, fish, macaroni])
eats = Function([persons, meals] -> [foods])
# Constraints
ForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy
ForAll([p:persons, m1:meals, m2:meals], Implies(m1 != m2, eats(p, m1) != eats(p, m2))) ::: Neither of them eats the same kind of food more than once during the day
ForAll([p:persons], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet
ForAll([p:persons], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet
ForAll([p:persons], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet
eats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch
# Options
is_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)
is_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)
is_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)
is_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)
is_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
If F is assigned to exactly three committees, and G is assigned to exactly two committees, then which one of the following must be true?

# Options:
A) G is assigned to the Quality Committee.
B) G is assigned to the Sales Committee.
C) K is assigned to the Quality Committee.
D) L is assigned to the Sales Committee.
E) M is assigned to the Quality Committee.","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees, committees] -> [bool])
# Constraints
ForAll([c:committees], Exists([e:employees], And(assigned(e, c), Or(e == F, e == G, e == H)))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e, c))) ::: Each employee must be assigned to at least one committee
ForAll([e:employees], Implies(e == F, And(assigned(e, Policy), assigned(e, Quality), assigned(e, Sales)))) ::: F is assigned to exactly three committees
ForAll([e:employees], Implies(e == G, And(Count([c:committees], assigned(e, c)) == 2))) ::: G is assigned to exactly two committees
ForAll([e:employees], Implies(e == H, assigned(e, Policy))) ::: All three officers must be assigned to the Policy Committee
assigned(G, c) != assigned(L, c) ::: G cannot be assigned to the same committee as L
ForAll([e:employees], Implies(e == K, assigned(e, Sales))) ::: K must be assigned to the Sales Committee
# Options
is_valid(assigned(G, Quality)) ::: (A)
is_valid(assigned(G, Sales)) ::: (B)
is_valid(assigned(K, Quality)) ::: (C)
is_valid(assigned(L, Sales)) ::: (D)
is_valid(assigned(M, Quality)) ::: (E)"
"# Context:
On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.

# Question:
If U's appointment is immediately after T's appointment and immediately before R's appointment, then which one of the following must be true?

# Options:
A) Q's appointment is at some time before P's appointment.
B) S's appointment is at some time before P's appointment.
C) S's appointment is immediately before Q's appointment.
D) W's appointment is immediately before P's appointment.
E) W's appointment is at some time before S's appointment.","# Declarations
patients = EnumSort([P, Q, R, S, T, U, W])
appointments = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([patients] -> [appointments])
# Constraints
ForAll([p:patients], Exists([a:appointments], scheduled(p) == a)) ::: each patient has exactly one appointment
scheduled(Q) < scheduled(W) ::: Q's appointment is at some time before W's appointment
scheduled(U) < scheduled(P) ::: U's appointment is at some time before P's appointment
Or(scheduled(R) == 3, scheduled(T) == 3) ::: Either R or T has appointment 3
Or(scheduled(S) == scheduled(R) - 1, scheduled(S) == scheduled(R) + 1) ::: S's appointment is either the appointment immediately before or the appointment immediately after R's appointment
scheduled(T) == scheduled(U) - 1 ::: U's appointment is immediately after T's appointment
scheduled(U) == scheduled(R) - 1 ::: U's appointment is immediately before R's appointment
# Options
is_valid(scheduled(Q) < scheduled(P)) ::: (A)
is_valid(scheduled(S) < scheduled(P)) ::: (B)
is_valid(scheduled(S) == scheduled(Q) - 1) ::: (C)
is_valid(scheduled(W) == scheduled(P) - 1) ::: (D)
is_valid(scheduled(W) < scheduled(S)) ::: (E)"
"# Context:
At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.

# Question:
Which one of the following is an acceptable assignment of sponsors to tables?

# Options:
A) Table 1: K, P; Table 2: M, Q; Table 3: L, V, Z
B) Table 1: K, Q, Z; Table 2: L, V; Table 3: M, P
C) Table 1: L, P; Table 2: K, M; Table 3: Q, V, Z
D) Table 1: L, Q, V; Table 2: K, M; Table 3: P, Z
E) Table 1: L, V, Z; Table 2: K, M, P; Table 3: Q","# Declarations
sponsors = EnumSort([K, L, M, P, Q, V, Z])
tables = EnumSort([1, 2, 3])
seated = Function([sponsors] -> [tables])
# Constraints
ForAll([t:tables], Count([s:sponsors], seated(s) == t) >= 2) ::: Each table has at least two sponsors seated at it
ForAll([s:sponsors], Exists([t:tables], seated(s) == t)) ::: Each sponsor is seated at exactly one table
ForAll([s:sponsors], Implies(Or(s == K, s == L, s == M), Or(seated(s) == 1, seated(s) == 2))) ::: Any sponsor receiving honors is seated at table 1 or table 2
seated(L) == seated(V) ::: L is seated at the same table as V
# Options
is_sat(And(seated(K) == 1, seated(P) == 1, seated(M) == 2, seated(Q) == 2, seated(L) == 3, seated(V) == 3, seated(Z) == 3)) ::: (A)
is_sat(And(seated(K) == 1, seated(Q) == 1, seated(Z) == 1, seated(L) == 2, seated(V) == 2, seated(M) == 3, seated(P) == 3)) ::: (B)
is_sat(And(seated(L) == 1, seated(P) == 1, seated(K) == 2, seated(M) == 2, seated(Q) == 3, seated(V) == 3, seated(Z) == 3)) ::: (C)
is_sat(And(seated(L) == 1, seated(Q) == 1, seated(V) == 1, seated(K) == 2, seated(M) == 2, seated(P) == 3, seated(Z) == 3)) ::: (D)
is_sat(And(seated(L) == 1, seated(V) == 1, seated(Z) == 1, seated(K) == 2, seated(M) == 2, seated(P) == 2, seated(Q) == 3)) ::: (E)"
"# Context:
Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.

# Question:
If product O is presented on the same day as product P, which one of the following must be true?

# Options:
A) F presents product O or else product P.
B) F presents neither product O nor product P.
C) H presents product O or else product P.
D) I presents product O or else product P.
E) J presents neither product O nor product P.","# Declarations
salespeople = EnumSort([F, G, H, I, J])
products = EnumSort([L, M, N, O, P])
days = EnumSort([Monday, Tuesday, Wednesday])
presents = Function([salespeople] -> [products])
scheduled = Function([products] -> [days])
# Constraints
Count([p:products], scheduled(p) == Monday) == 2 ::: Exactly two products will be presented on Monday
Count([p:products], scheduled(p) == Tuesday) == 1 ::: Exactly one product will be presented on Tuesday
Count([p:products], scheduled(p) == Wednesday) == 2 ::: Exactly two products will be presented on Wednesday
ForAll([s:salespeople], ForAll([s1:salespeople], Implies(s != s1, presents(s) != presents(s1)))) ::: Each salesperson presents a different product
ForAll([s:salespeople], ForAll([s1:salespeople], Implies(s != s1, scheduled(presents(s)) != scheduled(presents(s1))))) ::: Each salesperson presents on a different day
scheduled(O) == scheduled(P) ::: Product O is presented on the same day as product P
ForAll([s:salespeople], Implies(s == F, scheduled(presents(s)) != scheduled(presents(H)))) ::: F cannot present a product on the same day as H
Or(scheduled(N) == Tuesday, scheduled(N) == Tuesday) ::: Either I or else J must present product N on Tuesday
ForAll([s:salespeople], Implies(s == G, scheduled(presents(s)) == scheduled(O))) ::: G must present a product on the day that product O is presented
# Options
is_valid(Or(presents(F) == O, presents(F) == P)) ::: (A)
is_valid(And(presents(F) != O, presents(F) != P)) ::: (B)
is_valid(Or(presents(H) == O, presents(H) == P)) ::: (C)
is_valid(Or(presents(I) == O, presents(I) == P)) ::: (D)
is_valid(And(presents(J) != O, presents(J) != P)) ::: (E)"
"# Context:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.

# Question:
If H is assigned to a different boat than Y, which one of the following must be assigned to boat 1?

# Options:
A) F
B) G
C) H
D) V
E) Y","# Declarations
boats = EnumSort([boat1, boat2])
people = EnumSort([F, G, H, V, W, X, Y, Z])
assigned = Function([people] -> [boats])
# Constraints
Count([p:people], assigned(p) == boat1) == 4 ::: Each of two boats, boat 1 and boat 2, will be assigned exactly four people
Count([p:people], assigned(p) == boat2) == 4 ::: Each of two boats, boat 1 and boat 2, will be assigned exactly four people
Exists([a:people], And(a == F, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Exists([a:people], And(a == G, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Exists([a:people], And(a == H, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Implies(assigned(F) == boat2, assigned(G) == boat2) ::: If F is assigned to boat 2, G is assigned to boat 2
Implies(assigned(V) == boat1, assigned(W) == boat2) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(X) != assigned(Z) ::: X and Z are assigned to different boats
assigned(H) != assigned(Y) ::: H is assigned to a different boat than Y
# Options
is_valid(assigned(F) == boat1) ::: (A)
is_valid(assigned(G) == boat1) ::: (B)
is_valid(assigned(H) == boat1) ::: (C)
is_valid(assigned(V) == boat1) ::: (D)
is_valid(assigned(Y) == boat1) ::: (E)"
"# Context:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.

# Question:
If exactly one adult is assigned to boat 1, which one of the following must be true?

# Options:
A) F is assigned to boat 1.
B) G is assigned to boat 2.
C) H is assigned to boat 2.
D) V is assigned to boat 1.
E) Z is assigned to boat 2.","# Declarations
people = EnumSort([F, G, H, V, W, X, Y, Z])
boats = EnumSort([boat1, boat2])
assigned = Function([people] -> [boats])
# Constraints
Count([p:people], assigned(p) == boat1) == 4 ::: boat 1 will be assigned exactly four people
Count([p:people], assigned(p) == boat2) == 4 ::: boat 2 will be assigned exactly four people
Exists([a:people], And(a == F, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Exists([a:people], And(a == G, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Exists([a:people], And(a == H, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Implies(assigned(F) == boat2, assigned(G) == boat2) ::: If F is assigned to boat 2, G is assigned to boat 2
Implies(assigned(V) == boat1, assigned(W) == boat2) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(X) != assigned(Z) ::: X and Z are assigned to different boats
Count([a:people], And(a == F, assigned(a) == boat1)) + Count([a:people], And(a == G, assigned(a) == boat1)) + Count([a:people], And(a == H, assigned(a) == boat1)) == 1 ::: exactly one adult is assigned to boat 1
# Options
is_valid(assigned(F) == boat1) ::: (A)
is_valid(assigned(G) == boat2) ::: (B)
is_valid(assigned(H) == boat2) ::: (C)
is_valid(assigned(V) == boat1) ::: (D)
is_valid(assigned(Z) == boat2) ::: (E)"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
Which one of the following CANNOT be true?

# Options:
A) F is assigned to exactly one committee.
B) G is assigned to exactly three committees.
C) H is assigned to exactly three committees.
D) K is assigned to exactly one committee.
E) L is assigned to exactly two committees.","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees, committees] -> [bool])
# Constraints
ForAll([c:committees], Exists([e:employees], And(assigned(e, c), Or(e == F, e == G, e == H)))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e, c))) ::: Each employee must be assigned to at least one committee
ForAll([e:employees], Implies(e == F, assigned(e, Policy))) ::: All three officers must be assigned to the Policy Committee
ForAll([e:employees], Implies(e == G, assigned(e, Policy))) ::: All three officers must be assigned to the Policy Committee
ForAll([e:employees], Implies(e == H, assigned(e, Policy))) ::: All three officers must be assigned to the Policy Committee
ForAll([c:committees], Implies(And(assigned(G, c), assigned(L, c)), False)) ::: G cannot be assigned to the same committee as L
ForAll([c:committees], Implies(c == Sales, assigned(K, c))) ::: K must be assigned to the Sales Committee
# Options
is_unsat(Count([c:committees], assigned(F, c)) == 1) ::: (A)
is_unsat(Count([c:committees], assigned(G, c)) == 3) ::: (B)
is_unsat(Count([c:committees], assigned(H, c)) == 3) ::: (C)
is_unsat(Count([c:committees], assigned(K, c)) == 1) ::: (D)
is_unsat(Count([c:committees], assigned(L, c)) == 2) ::: (E)"
"# Context:
A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.

# Question:
If no two lights are assigned light bulbs that are the same color as each other, then which one of the following could be true?

# Options:
A) Light 1 is green, and light 2 is purple.
B) Light 1 is green, and light 2 is yellow.
C) Light 1 is purple, and light 3 is yellow.
D) Light 1 is yellow, and light 2 is green.
E) Light 1 is yellow, and light 3 is purple.","# Declarations
lights = EnumSort([light1, light2, light3])
colors = EnumSort([green, purple, yellow])
bulb = Function([lights] -> [colors])
# Constraints
Implies(bulb(light1) == purple, bulb(light2) == yellow) ::: Whenever light 1 is purple, light 2 must be yellow
Implies(bulb(light2) == green, bulb(light1) == green) ::: Whenever light 2 is green, light 1 must be green
Implies(Or(bulb(light3) == purple, bulb(light3) == yellow), bulb(light2) == purple) ::: Whenever light 3 is either purple or yellow, light 2 must be purple
ForAll([l1:lights, l2:lights], Implies(l1 != l2, bulb(l1) != bulb(l2))) ::: no two lights are assigned light bulbs that are the same color as each other
# Options
is_valid(And(bulb(light1) == green, bulb(light2) == purple)) ::: (A)
is_valid(And(bulb(light1) == green, bulb(light2) == yellow)) ::: (B)
is_valid(And(bulb(light1) == purple, bulb(light3) == yellow)) ::: (C)
is_valid(And(bulb(light1) == yellow, bulb(light2) == green)) ::: (D)
is_valid(And(bulb(light1) == yellow, bulb(light3) == purple)) ::: (E)"
"# Context:
During a four-week period, each of seven previously unadvertised products—G, H, J, K, L, M, and O—will be advertised. A different pair of these products will be advertised each week. Exactly one of the products will be a member of two of these four pairs. The following constraints must be observed: J is not advertised during a given week unless H is advertised during the immediately preceding week. The product that is advertised during two of the weeks is advertised during week 4 but is not advertised during week 3. G is not advertised during a given week unless either J or else O is also advertised that week. K is advertised during one of the first two weeks. O is one of the products advertised during week 3.

# Question:
Which one of the following is a pair of products that CANNOT be advertised during the same week as each other?

# Options:
A) H and K
B) H and M
C) J and O
D) K and L
E) L and M","# Declarations
products = EnumSort([G, H, J, K, L, M, O])
weeks = EnumSort([1, 2, 3, 4])
advertised = Function([weeks, products, products] -> [bool])
# Constraints
ForAll([w:weeks], Exists([p1:products, p2:products], And(p1 != p2, advertised(w, p1, p2)))) ::: A different pair of products will be advertised each week
Exists([p:products], Count([w:weeks], Exists([p1:products, p2:products], And(p1 != p2, advertised(w, p, p1)))) == 2) ::: Exactly one product will be a member of two of these four pairs
ForAll([w:weeks], Implies(w != 1, ForAll([p1:products, p2:products], Implies(advertised(w, J, p1), advertised(w-1, H, p2))))) ::: J is not advertised during a given week unless H is advertised during the immediately preceding week
Exists([p:products], And(Exists([p1:products, p2:products], advertised(4, p, p1)), ForAll([p1:products, p2:products], Not(advertised(3, p, p1))))) ::: The product that is advertised during two of the weeks is advertised during week 4 but is not advertised during week 3
ForAll([w:weeks], ForAll([p1:products, p2:products], Implies(advertised(w, G, p1), Or(advertised(w, J, p2), advertised(w, O, p2))))) ::: G is not advertised during a given week unless either J or else O is also advertised that week
Exists([p1:products, p2:products], And(p1 != p2, advertised(1, K, p1), advertised(2, K, p2))) ::: K is advertised during one of the first two weeks
Exists([p1:products, p2:products], advertised(3, O, p1)) ::: O is one of the products advertised during week 3
# Options
is_unsat(Exists([w:weeks], And(advertised(w, H, K), advertised(w, H, M)))) ::: (A)
is_unsat(Exists([w:weeks], And(advertised(w, H, M), advertised(w, H, M)))) ::: (B)
is_unsat(Exists([w:weeks], And(advertised(w, J, O), advertised(w, J, O)))) ::: (C)
is_unsat(Exists([w:weeks], And(advertised(w, K, L), advertised(w, K, L)))) ::: (D)
is_unsat(Exists([w:weeks], And(advertised(w, L, M), advertised(w, L, M)))) ::: (E)"
"# Context:
A train makes five trips around a loop through five stations—P, Q, R, S, and T, in that order—stopping at exactly three of the stations on each trip. The train must conform to the following conditions: The train stops at any given station on exactly three trips, but not on three consecutive trips. The train stops at any given station at least once in any two consecutive trips.

# Question:
If the train is to stop at Q, R, and T on the first trip and at Q, R, and S on the fourth trip, then it could be true that the train

# Options:
A) stops at Q on the second trip
B) stops at R on the fifth trip
C) stops at T on the second trip
D) does not stop at P on the third trip
E) does not stop at T on the fifth trip","# Declarations
stations = EnumSort([P, Q, R, S, T])
trips = EnumSort([1, 2, 3, 4, 5])
stops = Function([trips, stations] -> [bool])
# Constraints
ForAll([s:stations], Count([t:trips], stops(t, s)) == 3) ::: The train stops at any given station on exactly three trips
ForAll([s:stations], ForAll([t:trips], Implies(And(t >= 1, t <= 3), Not(And(stops(t, s), stops(t+1, s), stops(t+2, s)))))) ::: The train stops at any given station on exactly three trips, but not on three consecutive trips
ForAll([t:trips], Implies(t < 5, Exists([s:stations], And(stops(t, s), stops(t+1, s))))) ::: The train stops at any given station at least once in any two consecutive trips
ForAll([s:stations], Implies(stops(1, s), And(s == Q, s == R, s == T))) ::: The train stops at Q, R, and T on the first trip
ForAll([s:stations], Implies(stops(4, s), And(s == Q, s == R, s == S))) ::: The train stops at Q, R, and S on the fourth trip
# Options
is_valid(stops(2, Q)) ::: (A)
is_valid(stops(5, R)) ::: (B)
is_valid(stops(2, T)) ::: (C)
is_valid(Not(stops(3, P))) ::: (D)
is_valid(Not(stops(5, T))) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
If only one silk rug is selected for the exhibition, then the other rugs selected must be a group made up of

# Options:
A) one oval rug and two rectangular rugs
B) two oval rugs and one rectangular rug
C) two oval rugs and two rectangular rugs
D) two oval rugs and three rectangular rugs
E) three rectangular rugs","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rect_wool1, rect_wool2, rect_wool3, oval_silk, rect_silk1, rect_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: The coordinator will select at least four rugs
Count([r:rugs], selected(r)) <= 6 ::: The coordinator will select at most six rugs
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == oval_silk))) >= 2 ::: At least two oval rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3))) >= 2 ::: The number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3))) <= 3 ::: The number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Exists([r:rugs], And(selected(r), Or(r == rect_silk1, r == rect_silk2)))) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected
Count([r:rugs], And(selected(r), Or(r == oval_silk, r == rect_silk1, r == rect_silk2))) == 1 ::: If only one silk rug is selected for the exhibition
# Options
is_valid(And(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) == 1, Count([r:rugs], And(selected(r), Or(r == rect_wool1, r == rect_wool2, r == rect_wool3))) == 2)) ::: (A) one oval rug and two rectangular rugs
is_valid(And(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) == 2, Count([r:rugs], And(selected(r), Or(r == rect_wool1, r == rect_wool2, r == rect_wool3))) == 1)) ::: (B) two oval rugs and one rectangular rug
is_valid(And(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) == 2, Count([r:rugs], And(selected(r), Or(r == rect_wool1, r == rect_wool2, r == rect_wool3))) == 2)) ::: (C) two oval rugs and two rectangular rugs
is_valid(And(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) == 2, Count([r:rugs], And(selected(r), Or(r == rect_wool1, r == rect_wool2, r == rect_wool3))) == 3)) ::: (D) two oval rugs and three rectangular rugs
is_valid(Count([r:rugs], And(selected(r), Or(r == rect_wool1, r == rect_wool2, r == rect_wool3))) == 3) ::: (E) three rectangular rugs"
"# Context:
Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.

# Question:
If products M and P are presented on Monday, which one of the following could be true?

# Options:
A) G presents product P.
B) I presents product O.
C) J presents product L.
D) F presents a product on Monday.
E) G presents a product on Monday.","# Declarations
salespeople = EnumSort([F, G, H, I, J])
products = EnumSort([L, M, N, O, P])
days = EnumSort([Monday, Tuesday, Wednesday])
presents = Function([salespeople] -> [products])
scheduled = Function([products] -> [days])
# Constraints
Count([p:products], scheduled(p) == Monday) == 2 ::: Exactly two products will be presented on Monday
Count([p:products], scheduled(p) == Tuesday) == 1 ::: Exactly one product will be presented on Tuesday
Count([p:products], scheduled(p) == Wednesday) == 2 ::: Exactly two products will be presented on Wednesday
ForAll([s:salespeople], ForAll([s1:salespeople], Implies(s != s1, presents(s) != presents(s1)))) ::: Each salesperson presents a different product
ForAll([s:salespeople], ForAll([s1:salespeople], Implies(s != s1, scheduled(presents(s)) != scheduled(presents(s1))))) ::: Each product is presented on a different day
scheduled(M) == Monday ::: products M and P are presented on Monday
scheduled(P) == Monday ::: products M and P are presented on Monday
Or(presents(I) == N, presents(J) == N) ::: Either I or else J must present product N on Tuesday
scheduled(N) == Tuesday ::: Either I or else J must present product N on Tuesday
ForAll([s:salespeople], Implies(scheduled(presents(s)) == scheduled(O), scheduled(presents(G)) == scheduled(O))) ::: G must present a product on the day that product O is presented
# Options
is_valid(scheduled(presents(F)) == Monday) ::: (A)
is_valid(scheduled(presents(H)) == Tuesday) ::: (B)
is_valid(scheduled(presents(I)) == Wednesday) ::: (C)
is_valid(scheduled(presents(J)) == Wednesday) ::: (D)
is_valid(scheduled(presents(G)) == Tuesday) ::: (E)"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
If H is assigned to exactly one committee, and if no committee has both F and M assigned to it, then it must be true that

# Options:
A) G and M are both assigned to the Quality Committee
B) K and L are both assigned to the Sales Committee
C) K is assigned to exactly two committees
D) L is assigned to exactly two committees
E) M is assigned to exactly two committees","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees, committees] -> [bool])
# Constraints
ForAll([c:committees], Exists([e:employees], And(assigned(e, c), Or(e == F, e == G, e == H)))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e, c))) ::: Each employee must be assigned to at least one committee
ForAll([c:committees], Implies(c == Policy, And(assigned(F, c), assigned(G, c), assigned(H, c)))) ::: All three officers must be assigned to the Policy Committee
ForAll([c:committees], Not(And(assigned(G, c), assigned(L, c)))) ::: G cannot be assigned to the same committee as L
ForAll([c:committees], Implies(c == Sales, assigned(K, c))) ::: K must be assigned to the Sales Committee
Count([c:committees], assigned(H, c)) == 1 ::: H is assigned to exactly one committee
ForAll([c:committees], Not(And(assigned(F, c), assigned(M, c)))) ::: No committee has both F and M assigned to it
# Options
is_valid(And(assigned(G, Quality), assigned(M, Quality))) ::: (A)
is_valid(And(assigned(K, Sales), assigned(L, Sales))) ::: (B)
is_valid(Count([c:committees], assigned(K, c)) == 2) ::: (C)
is_valid(Count([c:committees], assigned(L, c)) == 2) ::: (D)
is_valid(Count([c:committees], assigned(M, c)) == 2) ::: (E)"
"# Context:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.

# Question:
If the condition requiring house 6 to be a split-level house is suspended but all other original conditions remain the same, then any of the following could be an accurate list of the styles of houses 2, 4, 6, and 8, respectively, EXCEPT:

# Options:
A) ranch, split-level, ranch, Tudor
B) split-level, ranch, Tudor, split-level
C) split-level, Tudor, ranch, split-level
D) Tudor, ranch, Tudor, split-level
E) Tudor, split-level, ranch, Tudor","# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])
# Constraints
ForAll([h:houses], Implies(h % 2 == 1, Exists([h1:houses], And(h1 == h + 1, style(h) != style(h1))))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(h % 2 == 0, Exists([h1:houses], And(h1 == h - 1, style(h) != style(h1))))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(h % 2 == 0, Exists([h1:houses], And(h1 == h + 2, style(h) != style(h1))))) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Exists([h1:houses], And(Or(h1 == h - 1, h1 == h + 1, h1 == h - 2, h1 == h + 2), style(h1) == Tudor)))) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
# Options
is_unsat(And(style(2) == ranch, style(4) == split_level, style(6) == ranch, style(8) == Tudor)) ::: (A)
is_unsat(And(style(2) == split_level, style(4) == ranch, style(6) == Tudor, style(8) == split_level)) ::: (B)
is_unsat(And(style(2) == split_level, style(4) == Tudor, style(6) == ranch, style(8) == split_level)) ::: (C)
is_unsat(And(style(2) == Tudor, style(4) == ranch, style(6) == Tudor, style(8) == split_level)) ::: (D)
is_unsat(And(style(2) == Tudor, style(4) == split_level, style(6) == ranch, style(8) == Tudor)) ::: (E)"
"# Context:
A train makes five trips around a loop through five stations—P, Q, R, S, and T, in that order—stopping at exactly three of the stations on each trip. The train must conform to the following conditions: The train stops at any given station on exactly three trips, but not on three consecutive trips. The train stops at any given station at least once in any two consecutive trips.

# Question:
The train CANNOT stop at both P and Q on both the

# Options:
A) first and third trips
B) first and fourth trips
C) second and fourth trips
D) second and fifth trips
E) fourth and fifth trips","# Declarations
stations = EnumSort([P, Q, R, S, T])
trips = EnumSort([1, 2, 3, 4, 5])
stops = Function([trips, stations] -> [bool])
# Constraints
ForAll([s:stations], Count([t:trips], stops(t, s)) == 3) ::: The train stops at any given station on exactly three trips
ForAll([s:stations], ForAll([t:trips], Implies(And(t <= 3, stops(t, s)), Not(And(stops(t+1, s), stops(t+2, s)))))) ::: The train stops at any given station on exactly three trips, but not on three consecutive trips
ForAll([s:stations], ForAll([t:trips], Implies(t < 5, Or(stops(t, s), stops(t+1, s))))) ::: The train stops at any given station at least once in any two consecutive trips
# Options
is_unsat(And(stops(1, P), stops(1, Q), stops(3, P), stops(3, Q))) ::: (A)
is_unsat(And(stops(1, P), stops(1, Q), stops(4, P), stops(4, Q))) ::: (B)
is_unsat(And(stops(2, P), stops(2, Q), stops(4, P), stops(4, Q))) ::: (C)
is_unsat(And(stops(2, P), stops(2, Q), stops(5, P), stops(5, Q))) ::: (D)
is_unsat(And(stops(4, P), stops(4, Q), stops(5, P), stops(5, Q))) ::: (E)"
"# Context:
Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.

# Question:
Which one of the following is a complete and accurate list of classes any one of which could be the class to which V is added?

# Options:
A) class 1
B) class 3
C) class 1, class 3
D) class 2, class 3
E) class 1, class 2, class 3","# Declarations
students = EnumSort([R, S, T, V, W, X, Y, Z])
classes = EnumSort([class1, class2, class3])
assigned = Function([students] -> [classes])
# Constraints
Count([s:students], assigned(s) == class1) == 3 ::: class 1 will gain three new students
Count([s:students], assigned(s) == class2) == 3 ::: class 2 will gain three new students
Count([s:students], assigned(s) == class3) == 2 ::: class 3 will gain two new students
assigned(R) == class1 ::: R must be added to class 1
assigned(S) == class3 ::: S must be added to class 3
assigned(S) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(W) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(V) != assigned(Z) ::: V cannot be added to the same class as Z
Implies(assigned(T) == class1, assigned(Z) == class1) ::: If T is added to class 1, Z must also be added to class 1
# Options
is_accurate_list([assigned(V) == class1]) ::: (A)
is_accurate_list([assigned(V) == class3]) ::: (B)
is_accurate_list([assigned(V) == class1, assigned(V) == class3]) ::: (C)
is_accurate_list([assigned(V) == class2, assigned(V) == class3]) ::: (D)
is_accurate_list([assigned(V) == class1, assigned(V) == class2, assigned(V) == class3]) ::: (E)"
"# Context:
Within a tennis league each of five teams occupies one of five positions, numbered 1 through 5 in order of rank, with number 1 as the highest position. The teams are initially in the order R, J, S, M, L, with R in position 1. Teams change positions only when a lower-positioned team defeats a higher-positioned team. The rules are as follows: Matches are played alternately in odd-position rounds and in even-position rounds. In an odd-position round, teams in positions 3 and 5 play against teams positioned immediately above them. In an even-position round, teams in positions 2 and 4 play against teams positioned immediately above them. When a lower-positioned team defeats a higher-positioned team, the two teams switch positions after the round is completed.

# Question:
Which one of the following could be the order of teams, from position 1 through position 5 respectively, after exactly one round of even-position matches if no odd-position round has yet been played?

# Options:
A) J, R, M, L, S
B) J, R, S, L, M
C) R, J, M, L, S
D) R, J, M, S, L
E) R, S, J, L, M","# Declarations
teams = EnumSort([R, J, S, M, L])
positions = EnumSort([1, 2, 3, 4, 5])
initial_position = Function([teams] -> [positions])
final_position = Function([teams] -> [positions])
# Constraints
initial_position(R) == 1 ::: R is initially in position 1
initial_position(J) == 2 ::: J is initially in position 2
initial_position(S) == 3 ::: S is initially in position 3
initial_position(M) == 4 ::: M is initially in position 4
initial_position(L) == 5 ::: L is initially in position 5
ForAll([t:teams], final_position(t) != initial_position(t)) ::: Teams change positions only when a lower-positioned team defeats a higher-positioned team
ForAll([t1:teams, t2:teams], Implies(And(initial_position(t1) == 2, initial_position(t2) == 3), Or(final_position(t1) == 3, final_position(t2) == 2))) ::: In an even-position round, teams in positions 2 and 4 play against teams positioned immediately above them
ForAll([t1:teams, t2:teams], Implies(And(initial_position(t1) == 4, initial_position(t2) == 5), Or(final_position(t1) == 5, final_position(t2) == 4))) ::: In an even-position round, teams in positions 2 and 4 play against teams positioned immediately above them
# Options
is_sat(And(final_position(J) == 1, final_position(R) == 2, final_position(M) == 3, final_position(L) == 4, final_position(S) == 5)) ::: (A)
is_sat(And(final_position(J) == 1, final_position(R) == 2, final_position(S) == 3, final_position(L) == 4, final_position(M) == 5)) ::: (B)
is_sat(And(final_position(R) == 1, final_position(J) == 2, final_position(M) == 3, final_position(L) == 4, final_position(S) == 5)) ::: (C)
is_sat(And(final_position(R) == 1, final_position(J) == 2, final_position(M) == 3, final_position(S) == 4, final_position(L) == 5)) ::: (D)
is_sat(And(final_position(R) == 1, final_position(S) == 2, final_position(J) == 3, final_position(L) == 4, final_position(M) == 5)) ::: (E)"
"# Context:
On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.

# Question:
If T's appointment is immediately after P's appointment and immediately before W's appointment, then which one of the following must be true?

# Options:
A) W's appointment is at some time before R's appointment.
B) U's appointment is at some time before R's appointment.
C) S's appointment is at some time before U's appointment.
D) R's appointment is at some time before P's appointment.
E) Q's appointment is at some time before S's appointment.","# Declarations
patients = EnumSort([P, Q, R, S, T, U, W])
appointments = EnumSort([1, 2, 3, 4, 5, 6, 7])
scheduled = Function([patients] -> [appointments])
# Constraints
ForAll([p:patients], Exists([a:appointments], scheduled(p) == a)) ::: each patient has exactly one appointment
scheduled(Q) < scheduled(W) ::: Q's appointment is at some time before W's appointment
scheduled(U) < scheduled(P) ::: U's appointment is at some time before P's appointment
Or(scheduled(R) == 3, scheduled(T) == 3) ::: Either R or T has appointment 3
Or(scheduled(S) == scheduled(R) - 1, scheduled(S) == scheduled(R) + 1) ::: S's appointment is either the appointment immediately before or the appointment immediately after R's appointment
scheduled(T) == scheduled(P) + 1 ::: T's appointment is immediately after P's appointment
scheduled(T) == scheduled(W) - 1 ::: T's appointment is immediately before W's appointment
# Options
is_valid(scheduled(W) < scheduled(R)) ::: (A)
is_valid(scheduled(U) < scheduled(R)) ::: (B)
is_valid(scheduled(S) < scheduled(U)) ::: (C)
is_valid(scheduled(R) < scheduled(P)) ::: (D)
is_valid(scheduled(Q) < scheduled(S)) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
The rugs selected for the exhibition can include any of the following EXCEPT:

# Options:
A) one oval silk rug
B) two oval wool rugs
C) three oval rugs
D) two rectangular wool rugs
E) three rectangular wool rugs","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rectangular_wool1, rectangular_wool2, rectangular_wool3, oval_silk, rectangular_silk1, rectangular_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: The coordinator will select at least four rugs
Count([r:rugs], selected(r)) <= 6 ::: The coordinator will select at most six rugs
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == oval_silk))) >= 2 ::: At least two oval rugs must be selected
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) >= 2 ::: The number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) <= 3 ::: The number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Count([r:rugs], And(selected(r), Or(r == rectangular_silk1, r == rectangular_silk2))) >= 1) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected
# Options
is_unsat(Count([r:rugs], And(selected(r), r == oval_silk)) == 1) ::: (A) one oval silk rug
is_unsat(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2))) == 2) ::: (B) two oval wool rugs
is_unsat(Count([r:rugs], And(selected(r), Or(r == oval_wool1, r == oval_wool2, r == oval_silk))) == 3) ::: (C) three oval rugs
is_unsat(Count([r:rugs], And(selected(r), Or(r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) == 2) ::: (D) two rectangular wool rugs
is_unsat(Count([r:rugs], And(selected(r), Or(r == rectangular_wool1, r == rectangular_wool2, r == rectangular_wool3))) == 3) ::: (E) three rectangular wool rugs"
"# Context:
A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.

# Question:
Which one of the following areas must be reduced?

# Options:
A) G
B) L
C) N
D) P
E) W","# Declarations
areas = EnumSort([G, L, M, R, N, P, S, W])
reduced = Function([areas] -> [bool])
# Constraints
Count([a:areas], reduced(a)) == 5 ::: The committee must reduce exactly five of eight areas
Implies(And(reduced(G), reduced(S)), reduced(W)) ::: If both G and S are reduced, W is also reduced
Implies(reduced(N), And(Not(reduced(R)), Not(reduced(S)))) ::: If N is reduced, neither R nor S is reduced
Implies(reduced(P), Not(reduced(L))) ::: If P is reduced, L is not reduced
Count([a:areas], And(Or(a == L, a == M, a == R), reduced(a))) == 2 ::: Of the three areas L, M, and R, exactly two are reduced
# Options
is_valid(reduced(G)) ::: (A)
is_valid(reduced(L)) ::: (B)
is_valid(reduced(N)) ::: (C)
is_valid(reduced(P)) ::: (D)
is_valid(reduced(W)) ::: (E)"
"# Context:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.

# Question:
If V and W are assigned to the same boat as each other, which one of the following is a pair of people who must also be assigned to the same boat as each other?

# Options:
A) F and H
B) F and Y
C) G and X
D) W and X
E) Y and Z","# Declarations
people = EnumSort([F, G, H, V, W, X, Y, Z])
boats = EnumSort([boat1, boat2])
assigned = Function([people] -> [boats])
# Constraints
Count([p:people], assigned(p) == boat1) == 4 ::: boat 1 will be assigned exactly four people
Count([p:people], assigned(p) == boat2) == 4 ::: boat 2 will be assigned exactly four people
ForAll([b:boats], Exists([p:people], And(p == F, assigned(p) == b))) ::: Each boat is assigned at least one adult
ForAll([b:boats], Exists([p:people], And(p == G, assigned(p) == b))) ::: Each boat is assigned at least one adult
ForAll([b:boats], Exists([p:people], And(p == H, assigned(p) == b))) ::: Each boat is assigned at least one adult
Implies(assigned(F) == boat2, assigned(G) == boat2) ::: If F is assigned to boat 2, G is assigned to boat 2
Implies(assigned(V) == boat1, assigned(W) == boat2) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(X) != assigned(Z) ::: X and Z are assigned to different boats
assigned(V) == assigned(W) ::: V and W are assigned to the same boat as each other
# Options
is_valid(And(assigned(F) == assigned(H))) ::: (A)
is_valid(And(assigned(F) == assigned(Y))) ::: (B)
is_valid(And(assigned(G) == assigned(X))) ::: (C)
is_valid(And(assigned(W) == assigned(X))) ::: (D)
is_valid(And(assigned(Y) == assigned(Z))) ::: (E)"
"# Context:
The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.

# Question:
If three wool rugs are selected, then any of the following could be a complete and accurate list of the other rugs selected EXCEPT:

# Options:
A) one oval silk rug
B) one rectangular silk rug
C) two rectangular silk rugs
D) one oval silk rug and one rectangular silk rug
E) one oval silk rug and two rectangular silk rugs","# Declarations
rugs = EnumSort([oval_wool1, oval_wool2, rect_wool1, rect_wool2, rect_wool3, oval_silk, rect_silk1, rect_silk2])
selected = Function([rugs] -> [bool])
# Constraints
Count([r:rugs], selected(r)) >= 4 ::: At least four rugs must be selected
Count([r:rugs], selected(r)) <= 6 ::: At most six rugs must be selected
Count([r:rugs], And(Or(r == oval_wool1, r == oval_wool2), selected(r))) >= 2 ::: At least two oval rugs must be selected
Count([r:rugs], And(Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3), selected(r))) >= 2 ::: The number of wool rugs selected can be neither less than two nor more than three
Count([r:rugs], And(Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3), selected(r))) <= 3 ::: The number of wool rugs selected can be neither less than two nor more than three
Implies(selected(oval_silk), Exists([r:rugs], And(Or(r == rect_silk1, r == rect_silk2), selected(r)))) ::: If the oval silk rug is selected, at least one rectangular silk rug must be selected
Count([r:rugs], And(Or(r == oval_wool1, r == oval_wool2, r == rect_wool1, r == rect_wool2, r == rect_wool3), selected(r))) == 3 ::: If three wool rugs are selected
# Options
is_unsat(And(selected(oval_silk), ForAll([r:rugs], Implies(Or(r == rect_silk1, r == rect_silk2), Not(selected(r)))))) ::: (A) one oval silk rug
is_unsat(And(ForAll([r:rugs], Implies(Or(r == oval_silk, r == rect_silk1, r == rect_silk2), Not(selected(r)))), Exists([r:rugs], And(Or(r == rect_silk1, r == rect_silk2), selected(r))))) ::: (B) one rectangular silk rug
is_unsat(And(ForAll([r:rugs], Implies(Or(r == oval_silk, r == rect_silk1, r == rect_silk2), Not(selected(r)))), Count([r:rugs], And(Or(r == rect_silk1, r == rect_silk2), selected(r))) == 2)) ::: (C) two rectangular silk rugs
is_unsat(And(selected(oval_silk), Exists([r:rugs], And(Or(r == rect_silk1, r == rect_silk2), selected(r))))) ::: (D) one oval silk rug and one rectangular silk rug
is_unsat(And(selected(oval_silk), Count([r:rugs], And(Or(r == rect_silk1, r == rect_silk2), selected(r))) == 2)) ::: (E) one oval silk rug and two rectangular silk rugs"
"# Context:
A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.

# Question:
There is exactly one possible color sequence of the three lights if which one of the following is true?

# Options:
A) Light 1 is purple.
B) Light 2 is purple.
C) Light 2 is yellow.
D) Light 3 is purple.
E) Light 3 is yellow.","# Declarations
colors = EnumSort([green, purple, yellow])
lights = EnumSort([light1, light2, light3])
bulb_color = Function([lights] -> [colors])
# Constraints
Implies(bulb_color(light1) == purple, bulb_color(light2) == yellow) ::: Whenever light 1 is purple, light 2 must be yellow
Implies(bulb_color(light2) == green, bulb_color(light1) == green) ::: Whenever light 2 is green, light 1 must be green
Implies(Or(bulb_color(light3) == purple, bulb_color(light3) == yellow), bulb_color(light2) == purple) ::: Whenever light 3 is either purple or yellow, light 2 must be purple
# Options
is_valid(bulb_color(light1) == purple) ::: (A)
is_valid(bulb_color(light2) == purple) ::: (B)
is_valid(bulb_color(light2) == yellow) ::: (C)
is_valid(bulb_color(light3) == purple) ::: (D)
is_valid(bulb_color(light3) == yellow) ::: (E)"
"# Context:
Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.

# Question:
Which one of the following is a group of three employees who can be assigned together to the Sales Committee?

# Options:
A) F, G, and H
B) F, G, and M
C) G, K, and L
D) H, K, and L
E) K, L, and M","# Declarations
employees = EnumSort([F, G, H, K, L, M])
committees = EnumSort([Policy, Quality, Sales])
assigned = Function([employees] -> [committees])
# Constraints
ForAll([c:committees], Exists([e:employees], And(assigned(e) == c, Or(e == F, e == G, e == H)))) ::: Each committee must have at least one officer assigned to it
ForAll([e:employees], Exists([c:committees], assigned(e) == c)) ::: Each employee must be assigned to at least one committee
ForAll([e:employees], Implies(Or(e == F, e == G, e == H), assigned(e) == Policy)) ::: All three officers must be assigned to the Policy Committee
assigned(G) != assigned(L) ::: G cannot be assigned to the same committee as L
assigned(K) == Sales ::: K must be assigned to the Sales Committee
# Options
is_sat(And(assigned(F) == Sales, assigned(G) == Sales, assigned(H) == Sales)) ::: (A)
is_sat(And(assigned(F) == Sales, assigned(G) == Sales, assigned(M) == Sales)) ::: (B)
is_sat(And(assigned(G) == Sales, assigned(K) == Sales, assigned(L) == Sales)) ::: (C)
is_sat(And(assigned(H) == Sales, assigned(K) == Sales, assigned(L) == Sales)) ::: (D)
is_sat(And(assigned(K) == Sales, assigned(L) == Sales, assigned(M) == Sales)) ::: (E)"
"# Context:
At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.

# Question:
If X is performed first, which one of the following must be true?

# Options:
A) X is performed by George.
B) X is performed by Helen.
C) P is the fourth song performed.
D) Y is the second song performed.
E) Y is the third song performed.","# Declarations
songs = EnumSort([O, P, T, X, Y, Z])
vocalists = EnumSort([George, Helen, Leslie])
performed_by = Function([songs] -> [vocalists])
performed_order = Function([songs] -> [int])
# Constraints
ForAll([s:songs], Exists([s1:songs], And(s1 != s, performed_order(s1) < performed_order(s)))) ::: The songs will be sung consecutively as solos, and each will be performed exactly once
performed_order(Y) < performed_order(T) ::: Y must be performed earlier than T
performed_order(Y) < performed_order(O) ::: Y must be performed earlier than O
performed_order(P) < performed_order(Z) ::: P must be performed earlier than Z
performed_order(P) > performed_order(O) ::: P must be performed later than O
ForAll([s:songs], Implies(s == X, performed_by(s) != George)) ::: George can perform only X, Y, and Z
ForAll([s:songs], Implies(s == T, performed_by(s) != Helen)) ::: Helen can perform only T, P, and X
ForAll([s:songs], Implies(s == O, performed_by(s) != Leslie)) ::: Leslie can perform only O, P, and X
performed_by(X) != performed_by(Z) ::: The vocalist who performs first must be different from the vocalist who performs last
performed_order(X) == 1 ::: X is performed first
# Options
is_valid(performed_by(X) == George) ::: (A)
is_valid(performed_by(X) == Helen) ::: (B)
is_valid(performed_order(P) == 4) ::: (C)
is_valid(performed_order(Y) == 2) ::: (D)
is_valid(performed_order(Y) == 3) ::: (E)"
"# Context:
Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.

# Question:
If G is assigned to boat 1, which one of the following must be true?

# Options:
A) H is assigned to boat 2.
B) V is assigned to boat 2.
C) Exactly one adult is assigned to boat 1.
D) Exactly two adults are assigned to boat 2.
E) Exactly two children are assigned to boat 2.","# Declarations
boats = EnumSort([boat1, boat2])
people = EnumSort([F, G, H, V, W, X, Y, Z])
assigned = Function([people] -> [boats])
# Constraints
Count([p:people], assigned(p) == boat1) == 4 ::: Each boat is assigned exactly four people
Count([p:people], assigned(p) == boat2) == 4 ::: Each boat is assigned exactly four people
Exists([a:people], And(a == F, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Exists([a:people], And(a == G, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Exists([a:people], And(a == H, Or(assigned(a) == boat1, assigned(a) == boat2))) ::: Each boat is assigned at least one adult
Implies(assigned(F) == boat2, assigned(G) == boat2) ::: If F is assigned to boat 2, G is assigned to boat 2
Implies(assigned(V) == boat1, assigned(W) == boat2) ::: If V is assigned to boat 1, W is assigned to boat 2
assigned(X) != assigned(Z) ::: X and Z are assigned to different boats
assigned(G) == boat1 ::: If G is assigned to boat 1
# Options
is_valid(assigned(H) == boat2) ::: (A)
is_valid(assigned(V) == boat2) ::: (B)
is_valid(Count([a:people], And(a == F, assigned(a) == boat1)) == 1) ::: (C)
is_valid(Count([a:people], And(a == F, assigned(a) == boat2)) == 2) ::: (D)
is_valid(Count([c:people], And(c == V, assigned(c) == boat2)) == 2) ::: (E)"
"# Context:
On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.

# Question:
If P's appointment is immediately before S's appointment, then each of the following could be true EXCEPT:

# Options:
A) R's appointment is immediately before W's appointment.
B) T's appointment is immediately before Q's appointment.
C) U's appointment is immediately before P's appointment.
D) U's appointment is immediately before Q's appointment.
E) W's appointment is immediately before T's appointment.","# Declarations
patients = EnumSort([P, Q, R, S, T, U, W])
appointments = EnumSort([1, 2, 3, 4, 5, 6, 7])
schedule = Function([patients] -> [appointments])
# Constraints
ForAll([p:patients], Exists([a:appointments], schedule(p) == a)) ::: each patient has exactly one appointment
ForAll([a:appointments], Exists([p:patients], schedule(p) == a)) ::: each appointment is assigned to exactly one patient
schedule(Q) < schedule(W) ::: Q's appointment is at some time before W's appointment
schedule(U) < schedule(P) ::: U's appointment is at some time before P's appointment
Or(schedule(R) == 3, schedule(T) == 3) ::: Either R or T has appointment 3
Or(schedule(S) == schedule(R) + 1, schedule(S) == schedule(R) - 1) ::: S's appointment is either the appointment immediately before or the appointment immediately after R's appointment
schedule(P) == schedule(S) - 1 ::: P's appointment is immediately before S's appointment
# Options
is_unsat(schedule(R) == schedule(W) - 1) ::: (A)
is_unsat(schedule(T) == schedule(Q) - 1) ::: (B)
is_unsat(schedule(U) == schedule(P) - 1) ::: (C)
is_unsat(schedule(U) == schedule(Q) - 1) ::: (D)
is_unsat(schedule(W) == schedule(T) - 1) ::: (E)"
"# Context:
A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.

# Question:
If light 1 is yellow, then any of the following can be true, EXCEPT:

# Options:
A) Light 2 is green.
B) Light 2 is purple.
C) Light 3 is green.
D) Light 3 is purple.
E) Light 3 is yellow.","# Declarations
lights = EnumSort([light1, light2, light3])
colors = EnumSort([green, purple, yellow])
bulb = Function([lights] -> [colors])
# Constraints
Implies(bulb(light1) == purple, bulb(light2) == yellow) ::: Whenever light 1 is purple, light 2 must be yellow
Implies(bulb(light2) == green, bulb(light1) == green) ::: Whenever light 2 is green, light 1 must be green
Implies(Or(bulb(light3) == purple, bulb(light3) == yellow), bulb(light2) == purple) ::: Whenever light 3 is either purple or yellow, light 2 must be purple
bulb(light1) == yellow ::: If light 1 is yellow
# Options
is_unsat(bulb(light2) == green) ::: (A)
is_unsat(bulb(light2) == purple) ::: (B)
is_unsat(bulb(light3) == green) ::: (C)
is_unsat(bulb(light3) == purple) ::: (D)
is_unsat(bulb(light3) == yellow) ::: (E)"
"# Context:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.

# Question:
If no house faces a house of the same style, then it must be true that house

# Options:
A) 1 is a split-level house
B) 1 is a Tudor house
C) 2 is a ranch house
D) 2 is a split-level house
E) 4 is a Tudor house","# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])
# Constraints
ForAll([h:houses], Implies(h != 1, style(h) != style(h-1))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(h % 2 == 0, style(h) != style(h-1))) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Or(style(h-1) == Tudor, style(h+1) == Tudor))) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house
ForAll([h:houses], Implies(h % 2 == 0, style(h) != style(h-1))) ::: If no house faces a house of the same style
# Options
is_valid(style(1) == split_level) ::: (A)
is_valid(style(1) == Tudor) ::: (B)
is_valid(style(2) == ranch) ::: (C)
is_valid(style(2) == split_level) ::: (D)
is_valid(style(4) == Tudor) ::: (E)"
"# Context:
A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.

# Question:
Which one of the following could be an accurate list of the colors of light bulbs selected for lights 1, 2, and 3, respectively?

# Options:
A) green, green, yellow
B) purple, green, green
C) purple, purple, green
D) yellow, purple, green
E) yellow, yellow, yellow","# Declarations
colors = EnumSort([green, purple, yellow])
lights = EnumSort([light1, light2, light3])
bulb_color = Function([lights] -> [colors])
# Constraints
Implies(bulb_color(light1) == purple, bulb_color(light2) == yellow) ::: Whenever light 1 is purple, light 2 must be yellow
Implies(bulb_color(light2) == green, bulb_color(light1) == green) ::: Whenever light 2 is green, light 1 must be green
Implies(Or(bulb_color(light3) == purple, bulb_color(light3) == yellow), bulb_color(light2) == purple) ::: Whenever light 3 is either purple or yellow, light 2 must be purple
# Options
is_accurate_list([bulb_color(light1) == green, bulb_color(light2) == green, bulb_color(light3) == yellow]) ::: (A)
is_accurate_list([bulb_color(light1) == purple, bulb_color(light2) == green, bulb_color(light3) == green]) ::: (B)
is_accurate_list([bulb_color(light1) == purple, bulb_color(light2) == purple, bulb_color(light3) == green]) ::: (C)
is_accurate_list([bulb_color(light1) == yellow, bulb_color(light2) == purple, bulb_color(light3) == green]) ::: (D)
is_accurate_list([bulb_color(light1) == yellow, bulb_color(light2) == yellow, bulb_color(light3) == yellow]) ::: (E)"
"# Context:
Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.

# Question:
There are how many different persons any one of whom could be paired with M to form a team?

# Options:
A) one
B) two
C) three
D) four
E) five","# Declarations
persons = EnumSort([G, H, I, K, L, M, P])
teams = EnumSort([team1, team2, team3])
organizer = Function([persons] -> [bool])
team_member = Function([persons] -> [teams])
# Constraints
ForAll([p:persons], Implies(organizer(p), team_member(p) == None)) ::: One person will be the organizer and not a member of any team
Count([p:persons], organizer(p)) == 1 ::: One person will be the organizer
Count([p:persons], team_member(p) != None) == 6 ::: The remaining six will form three climbing teams
ForAll([p:persons], Count([t:teams], team_member(p) == t) <= 1) ::: No person can be on more than one team
team_member(M) != team_member(P) ::: M and P cannot be on the same team as each other
Implies(team_member(K) != None, team_member(K) == team_member(M)) ::: If K is on a team, M must also be on that team
Implies(team_member(G) != None, Or(team_member(G) == team_member(H), team_member(G) == team_member(I))) ::: If G is on a team, either H or I must also be on that team
Implies(team_member(H) != None, organizer(K)) ::: If H is on a team, K must be the organizer
# Options
is_accurate_list([Count([p:persons], team_member(M) == team_member(p)) == 1]) ::: (A)
is_accurate_list([Count([p:persons], team_member(M) == team_member(p)) == 2]) ::: (B)
is_accurate_list([Count([p:persons], team_member(M) == team_member(p)) == 3]) ::: (C)
is_accurate_list([Count([p:persons], team_member(M) == team_member(p)) == 4]) ::: (D)
is_accurate_list([Count([p:persons], team_member(M) == team_member(p)) == 5]) ::: (E)"
"# Context:
During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.

# Question:
Which one of the following statements could be true?

# Options:
A) Nikki's fall sport is mountaineering and Otto's spring sport is running.
B) Nikki's spring sport is running and her summer sport is mountaineering.
C) Nikki's spring sport is mountaineering and Otto's fall sport is mountaineering.
D) Nikki's spring sport is running and Otto's fall sport is mountaineering.
E) Nikki's summer sport is mountaineering and Otto's spring sport is mountaineering.","# Declarations
seasons = EnumSort([fall, winter, spring, summer])
sports = EnumSort([hockey, kayaking, mountaineering, running, volleyball])
children = EnumSort([Nikki, Otto])
participates = Function([children, seasons] -> [sports])
# Constraints
ForAll([c:children], Count([s:seasons], participates(c, s) == mountaineering) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == running) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == kayaking) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == hockey) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == volleyball) == 1) ::: Each child participates in exactly four different sports during the year
Or(participates(Nikki, fall) == mountaineering, participates(Nikki, fall) == running, participates(Nikki, fall) == volleyball) ::: In the fall, each child participates in mountaineering, running, or volleyball
Or(participates(Otto, fall) == mountaineering, participates(Otto, fall) == running, participates(Otto, fall) == volleyball) ::: In the fall, each child participates in mountaineering, running, or volleyball
Or(participates(Nikki, winter) == hockey, participates(Nikki, winter) == volleyball) ::: In the winter, each child participates in hockey or volleyball
Or(participates(Otto, winter) == hockey, participates(Otto, winter) == volleyball) ::: In the winter, each child participates in hockey or volleyball
Or(participates(Nikki, spring) == kayaking, participates(Nikki, spring) == mountaineering, participates(Nikki, spring) == running, participates(Nikki, spring) == volleyball) ::: In the spring, each child participates in kayaking, mountaineering, running, or volleyball
Or(participates(Otto, spring) == kayaking, participates(Otto, spring) == mountaineering, participates(Otto, spring) == running, participates(Otto, spring) == volleyball) ::: In the spring, each child participates in kayaking, mountaineering, running, or volleyball
Or(participates(Nikki, summer) == kayaking, participates(Nikki, summer) == mountaineering, participates(Nikki, summer) == volleyball) ::: In the summer, each child participates in kayaking, mountaineering, or volleyball
Or(participates(Otto, summer) == kayaking, participates(Otto, summer) == mountaineering, participates(Otto, summer) == volleyball) ::: In the summer, each child participates in kayaking, mountaineering, or volleyball
participates(Otto, summer) == volleyball ::: Otto's summer sport is volleyball
ForAll([s:seasons], participates(Nikki, s) != participates(Otto, s)) ::: Nikki and Otto do not participate in the same sport during the same season
# Options
is_sat(And(participates(Nikki, fall) == mountaineering, participates(Otto, spring) == running)) ::: (A)
is_sat(And(participates(Nikki, spring) == running, participates(Nikki, summer) == mountaineering)) ::: (B)
is_sat(And(participates(Nikki, spring) == mountaineering, participates(Otto, fall) == mountaineering)) ::: (C)
is_sat(And(participates(Nikki, spring) == running, participates(Otto, fall) == mountaineering)) ::: (D)
is_sat(And(participates(Nikki, summer) == mountaineering, participates(Otto, spring) == mountaineering)) ::: (E)"
"# Context:
Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.

# Question:
Which one of the following must be true?

# Options:
A) A tiger is assigned to stall 2.
B) A tiger is assigned to stall 4.
C) A tiger is assigned to stall 5.
D) A lion is assigned to stall 3.
E) A lion is assigned to stall 4.","# Declarations
animals = EnumSort([F, G, H, J, K, M])
stalls = EnumSort([1, 2, 3, 4, 5, 6])
assigned = Function([animals] -> [stalls])
# Constraints
ForAll([a:animals], Exists([s:stalls], assigned(a) == s)) ::: Each animal will be assigned to exactly one stall
ForAll([s:stalls], Exists([a:animals], assigned(a) == s)) ::: Each stall will have exactly one animal assigned to it
assigned(F) == 1 ::: A lion must be assigned to stall 1
assigned(H) == 6 ::: H must be assigned to stall 6
assigned(J) == assigned(K) + 1 ::: J must be assigned to a stall numbered one higher than K's stall
Not(assigned(K) == 3) ::: K cannot be assigned to the stall that faces H's stall
ForAll([a1:animals, a2:animals], Implies(And(a1 != a2, Or(a1 == K, a1 == M), Or(a2 == K, a2 == M)), Not(And(assigned(a1) == 1, assigned(a2) == 4)))) ::: The tigers' stalls cannot face each other
ForAll([a1:animals, a2:animals], Implies(And(a1 != a2, Or(a1 == K, a1 == M), Or(a2 == K, a2 == M)), Not(And(assigned(a1) == 2, assigned(a2) == 5)))) ::: The tigers' stalls cannot face each other
ForAll([a1:animals, a2:animals], Implies(And(a1 != a2, Or(a1 == K, a1 == M), Or(a2 == K, a2 == M)), Not(And(assigned(a1) == 3, assigned(a2) == 6)))) ::: The tigers' stalls cannot face each other
# Options
is_valid(Exists([a:animals], And(Or(a == K, a == M), assigned(a) == 2))) ::: (A)
is_valid(Exists([a:animals], And(Or(a == K, a == M), assigned(a) == 4))) ::: (B)
is_valid(Exists([a:animals], And(Or(a == K, a == M), assigned(a) == 5))) ::: (C)
is_valid(Exists([a:animals], And(Or(a == F, a == G, a == H, a == J), assigned(a) == 3))) ::: (D)
is_valid(Exists([a:animals], And(Or(a == F, a == G, a == H, a == J), assigned(a) == 4))) ::: (E)"
"# Context:
Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.

# Question:
If X is added to class 3, each of the following is a pair of students who can be added to class 1 EXCEPT

# Options:
A) Y and Z
B) W and Z
C) V and Y
D) V and W
E) T and Z","# Declarations
students = EnumSort([R, S, T, V, W, X, Y, Z])
classes = EnumSort([class1, class2, class3])
assigned = Function([students] -> [classes])
# Constraints
Count([s:students], assigned(s) == class1) == 3 ::: class 1 will gain three new students
Count([s:students], assigned(s) == class2) == 3 ::: class 2 will gain three new students
Count([s:students], assigned(s) == class3) == 2 ::: class 3 will gain two new students
assigned(R) == class1 ::: R must be added to class 1
assigned(S) == class3 ::: S must be added to class 3
assigned(X) == class3 ::: X is added to class 3
assigned(S) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(W) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(V) != assigned(Z) ::: V cannot be added to the same class as Z
Implies(assigned(T) == class1, assigned(Z) == class1) ::: If T is added to class 1, Z must also be added to class 1
# Options
is_unsat(And(assigned(Y) == class1, assigned(Z) == class1)) ::: (A) Y and Z
is_unsat(And(assigned(W) == class1, assigned(Z) == class1)) ::: (B) W and Z
is_unsat(And(assigned(V) == class1, assigned(Y) == class1)) ::: (C) V and Y
is_unsat(And(assigned(V) == class1, assigned(W) == class1)) ::: (D) V and W
is_unsat(And(assigned(T) == class1, assigned(Z) == class1)) ::: (E) T and Z"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
If at noon plane L is within exactly three of the areas, which one of the following could be true at that time?

# Options:
A) J is within exactly two of the areas.
B) J is within exactly three of the areas.
C) K is within area S.
D) M is within area R.
E) M is within area T.","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
in_area = Function([planes, areas] -> [bool])
# Constraints
ForAll([p:planes], Exists([a:areas], in_area(p, a))) ::: Each plane is in at least one of the four areas
ForAll([a:areas], in_area(J, S)) ::: J is in area S
ForAll([a:areas], Implies(in_area(J, a), Not(in_area(K, a)))) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(in_area(L, a), Not(in_area(M, a)))) ::: L is not in any detection area that M is in
Count([a:areas], in_area(M, a)) == 1 ::: M is in exactly one of the areas
Count([a:areas], in_area(L, a)) == 3 ::: Plane L is within exactly three of the areas
# Options
is_valid(Count([a:areas], in_area(J, a)) == 2) ::: (A)
is_valid(Count([a:areas], in_area(J, a)) == 3) ::: (B)
is_valid(in_area(K, S)) ::: (C)
is_valid(in_area(M, R)) ::: (D)
is_valid(in_area(M, T)) ::: (E)"
"# Context:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.

# Question:
On the street, there could be exactly

# Options:
A) one ranch house
B) one Tudor house
C) two Tudor houses
D) four ranch houses
E) five ranch houses","# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])
# Constraints
ForAll([h:houses], Implies(h != 1, style(h) != style(h-1))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(h != 2, style(h) != style(h-2))) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Or(Exists([h1:houses], And(h1 == h+1, style(h1) == Tudor)), Exists([h2:houses], And(h2 == h-1, style(h2) == Tudor))))) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house
# Options
is_valid(Count([h:houses], style(h) == ranch) == 1) ::: (A)
is_valid(Count([h:houses], style(h) == Tudor) == 1) ::: (B)
is_valid(Count([h:houses], style(h) == Tudor) == 2) ::: (C)
is_valid(Count([h:houses], style(h) == ranch) == 4) ::: (D)
is_valid(Count([h:houses], style(h) == ranch) == 5) ::: (E)"
"# Context:
Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.

# Question:
Which one of the following could be true?

# Options:
A) F's stall is numbered one higher than J's stall.
B) H's stall faces M's stall.
C) J is assigned to stall 4.
D) K's stall faces J's stall.
E) K's stall is in a different row than J's stall.","# Declarations
animals = EnumSort([F, G, H, J, K, M])
stalls = EnumSort([1, 2, 3, 4, 5, 6])
assigned = Function([animals] -> [stalls])
# Constraints
ForAll([a:animals], Exists([s:stalls], assigned(a) == s)) ::: Each animal will be assigned to exactly one stall
assigned(F) == 1 ::: A lion must be assigned to stall 1
assigned(H) == 6 ::: H must be assigned to stall 6
assigned(J) == assigned(K) + 1 ::: J must be assigned to a stall numbered one higher than K's stall
Not(assigned(K) == 3) ::: K cannot be assigned to the stall that faces H's stall
ForAll([a1:animals, a2:animals], Implies(And(a1 == K, a2 == M), Not(Or(assigned(a1) == 1, assigned(a1) == 4, assigned(a1) == 2, assigned(a1) == 5, assigned(a1) == 3, assigned(a1) == 6)))) ::: The tigers' stalls cannot face each other
# Options
is_valid(assigned(F) == assigned(J) + 1) ::: (A)
is_valid(Or(assigned(H) == 4, assigned(M) == 6)) ::: (B)
is_valid(assigned(J) == 4) ::: (C)
is_valid(Or(assigned(K) == 1, assigned(J) == 4)) ::: (D)
is_valid(Or(assigned(K) == 1, assigned(K) == 2, assigned(K) == 3, assigned(J) == 4, assigned(J) == 5, assigned(J) == 6)) ::: (E)"
"# Context:
Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.

# Question:
If X is added to class 1, which one of the following is a student who must be added to class 2?

# Options:
A) T
B) V
C) W
D) Y
E) Z","# Declarations
students = EnumSort([R, S, T, V, W, X, Y, Z])
classes = EnumSort([class1, class2, class3])
assigned = Function([students] -> [classes])
# Constraints
Count([s:students], assigned(s) == class1) == 3 ::: class 1 will gain three new students
Count([s:students], assigned(s) == class2) == 3 ::: class 2 will gain three new students
Count([s:students], assigned(s) == class3) == 2 ::: class 3 will gain two new students
assigned(R) == class1 ::: R must be added to class 1
assigned(S) == class3 ::: S must be added to class 3
assigned(S) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(W) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(V) != assigned(Z) ::: V cannot be added to the same class as Z
Implies(assigned(T) == class1, assigned(Z) == class1) ::: If T is added to class 1, Z must also be added to class 1
assigned(X) == class1 ::: If X is added to class 1
# Options
is_valid(assigned(T) == class2) ::: (A)
is_valid(assigned(V) == class2) ::: (B)
is_valid(assigned(W) == class2) ::: (C)
is_valid(assigned(Y) == class2) ::: (D)
is_valid(assigned(Z) == class2) ::: (E)"
"# Context:
Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.

# Question:
If J is assigned to stall 3, which one of the following could be true?

# Options:
A) F is assigned to stall 2.
B) F is assigned to stall 4.
C) G is assigned to stall 1.
D) G is assigned to stall 4.
E) M is assigned to stall 5.","# Declarations
animals = EnumSort([F, G, H, J, K, M])
stalls = EnumSort([1, 2, 3, 4, 5, 6])
assigned = Function([animals] -> [stalls])
# Constraints
ForAll([a:animals], Exists([s:stalls], assigned(a) == s)) ::: Each animal will be assigned to exactly one stall
ForAll([s:stalls], Exists([a:animals], assigned(a) == s)) ::: Each stall will have exactly one animal assigned to it
assigned(H) == 6 ::: H must be assigned to stall 6
assigned(J) == assigned(K) + 1 ::: J must be assigned to a stall numbered one higher than K's stall
assigned(K) != 3 ::: K cannot be assigned to the stall that faces H's stall
ForAll([a:animals], Implies(Or(a == K, a == M), And(assigned(a) != 1, assigned(a) != 4))) ::: The tigers' stalls cannot face each other
Exists([a:animals], And(a != K, a != M, assigned(a) == 1)) ::: A lion must be assigned to stall 1
# Options
is_valid(assigned(F) == 2) ::: (A)
is_valid(assigned(F) == 4) ::: (B)
is_valid(assigned(G) == 1) ::: (C)
is_valid(assigned(G) == 4) ::: (D)
is_valid(assigned(M) == 5) ::: (E)"
"# Context:
Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.

# Question:
Which one of the following must be true?

# Options:
A) F is assigned to an even-numbered stall.
B) F is assigned to stall 1.
C) J is assigned to stall 2 or else stall 3.
D) J is assigned to stall 3 or else stall 4.
E) K is assigned to stall 2 or else stall 4.","# Declarations
animals = EnumSort([F, G, H, J, K, M])
stalls = EnumSort([1, 2, 3, 4, 5, 6])
assigned = Function([animals] -> [stalls])
# Constraints
ForAll([a:animals], Exists([s:stalls], assigned(a) == s)) ::: Each animal will be assigned to exactly one stall
ForAll([s:stalls], Exists([a:animals], assigned(a) == s)) ::: Each stall will have exactly one animal assigned to it
assigned(F) == 1 ::: A lion must be assigned to stall 1
assigned(H) == 6 ::: H must be assigned to stall 6
assigned(J) == assigned(K) + 1 ::: J must be assigned to a stall numbered one higher than K's stall
Not(assigned(K) == 3) ::: K cannot be assigned to the stall that faces H's stall
ForAll([a1:animals, a2:animals], Implies(And(a1 == K, a2 == M), Not(Or(assigned(a1) == 4, assigned(a2) == 4)))) ::: The tigers' stalls cannot face each other
# Options
is_valid(assigned(F) % 2 == 0) ::: (A)
is_valid(assigned(F) == 1) ::: (B)
is_valid(Or(assigned(J) == 2, assigned(J) == 3)) ::: (C)
is_valid(Or(assigned(J) == 3, assigned(J) == 4)) ::: (D)
is_valid(Or(assigned(K) == 2, assigned(K) == 4)) ::: (E)"
"# Context:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.

# Question:
If house 4 is a Tudor house, then it could be true that house

# Options:
A) 1 is a Tudor house
B) 2 is a Tudor house
C) 5 is a ranch house
D) 7 is a Tudor house
E) 8 is a ranch house","# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])
# Constraints
ForAll([h:houses], Implies(h != 1, style(h) != style(h-1))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(And(h != 2, h != 4, h != 6, h != 8), style(h) != style(h+1))) ::: Adjacent houses are of different styles
style(2) != style(4) ::: No split-level house faces another split-level house
style(4) != style(6) ::: No split-level house faces another split-level house
style(6) != style(8) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Or(style(h-1) == Tudor, style(h+1) == Tudor))) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house
style(4) == Tudor ::: House 4 is a Tudor house
# Options
is_valid(style(1) == Tudor) ::: (A)
is_valid(style(2) == Tudor) ::: (B)
is_valid(style(5) == ranch) ::: (C)
is_valid(style(7) == Tudor) ::: (D)
is_valid(style(8) == ranch) ::: (E)"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
If at noon K is within exactly two of the four areas, then which one of the following CANNOT be true at that time?

# Options:
A) J is within area T.
B) K is within area R.
C) K is within area T.
D) L is within area R.
E) L is within area T.","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
location = Function([planes] -> [areas])
# Constraints
ForAll([p:planes], Exists([a:areas], location(p) == a)) ::: Each plane is in at least one of the four areas
location(J) == S ::: J is in area S
ForAll([a:areas], Implies(location(J) == a, location(K) != a)) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(location(M) == a, location(L) != a)) ::: L is not in any detection area that M is in
Count([a:areas], location(M) == a) == 1 ::: M is in exactly one of the areas
Count([a:areas], location(K) == a) == 2 ::: K is within exactly two of the four areas
# Options
is_unsat(location(J) == T) ::: (A)
is_unsat(location(K) == R) ::: (B)
is_unsat(location(K) == T) ::: (C)
is_unsat(location(L) == R) ::: (D)
is_unsat(location(L) == T) ::: (E)"
"# Context:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.

# Question:
If there is one ranch house directly opposite another ranch house, which one of the following could be true?

# Options:
A) House 8 is a ranch house.
B) House 7 is a split-level house.
C) House 4 is a Tudor house.
D) House 2 is a split-level house.
E) House 1 is a ranch house.","# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])
# Constraints
ForAll([h:houses], Implies(h != 1, style(h) != style(h-1))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(h != 2, style(h) != style(h-2))) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Or(Exists([h1:houses], And(h1 == h+1, style(h1) == Tudor)), Exists([h2:houses], And(h2 == h-1, style(h2) == Tudor))))) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house
Exists([h:houses], And(style(h) == ranch, style(h+1) == ranch)) ::: There is one ranch house directly opposite another ranch house
# Options
is_valid(style(8) == ranch) ::: (A)
is_valid(style(7) == split_level) ::: (B)
is_valid(style(4) == Tudor) ::: (C)
is_valid(style(2) == split_level) ::: (D)
is_valid(style(1) == ranch) ::: (E)"
"# Context:
A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.

# Question:
If K delivers the first speech and H delivers the fifth speech, which one of the following must be true?

# Options:
A) R delivers the third speech.
B) T delivers the fourth speech.
C) J's speech is immediately before H's speech.
D) K's speech is immediately before T's speech.
E) R's speech is immediately before J's speech.","# Declarations
students = EnumSort([H, J, K, R, S, T])
speeches = EnumSort([1, 2, 3, 4, 5, 6])
delivers = Function([students] -> [speeches])
# Constraints
ForAll([s:students], Exists([s1:students], delivers(s) == delivers(s1))) ::: Each student delivers exactly one speech
ForAll([s:students], Count([s1:students], delivers(s1) == delivers(s)) == 1) ::: Each speech is delivered by exactly one student
Not(And(delivers(H) == delivers(J) - 1, delivers(J) == delivers(K) - 1)) ::: H, J, and K cannot form a sequence of three consecutive speeches
Not(And(delivers(R) == delivers(S) - 1, delivers(S) == delivers(T) - 1)) ::: R, S, and T cannot form a sequence of three consecutive speeches
delivers(H) < delivers(S) ::: H's speech must be earlier than S's speech
Or(delivers(J) != 1, delivers(J) != 6) ::: J's speech can be neither first nor sixth
Not(Or(delivers(T) == delivers(J) - 1, delivers(T) == delivers(J) + 1)) ::: T's speech can be neither immediately before nor immediately after J's speech
delivers(K) == 1 ::: K delivers the first speech
delivers(H) == 5 ::: H delivers the fifth speech
# Options
is_valid(delivers(R) == 3) ::: (A)
is_valid(delivers(T) == 4) ::: (B)
is_valid(delivers(J) == delivers(H) - 1) ::: (C)
is_valid(delivers(K) == delivers(T) - 1) ::: (D)
is_valid(delivers(R) == delivers(J) - 1) ::: (E)"
"# Context:
During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.

# Question:
If Otto does not run during the year, then which one of the following statements must be false?

# Options:
A) Nikki's fall sport is running.
B) Nikki's spring sport is running.
C) Nikki's summer sport is kayaking.
D) Otto's fall sport is mountaineering.
E) Otto's spring sport is kayaking.","# Declarations
seasons = EnumSort([fall, winter, spring, summer])
sports = EnumSort([hockey, kayaking, mountaineering, running, volleyball])
children = EnumSort([Nikki, Otto])
participates = Function([children, seasons] -> [sports])
# Constraints
ForAll([c:children], Count([s:seasons], participates(c, s) == mountaineering) + Count([s:seasons], participates(c, s) == running) + Count([s:seasons], participates(c, s) == volleyball) == 4) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], participates(c, fall) == mountaineering or participates(c, fall) == running or participates(c, fall) == volleyball) ::: In the fall, each child participates in mountaineering, running, or volleyball
ForAll([c:children], participates(c, winter) == hockey or participates(c, winter) == volleyball) ::: In the winter, each child participates in hockey or volleyball
ForAll([c:children], participates(c, spring) == kayaking or participates(c, spring) == mountaineering or participates(c, spring) == running or participates(c, spring) == volleyball) ::: In the spring, each child participates in kayaking, mountaineering, running, or volleyball
ForAll([c:children], participates(c, summer) == kayaking or participates(c, summer) == mountaineering or participates(c, summer) == volleyball) ::: In the summer, each child participates in kayaking, mountaineering, or volleyball
ForAll([s:seasons], participates(Nikki, s) != participates(Otto, s)) ::: Nikki and Otto do not participate in the same sport during the same season
participates(Otto, summer) == volleyball ::: Otto's summer sport is volleyball
ForAll([s:seasons], participates(Otto, s) != running) ::: Otto does not run during the year
# Options
is_unsat(participates(Nikki, fall) == running) ::: (A)
is_unsat(participates(Nikki, spring) == running) ::: (B)
is_unsat(participates(Nikki, summer) == kayaking) ::: (C)
is_unsat(participates(Otto, fall) == mountaineering) ::: (D)
is_unsat(participates(Otto, spring) == kayaking) ::: (E)"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
Which one of the following could be a complete listing of the planes located in the four areas at noon, with each plane listed in every area in which it is located?

# Options:
A) R: J, L; S: J, M; T: L; U: L
B) R: J, L; S: K; T: M; U: none
C) R: K; S: J; T: L; U: M
D) R: K, M; S: J, L; T: J; U: none
E) R: M; S: J, K; T: J, L; U: none","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
located = Function([planes, areas] -> [bool])
# Constraints
ForAll([p:planes], Exists([a:areas], located(p, a))) ::: Each plane is in at least one of the four areas
located(J, S) ::: J is in area S
ForAll([a:areas], Implies(located(J, a), Not(located(K, a)))) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(located(L, a), Not(located(M, a)))) ::: L is not in any detection area that M is in
Count([a:areas], located(M, a)) == 1 ::: M is in exactly one of the areas
# Options
is_accurate_list([located(J, R), located(L, R), located(J, S), located(M, S), located(L, T), located(L, U)]) ::: (A)
is_accurate_list([located(J, R), located(L, R), located(K, S), located(M, T)]) ::: (B)
is_accurate_list([located(K, R), located(J, S), located(L, T), located(M, U)]) ::: (C)
is_accurate_list([located(K, R), located(M, R), located(J, S), located(L, S), located(J, T)]) ::: (D)
is_accurate_list([located(M, R), located(J, S), located(K, S), located(J, T), located(L, T)]) ::: (E)"
"# Context:
Five experienced plumbers—Frank, Gene, Jill, Kathy, and Mark—and four inexperienced plumbers—Roberta, Sally, Tim, and Vernon—must decide which of them will be assigned to four work teams of exactly two plumbers each. Assignments must meet the following restrictions: Each plumber is assigned to at most one team. At least one plumber on each team must be experienced. Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank. If Tim is assigned to a team, either Gene or Kathy must be assigned to that team. Jill cannot be assigned to a team with Roberta.

# Question:
Which one of the following is an inexperienced plumber who can be assigned to a team with Frank?

# Options:
A) Kathy
B) Roberta
C) Sally
D) Tim
E) Vernon","# Declarations
experienced_plumbers = EnumSort([Frank, Gene, Jill, Kathy, Mark])
inexperienced_plumbers = EnumSort([Roberta, Sally, Tim, Vernon])
teams = EnumSort([team1, team2, team3, team4])
assigned = Function([experienced_plumbers, inexperienced_plumbers] -> [teams])
# Constraints
ForAll([e:experienced_plumbers, i:inexperienced_plumbers], assigned(e, i) != None) ::: Each plumber is assigned to at most one team
ForAll([t:teams], Exists([e:experienced_plumbers, i:inexperienced_plumbers], assigned(e, i) == t)) ::: At least one plumber on each team must be experienced
ForAll([i:inexperienced_plumbers], assigned(Frank, i) != None) ::: Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank
ForAll([e:experienced_plumbers], assigned(e, Roberta) != None) ::: Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank
ForAll([e:experienced_plumbers], assigned(e, Vernon) != None) ::: Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank
Implies(assigned(e, Tim) != None, Or(assigned(Gene, i) != None, assigned(Kathy, i) != None)) ::: If Tim is assigned to a team, either Gene or Kathy must be assigned to that team
ForAll([i:inexperienced_plumbers], assigned(Jill, i) != None) ::: Jill cannot be assigned to a team with Roberta
# Options
is_valid(assigned(Frank, Sally) != None) ::: (C)"
"# Context:
A breeder has ten birds: Kind Male Female Goldfinches H J, K Lovebirds M N Parakeets Q, R, S T, W The breeder exhibits pairs of birds consisting of one male and one female of the same kind. At most two pairs can be exhibited at a time; the remaining birds must be distributed between two cages. The breeder is constrained by the following conditions: Neither cage can contain more than four birds. Any two birds that are both of the same sex and of the same kind as each other cannot be caged together. Whenever either J or W is exhibited, S cannot be exhibited.

# Question:
If Q and T are among the birds assigned to the cages, which one of the following is a pair of birds that must be exhibited?

# Options:
A) H and J
B) H and K
C) M and N
D) R and W
E) S and W","# Declarations
birds = EnumSort([H, J, K, M, N, Q, R, S, T, W])
genders = EnumSort([Male, Female])
kinds = EnumSort([Goldfinch, Lovebird, Parakeet])
caged = Function([birds] -> [bool])
exhibited = Function([birds, birds] -> [bool])
bird_gender = Function([birds] -> [genders])
bird_kind = Function([birds, birds] -> [bool])
# Constraints
Count([b:birds], caged(b)) <= 8 ::: At most two pairs can be exhibited at a time
ForAll([b1:birds, b2:birds], Implies(exhibited(b1, b2), And(bird_gender(b1) != bird_gender(b2), bird_kind(b1, b2)))) ::: Exhibited pairs consist of one male and one female of the same kind
ForAll([c1:birds, c2:birds], Implies(And(caged(c1), caged(c2), bird_gender(c1) == bird_gender(c2), bird_kind(c1, c2)), c1 == c2)) ::: Any two birds that are both of the same sex and of the same kind as each other cannot be caged together
ForAll([b:birds], Implies(Or(exhibited(J, b), exhibited(W, b)), Not(exhibited(S, b)))) ::: Whenever either J or W is exhibited, S cannot be exhibited
caged(Q) ::: Q is among the birds assigned to the cages
caged(T) ::: T is among the birds assigned to the cages
# Options
is_valid(And(exhibited(H, J), Not(caged(H)), Not(caged(J)))) ::: (A)
is_valid(And(exhibited(H, K), Not(caged(H)), Not(caged(K)))) ::: (B)
is_valid(And(exhibited(M, N), Not(caged(M)), Not(caged(N)))) ::: (C)
is_valid(And(exhibited(R, W), Not(caged(R)), Not(caged(W)))) ::: (D)
is_valid(And(exhibited(S, W), Not(caged(S)), Not(caged(W)))) ::: (E)"
"# Context:
On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.

# Question:
Any of the following could be a Tudor house EXCEPT house

# Options:
A) 1
B) 2
C) 4
D) 7
E) 8","# Declarations
houses = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
styles = EnumSort([ranch, split_level, Tudor])
style = Function([houses] -> [styles])
# Constraints
ForAll([h:houses], Implies(h != 1, style(h) != style(h-1))) ::: Adjacent houses are of different styles
ForAll([h:houses], Implies(h != 8, style(h) != style(h+1))) ::: Adjacent houses are of different styles
style(2) != style(6) ::: No split-level house faces another split-level house
style(4) != style(6) ::: No split-level house faces another split-level house
style(6) != style(8) ::: No split-level house faces another split-level house
ForAll([h:houses], Implies(style(h) == ranch, Or(style(h-1) == Tudor, style(h+1) == Tudor))) ::: Every ranch house has at least one Tudor house adjacent to it
style(3) == ranch ::: House 3 is a ranch house
style(6) == split_level ::: House 6 is a split-level house
# Options
is_unsat(style(1) == Tudor) ::: (A)
is_unsat(style(2) == Tudor) ::: (B)
is_unsat(style(4) == Tudor) ::: (C)
is_unsat(style(7) == Tudor) ::: (D)
is_unsat(style(8) == Tudor) ::: (E)"
"# Context:
Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.

# Question:
Which one of the following must be true?

# Options:
A) If T and X are added to class 2, V is added to class 3.
B) If V and W are added to class 1, T is added to class 3.
C) If V and W are added to class 1, Z is added to class 3.
D) If V and X are added to class 1, W is added to class 3.
E) If Y and Z are added to class 2, X is added to class 2.","# Declarations
students = EnumSort([R, S, T, V, W, X, Y, Z])
classes = EnumSort([class1, class2, class3])
assigned = Function([students] -> [classes])
# Constraints
Count([s:students], assigned(s) == class1) == 3 ::: class 1 will gain three new students
Count([s:students], assigned(s) == class2) == 3 ::: class 2 will gain three new students
Count([s:students], assigned(s) == class3) == 2 ::: class 3 will gain two new students
assigned(R) == class1 ::: R must be added to class 1
assigned(S) == class3 ::: S must be added to class 3
assigned(S) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(W) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(V) != assigned(Z) ::: V cannot be added to the same class as Z
Implies(assigned(T) == class1, assigned(Z) == class1) ::: If T is added to class 1, Z must also be added to class 1
# Options
is_valid(Implies(And(assigned(T) == class2, assigned(X) == class2), assigned(V) == class3)) ::: (A)
is_valid(Implies(And(assigned(V) == class1, assigned(W) == class1), assigned(T) == class3)) ::: (B)
is_valid(Implies(And(assigned(V) == class1, assigned(W) == class1), assigned(Z) == class3)) ::: (C)
is_valid(Implies(And(assigned(V) == class1, assigned(X) == class1), assigned(W) == class3)) ::: (D)
is_valid(Implies(And(assigned(Y) == class2, assigned(Z) == class2), assigned(X) == class2)) ::: (E)"
"# Context:
During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.

# Question:
Which one of the following statements could be true?

# Options:
A) Nikki's fall sport is neither mountaineering nor running.
B) Nikki's spring sport is neither mountaineering nor running.
C) Nikki's summer sport is neither kayaking nor mountaineering.
D) Otto's fall sport is neither mountaineering nor running.
E) Otto's spring sport is neither kayaking, nor mountaineering, nor running.","# Declarations
seasons = EnumSort([fall, winter, spring, summer])
sports = EnumSort([hockey, kayaking, mountaineering, running, volleyball])
children = EnumSort([Nikki, Otto])
participates = Function([children, seasons] -> [sports])
# Constraints
ForAll([c:children], Count([s:seasons], participates(c, s) == mountaineering) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == running) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == kayaking) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == hockey) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == volleyball) == 1) ::: Each child participates in exactly four different sports during the year
ForAll([c:children], participates(c, fall) != hockey) ::: In the fall, each child participates in mountaineering, running, or volleyball
ForAll([c:children], participates(c, fall) != kayaking) ::: In the fall, each child participates in mountaineering, running, or volleyball
ForAll([c:children], participates(c, winter) != mountaineering) ::: In the winter, each child participates in hockey or volleyball
ForAll([c:children], participates(c, winter) != running) ::: In the winter, each child participates in hockey or volleyball
ForAll([c:children], participates(c, winter) != kayaking) ::: In the winter, each child participates in hockey or volleyball
ForAll([c:children], participates(c, spring) != hockey) ::: In the spring, each child participates in kayaking, mountaineering, running, or volleyball
ForAll([c:children], participates(c, summer) != hockey) ::: In the summer, each child participates in kayaking, mountaineering, or volleyball
ForAll([c:children], participates(c, summer) != running) ::: In the summer, each child participates in kayaking, mountaineering, or volleyball
participates(Otto, summer) == volleyball ::: Otto's summer sport is volleyball
ForAll([s:seasons], participates(Nikki, s) != participates(Otto, s)) ::: Nikki and Otto do not participate in the same sport during the same season
# Options
is_valid(And(participates(Nikki, fall) != mountaineering, participates(Nikki, fall) != running)) ::: (A)
is_valid(And(participates(Nikki, spring) != mountaineering, participates(Nikki, spring) != running)) ::: (B)
is_valid(And(participates(Nikki, summer) != kayaking, participates(Nikki, summer) != mountaineering)) ::: (C)
is_valid(And(participates(Otto, fall) != mountaineering, participates(Otto, fall) != running)) ::: (D)
is_valid(And(participates(Otto, spring) != kayaking, participates(Otto, spring) != mountaineering, participates(Otto, spring) != running)) ::: (E)"
"# Context:
A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.

# Question:
If K delivers the third speech, any of the following could be the student who makes the fourth speech EXCEPT

# Options:
A) H
B) J
C) R
D) S
E) T","# Declarations
students = EnumSort([H, J, K, R, S, T])
speeches = EnumSort([1, 2, 3, 4, 5, 6])
delivered = Function([students] -> [speeches])
# Constraints
ForAll([s:students], Exists([s1:students], delivered(s) == delivered(s1))) ::: Each student delivers exactly one speech
ForAll([s:students], delivered(s) != 1) ::: J's speech can be neither first nor sixth
ForAll([s:students], delivered(s) != 6) ::: J's speech can be neither first nor sixth
ForAll([s:students], delivered(s) != delivered(J) + 1) ::: T's speech can be neither immediately before nor immediately after J's speech
ForAll([s:students], delivered(s) != delivered(J) - 1) ::: T's speech can be neither immediately before nor immediately after J's speech
delivered(H) < delivered(S) ::: H's speech must be earlier than S's speech
delivered(K) == 3 ::: K delivers the third speech
# Options
is_unsat(delivered(H) == 4) ::: (A)
is_unsat(delivered(J) == 4) ::: (B)
is_unsat(delivered(R) == 4) ::: (C)
is_unsat(delivered(S) == 4) ::: (D)
is_unsat(delivered(T) == 4) ::: (E)"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
If at noon M is within area T, then which one of the following statements CANNOT be true at that time?

# Options:
A) J is within area T.
B) L is within area R.
C) L is within area S.
D) K is within exactly two areas.
E) L is within exactly two areas.","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
location = Function([planes] -> [areas])
# Constraints
ForAll([p:planes], Exists([a:areas], location(p) == a)) ::: Each plane is in at least one of the four areas
location(J) == S ::: J is in area S
ForAll([a:areas], Implies(location(J) == a, location(K) != a)) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(location(L) == a, location(M) != a)) ::: L is not in any detection area that M is in
Count([a:areas], location(M) == a) == 1 ::: M is in exactly one of the areas
location(M) == T ::: If at noon M is within area T
# Options
is_unsat(location(J) == T) ::: (A)
is_unsat(location(L) == R) ::: (B)
is_unsat(location(L) == S) ::: (C)
is_unsat(Count([a:areas], location(K) == a) == 2) ::: (D)
is_unsat(Count([a:areas], location(L) == a) == 2) ::: (E)"
"# Context:
A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.

# Question:
Which one of the following could be true?

# Options:
A) There is exactly one technician.
B) There are exactly two managers.
C) There are exactly two employees who are not supervised.
D) There are more managers than technicians.
E) The president supervises all of the other employees.","# Declarations
employees = EnumSort([F, G, H, K, L])
positions = EnumSort([president, manager, technician])
supervises = Function([employees, employees] -> [bool])
holds_position = Function([employees] -> [positions])
# Constraints
Exists([e:employees], holds_position(e) == president) ::: There is exactly one president
ForAll([e:employees], Implies(holds_position(e) == president, ForAll([e1:employees], supervises(e, e1) == False))) ::: Only the president is not supervised
ForAll([e:employees], Implies(holds_position(e) != president, Exists([e1:employees], And(supervises(e1, e), holds_position(e1) != holds_position(e))))) ::: Other employees are each supervised by exactly one employee, who is either the president or a manager, and holds a different position
Exists([e:employees], And(holds_position(e) == president, Exists([e1:employees], And(supervises(e, e1), holds_position(e1) == manager)))) ::: At least one of the employees whom the president supervises is a manager
ForAll([e:employees], Implies(holds_position(e) == manager, Exists([e1:employees], supervises(e, e1)))) ::: Each manager supervises at least one employee
ForAll([e:employees], supervises(F, e) == False) ::: F does not supervise any employee
Count([e:employees], supervises(G, e)) == 2 ::: G supervises exactly two employees
# Options
is_valid(Count([e:employees], holds_position(e) == technician) == 1) ::: (A)
is_valid(Count([e:employees], holds_position(e) == manager) == 2) ::: (B)
is_valid(Count([e:employees], ForAll([e1:employees], supervises(e1, e) == False)) == 2) ::: (C)
is_valid(Count([e:employees], holds_position(e) == manager) > Count([e:employees], holds_position(e) == technician)) ::: (D)
is_valid(Exists([e:employees], And(holds_position(e) == president, ForAll([e1:employees], Implies(e1 != e, supervises(e, e1)))))) ::: (E)"
"# Context:
Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.

# Question:
If T is added to class 3, which one of the following is a student who must be added to class 2?

# Options:
A) V
B) W
C) X
D) Y
E) Z","# Declarations
students = EnumSort([R, S, T, V, W, X, Y, Z])
classes = EnumSort([class1, class2, class3])
assigned = Function([students] -> [classes])
# Constraints
Count([s:students], assigned(s) == class1) == 3 ::: class 1 will gain three new students
Count([s:students], assigned(s) == class2) == 3 ::: class 2 will gain three new students
Count([s:students], assigned(s) == class3) == 2 ::: class 3 will gain two new students
assigned(R) == class1 ::: R must be added to class 1
assigned(S) == class3 ::: S must be added to class 3
assigned(S) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(W) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(V) != assigned(Z) ::: V cannot be added to the same class as Z
Implies(assigned(T) == class1, assigned(Z) == class1) ::: If T is added to class 1, Z must also be added to class 1
assigned(T) == class3 ::: If T is added to class 3
# Options
is_valid(assigned(V) == class2) ::: (A)
is_valid(assigned(W) == class2) ::: (B)
is_valid(assigned(X) == class2) ::: (C)
is_valid(assigned(Y) == class2) ::: (D)
is_valid(assigned(Z) == class2) ::: (E)"
"# Context:
Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.

# Question:
Which one of the following is an acceptable assignment of students to the three classes?

# Options:
A) R, T, Y V, W, X S, Z
B) R, T, Z S, V, Y W, X
C) R, W, X V, Y, Z S, T
D) R, X, Z T, V, Y S, W
E) R, X, Z V, W, Y S, T","# Declarations
students = EnumSort([R, S, T, V, W, X, Y, Z])
classes = EnumSort([class1, class2, class3])
assigned = Function([students] -> [classes])
# Constraints
Count([s:students], assigned(s) == class1) == 3 ::: class 1 will gain three new students
Count([s:students], assigned(s) == class2) == 3 ::: class 2 will gain three new students
Count([s:students], assigned(s) == class3) == 2 ::: class 3 will gain two new students
assigned(R) == class1 ::: R must be added to class 1
assigned(S) == class3 ::: S must be added to class 3
assigned(S) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(W) != assigned(Y) ::: Neither S nor W can be added to the same class as Y
assigned(V) != assigned(Z) ::: V cannot be added to the same class as Z
Implies(assigned(T) == class1, assigned(Z) == class1) ::: If T is added to class 1, Z must also be added to class 1
# Options
is_sat(And(assigned(R) == class1, assigned(T) == class1, assigned(Y) == class1, assigned(V) == class2, assigned(W) == class2, assigned(X) == class2, assigned(S) == class3, assigned(Z) == class3)) ::: (A)
is_sat(And(assigned(R) == class1, assigned(T) == class1, assigned(Z) == class1, assigned(S) == class3, assigned(V) == class2, assigned(Y) == class2, assigned(W) == class2, assigned(X) == class2)) ::: (B)
is_sat(And(assigned(R) == class1, assigned(W) == class1, assigned(X) == class1, assigned(V) == class2, assigned(Y) == class2, assigned(Z) == class2, assigned(S) == class3, assigned(T) == class3)) ::: (C)
is_sat(And(assigned(R) == class1, assigned(X) == class1, assigned(Z) == class1, assigned(T) == class1, assigned(V) == class2, assigned(Y) == class2, assigned(S) == class3, assigned(W) == class3)) ::: (D)
is_sat(And(assigned(R) == class1, assigned(X) == class1, assigned(Z) == class1, assigned(V) == class2, assigned(W) == class2, assigned(Y) == class2, assigned(S) == class3, assigned(T) == class3)) ::: (E)"
"# Context:
A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.

# Question:
If T delivers the third speech, which one of the following must be true?

# Options:
A) H delivers the first speech.
B) J delivers the fifth speech.
C) K delivers the fourth speech.
D) R delivers the sixth speech.
E) S delivers the fourth speech.","# Declarations
students = EnumSort([H, J, K, R, S, T])
speeches = EnumSort([1, 2, 3, 4, 5, 6])
delivered = Function([students] -> [speeches])
# Constraints
ForAll([s:students], Exists([s1:students], delivered(s) == delivered(s1))) ::: Each student delivers exactly one speech
Not(And(delivered(H) == 1, delivered(J) == 2, delivered(K) == 3)) ::: H, J, and K cannot form a sequence of three consecutive speeches
Not(And(delivered(H) == 2, delivered(J) == 3, delivered(K) == 4)) ::: H, J, and K cannot form a sequence of three consecutive speeches
Not(And(delivered(H) == 3, delivered(J) == 4, delivered(K) == 5)) ::: H, J, and K cannot form a sequence of three consecutive speeches
Not(And(delivered(H) == 4, delivered(J) == 5, delivered(K) == 6)) ::: H, J, and K cannot form a sequence of three consecutive speeches
Not(And(delivered(R) == 1, delivered(S) == 2, delivered(T) == 3)) ::: R, S, and T cannot form a sequence of three consecutive speeches
Not(And(delivered(R) == 2, delivered(S) == 3, delivered(T) == 4)) ::: R, S, and T cannot form a sequence of three consecutive speeches
Not(And(delivered(R) == 3, delivered(S) == 4, delivered(T) == 5)) ::: R, S, and T cannot form a sequence of three consecutive speeches
Not(And(delivered(R) == 4, delivered(S) == 5, delivered(T) == 6)) ::: R, S, and T cannot form a sequence of three consecutive speeches
delivered(H) < delivered(S) ::: H's speech must be earlier than S's speech
Or(delivered(J) != 1, delivered(J) != 6) ::: J's speech can be neither first nor sixth
Or(delivered(T) != delivered(J) - 1, delivered(T) != delivered(J) + 1) ::: T's speech can be neither immediately before nor immediately after J's speech
delivered(T) == 3 ::: T delivers the third speech
# Options
is_valid(delivered(H) == 1) ::: (A)
is_valid(delivered(J) == 5) ::: (B)
is_valid(delivered(K) == 4) ::: (C)
is_valid(delivered(R) == 6) ::: (D)
is_valid(delivered(S) == 4) ::: (E)"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
It CANNOT be true that at noon there is at least one plane that is within both area

# Options:
A) R and area T
B) R and area U
C) S and area T
D) S and area U
E) T and area U","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
in_area = Function([planes, areas] -> [bool])
# Constraints
ForAll([p:planes], Or(in_area(p, R), in_area(p, S), in_area(p, T), in_area(p, U))) ::: Each plane is in at least one of the four areas
in_area(J, S) ::: J is in area S
ForAll([a:areas], Implies(in_area(J, a), Not(in_area(K, a)))) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(in_area(M, a), Not(in_area(L, a)))) ::: L is not in any detection area that M is in
Count([a:areas], in_area(M, a)) == 1 ::: M is in exactly one of the areas
ForAll([p:planes], Implies(in_area(p, U), And(in_area(p, R), in_area(p, T)))) ::: Area U is completely within R and also completely within T
# Options
is_unsat(Exists([p:planes], And(in_area(p, R), in_area(p, T)))) ::: (A)
is_unsat(Exists([p:planes], And(in_area(p, R), in_area(p, U)))) ::: (B)
is_unsat(Exists([p:planes], And(in_area(p, S), in_area(p, T)))) ::: (C)
is_unsat(Exists([p:planes], And(in_area(p, S), in_area(p, U)))) ::: (D)
is_unsat(Exists([p:planes], And(in_area(p, T), in_area(p, U)))) ::: (E)"
"# Context:
Ron washed a total of seven objects after eating his lunch. Two of the objects were pieces of china: a mug and a plate. Two were pieces of glassware: a water glass and a juice glass. Three were utensils: a fork, a knife, and a spoon. Ron washed the two pieces of china consecutively, the two glasses consecutively, and the three utensils consecutively. He washed the objects as follows: Ron washed each of the objects exactly once. Ron washed the glassware after either the china or the utensils but not after both. He washed the knife before the spoon, and he washed the mug before the plate. He did not wash any two objects at the same time.

# Question:
If Ron washed a glass and the knife consecutively, but not necessarily in that order, then which one of the following statements must be false?

# Options:
A) He washed the fork before the plate.
B) He washed the fork before the spoon.
C) He washed the juice glass before the knife.
D) He washed the plate before the water glass.
E) He washed the spoon before the fork.","# Declarations
objects = EnumSort([mug, plate, water_glass, juice_glass, fork, knife, spoon])
washed_order = Function([objects, objects] -> [bool])
# Constraints
ForAll([o1:objects, o2:objects], Implies(washed_order(o1, o2), o1 != o2)) ::: Ron washed each of the objects exactly once
ForAll([o1:objects, o2:objects], Implies(washed_order(o1, o2), Not(washed_order(o2, o1)))) ::: He did not wash any two objects at the same time
washed_order(mug, plate) ::: Ron washed the mug before the plate
washed_order(water_glass, juice_glass) ::: Ron washed the two glasses consecutively
washed_order(fork, knife) ::: Ron washed the three utensils consecutively
washed_order(knife, spoon) ::: Ron washed the knife before the spoon
Or(And(washed_order(mug, water_glass), washed_order(mug, juice_glass)), And(washed_order(plate, water_glass), washed_order(plate, juice_glass)), And(washed_order(fork, water_glass), washed_order(fork, juice_glass)), And(washed_order(knife, water_glass), washed_order(knife, juice_glass)), And(washed_order(spoon, water_glass), washed_order(spoon, juice_glass))) ::: Ron washed the glassware after either the china or the utensils but not after both
Or(And(washed_order(water_glass, knife), washed_order(knife, water_glass)), And(washed_order(juice_glass, knife), washed_order(knife, juice_glass))) ::: Ron washed a glass and the knife consecutively, but not necessarily in that order
# Options
is_unsat(washed_order(fork, plate)) ::: (A)
is_unsat(washed_order(fork, spoon)) ::: (B)
is_unsat(washed_order(juice_glass, knife)) ::: (C)
is_unsat(washed_order(plate, water_glass)) ::: (D)
is_unsat(washed_order(spoon, fork)) ::: (E)"
"# Context:
A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.

# Question:
If R's speech is immediately after S's speech and immediately before K's speech, then which one of the following could be true?

# Options:
A) H's speech is immediately before S's speech.
B) H's speech is immediately before T's speech.
C) K's speech is immediately before J's speech.
D) K's speech is immediately before T's speech.
E) T's speech is immediately before S's speech.","# Declarations
students = EnumSort([H, J, K, R, S, T])
positions = EnumSort([1, 2, 3, 4, 5, 6])
delivered = Function([students] -> [positions])
# Constraints
ForAll([s:students], Exists([p:positions], delivered(s) == p)) ::: The professor will listen to exactly one speech from each of six students
ForAll([p:positions], Exists([s:students], delivered(s) == p)) ::: The six speeches will be delivered one at a time, consecutively
ForAll([p:positions], Implies(And(p <= 4, delivered(H) == p), delivered(J) != p + 1)) ::: The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(H) == p), delivered(K) != p + 2)) ::: The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(J) == p), delivered(H) != p + 1)) ::: The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(J) == p), delivered(K) != p + 1)) ::: The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(K) == p), delivered(H) != p + 2)) ::: The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(K) == p), delivered(J) != p + 1)) ::: The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(R) == p), delivered(S) != p + 1)) ::: The speeches delivered by R, S, and T cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(R) == p), delivered(T) != p + 2)) ::: The speeches delivered by R, S, and T cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(S) == p), delivered(R) != p + 1)) ::: The speeches delivered by R, S, and T cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(S) == p), delivered(T) != p + 1)) ::: The speeches delivered by R, S, and T cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(T) == p), delivered(R) != p + 2)) ::: The speeches delivered by R, S, and T cannot form a sequence of three consecutive speeches
ForAll([p:positions], Implies(And(p <= 4, delivered(T) == p), delivered(S) != p + 1)) ::: The speeches delivered by R, S, and T cannot form a sequence of three consecutive speeches
delivered(H) < delivered(S) ::: H's speech must be earlier than S's speech
Or(delivered(J) != 1, delivered(J) != 6) ::: J's speech can be neither first nor sixth
Or(delivered(T) != delivered(J) - 1, delivered(T) != delivered(J) + 1) ::: T's speech can be neither immediately before nor immediately after J's speech
delivered(R) == delivered(S) + 1 ::: R's speech is immediately after S's speech
delivered(R) == delivered(K) - 1 ::: R's speech is immediately before K's speech
# Options
is_valid(delivered(H) == delivered(S) - 1) ::: (A)
is_valid(delivered(H) == delivered(T) - 1) ::: (B)
is_valid(delivered(K) == delivered(J) - 1) ::: (C)
is_valid(delivered(K) == delivered(T) - 1) ::: (D)
is_valid(delivered(T) == delivered(S) - 1) ::: (E)"
"# Context:
A breeder has ten birds: Kind Male Female Goldfinches H J, K Lovebirds M N Parakeets Q, R, S T, W The breeder exhibits pairs of birds consisting of one male and one female of the same kind. At most two pairs can be exhibited at a time; the remaining birds must be distributed between two cages. The breeder is constrained by the following conditions: Neither cage can contain more than four birds. Any two birds that are both of the same sex and of the same kind as each other cannot be caged together. Whenever either J or W is exhibited, S cannot be exhibited.

# Question:
If Q and R are among the birds that are assigned to the cages, then it must be true that

# Options:
A) H is exhibited
B) K is exhibited
C) N is exhibited
D) J is assigned to one of the cages
E) T is assigned to one of the cages","# Declarations
birds = EnumSort([H, J, K, M, N, Q, R, S, T, W])
genders = EnumSort([Male, Female])
kinds = EnumSort([Goldfinch, Lovebird, Parakeet])
cages = EnumSort([Cage1, Cage2])
exhibited = Function([birds] -> [bool])
caged = Function([birds] -> [cages])
gender = Function([birds] -> [genders])
kind = Function([birds] -> [kinds])
# Constraints
ForAll([b:birds], Or(exhibited(b), Exists([c:cages], caged(b) == c))) ::: Each bird is either exhibited or caged
Count([b:birds], exhibited(b)) <= 2 ::: At most two pairs can be exhibited at a time
ForAll([c:cages], Count([b:birds], caged(b) == c) <= 4) ::: Neither cage can contain more than four birds
ForAll([b1:birds, b2:birds], Implies(And(b1 != b2, gender(b1) == gender(b2), kind(b1) == kind(b2)), caged(b1) != caged(b2))) ::: Any two birds that are both of the same sex and of the same kind as each other cannot be caged together
Implies(Or(exhibited(J), exhibited(W)), Not(exhibited(S))) ::: Whenever either J or W is exhibited, S cannot be exhibited
caged(Q) != None ::: Q is among the birds that are assigned to the cages
caged(R) != None ::: R is among the birds that are assigned to the cages
# Options
is_valid(exhibited(H)) ::: (A)
is_valid(exhibited(K)) ::: (B)
is_valid(exhibited(N)) ::: (C)
is_valid(caged(J) != None) ::: (D)
is_valid(caged(T) != None) ::: (E)"
"# Context:
An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.

# Question:
If neither fresco nor naturalism is scheduled for any day, which one of the following must be scheduled for day 1?

# Options:
A) history
B) lithography
C) oils
D) pastels
E) sculpture","# Declarations
lectures = EnumSort([fresco, history, lithography, naturalism, oils, pastels, sculpture, watercolors])
days = EnumSort([1, 2, 3])
times = EnumSort([morning, afternoon])
scheduled = Function([lectures] -> [days])
scheduled_time = Function([lectures] -> [times])
# Constraints
ForAll([l:lectures], Exists([d:days], scheduled(l) == d)) ::: Each lecture is scheduled for exactly one day
ForAll([d:days], Count([l:lectures], scheduled(l) == d) == 2) ::: There will be exactly two lectures each day
scheduled(oils) == 2 ::: Day 2 is the only day for which oils can be scheduled
ForAll([l:lectures], Implies(scheduled_time(l) == afternoon, And(l != sculpture, l != watercolors))) ::: Neither sculpture nor watercolors can be scheduled for the afternoon
ForAll([l:lectures], Implies(scheduled(l) == scheduled(lithography), And(l != oils, l != pastels))) ::: Neither oils nor pastels can be scheduled for the same day as lithography
ForAll([d:days], Implies(Or(scheduled(pastels) == d, scheduled(pastels) == d - 1), And(Exists([l:lectures], And(scheduled(l) == d + 1, Or(l == fresco, l == history))), Exists([l:lectures], And(scheduled(l) == d + 1, Or(l == fresco, l == history)))))) ::: If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order
ForAll([l:lectures], And(l != fresco, l != naturalism)) ::: Neither fresco nor naturalism is scheduled for any day
# Options
is_valid(scheduled(history) == 1) ::: (A)
is_valid(scheduled(lithography) == 1) ::: (B)
is_valid(scheduled(oils) == 1) ::: (C)
is_valid(scheduled(pastels) == 1) ::: (D)
is_valid(scheduled(sculpture) == 1) ::: (E)"
"# Context:
Ron washed a total of seven objects after eating his lunch. Two of the objects were pieces of china: a mug and a plate. Two were pieces of glassware: a water glass and a juice glass. Three were utensils: a fork, a knife, and a spoon. Ron washed the two pieces of china consecutively, the two glasses consecutively, and the three utensils consecutively. He washed the objects as follows: Ron washed each of the objects exactly once. Ron washed the glassware after either the china or the utensils but not after both. He washed the knife before the spoon, and he washed the mug before the plate. He did not wash any two objects at the same time.

# Question:
If Ron washed the spoon immediately before the fork, then which one of the following statements can be true?

# Options:
A) He washed the knife second.
B) He washed the knife third.
C) He washed the plate third.
D) He washed the plate sixth.
E) He washed the plate seventh.","# Declarations
objects = EnumSort([mug, plate, water_glass, juice_glass, fork, knife, spoon])
washed_order = Function([objects] -> [int])
# Constraints
Count([o:objects], True) == 7 ::: Ron washed a total of seven objects
ForAll([o:objects], Exists([o1:objects], washed_order(o) == washed_order(o1))) ::: Ron washed each of the objects exactly once
washed_order(mug) < washed_order(plate) ::: Ron washed the mug before the plate
washed_order(water_glass) < washed_order(juice_glass) ::: Ron washed the two glasses consecutively
washed_order(knife) < washed_order(spoon) ::: Ron washed the knife before the spoon
washed_order(spoon) == washed_order(fork) - 1 ::: Ron washed the spoon immediately before the fork
Or(washed_order(water_glass) > washed_order(plate), washed_order(water_glass) > washed_order(spoon)) ::: Ron washed the glassware after either the china or the utensils but not after both
# Options
is_valid(washed_order(knife) == 2) ::: (A)
is_valid(washed_order(knife) == 3) ::: (B)
is_valid(washed_order(plate) == 3) ::: (C)
is_valid(washed_order(plate) == 6) ::: (D)
is_valid(washed_order(plate) == 7) ::: (E)"
"# Context:
A breeder has ten birds: Kind Male Female Goldfinches H J, K Lovebirds M N Parakeets Q, R, S T, W The breeder exhibits pairs of birds consisting of one male and one female of the same kind. At most two pairs can be exhibited at a time; the remaining birds must be distributed between two cages. The breeder is constrained by the following conditions: Neither cage can contain more than four birds. Any two birds that are both of the same sex and of the same kind as each other cannot be caged together. Whenever either J or W is exhibited, S cannot be exhibited.

# Question:
Which one of the following lists two pairs of birds that the breeder can exhibit at the same time?

# Options:
A) H and J; M and N
B) H and J; S and T
C) H and K; M and N
D) H and K; R and W
E) M and N; S and W","# Declarations
birds = EnumSort([H, J, K, M, N, Q, R, S, T, W])
genders = EnumSort([Male, Female])
kinds = EnumSort([Goldfinch, Lovebird, Parakeet])
cages = EnumSort([Cage1, Cage2])
exhibited = Function([birds] -> [bool])
caged = Function([birds] -> [cages])
gender = Function([birds] -> [genders])
kind = Function([birds] -> [kinds])
# Constraints
Count([b:birds], exhibited(b)) <= 4 ::: At most two pairs can be exhibited at a time
ForAll([c:cages], Count([b:birds], caged(b) == c) <= 4) ::: Neither cage can contain more than four birds
ForAll([b1:birds, b2:birds], Implies(And(gender(b1) == gender(b2), kind(b1) == kind(b2), b1 != b2), Or(exhibited(b1), exhibited(b2), caged(b1) != caged(b2)))) ::: Any two birds that are both of the same sex and of the same kind as each other cannot be caged together
Implies(Or(exhibited(J), exhibited(W)), Not(exhibited(S))) ::: Whenever either J or W is exhibited, S cannot be exhibited
# Options
is_accurate_list([And(exhibited(H), exhibited(J)), And(exhibited(M), exhibited(N))]) ::: (A)
is_accurate_list([And(exhibited(H), exhibited(J)), And(exhibited(S), exhibited(T))]) ::: (B)
is_accurate_list([And(exhibited(H), exhibited(K)), And(exhibited(M), exhibited(N))]) ::: (C)
is_accurate_list([And(exhibited(H), exhibited(K)), And(exhibited(R), exhibited(W))]) ::: (D)
is_accurate_list([And(exhibited(M), exhibited(N)), And(exhibited(S), exhibited(W))]) ::: (E)"
"# Context:
A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.

# Question:
Which one of the following is a pair of employees who could serve as managers together?

# Options:
A) F, H
B) F, L
C) G, K
D) G, L
E) K, L","# Declarations
employees = EnumSort([F, G, H, K, L])
positions = EnumSort([president, manager, technician])
holds_position = Function([employees] -> [positions])
supervises = Function([employees, employees] -> [bool])
# Constraints
Exists([e:employees], holds_position(e) == president) ::: There is exactly one president
ForAll([e:employees], Implies(holds_position(e) != president, Exists([s:employees], And(holds_position(s) != technician, supervises(s, e))))) ::: Other employees are each supervised by exactly one employee, who is either the president or a manager
ForAll([e:employees], Implies(supervises(e, s), holds_position(e) != holds_position(s))) ::: Each supervised employee holds a different position than his or her supervisor
Exists([e:employees], And(holds_position(e) == president, Exists([s:employees], And(holds_position(s) == manager, supervises(e, s))))) ::: At least one of the employees whom the president supervises is a manager
ForAll([e:employees], Implies(holds_position(e) == manager, Exists([s:employees], supervises(e, s)))) ::: Each manager supervises at least one employee
ForAll([e:employees], Not(supervises(F, e))) ::: F does not supervise any employee
Count([e:employees], supervises(G, e)) == 2 ::: G supervises exactly two employees
# Options
is_valid(And(holds_position(F) == manager, holds_position(H) == manager)) ::: (A)
is_valid(And(holds_position(F) == manager, holds_position(L) == manager)) ::: (B)
is_valid(And(holds_position(G) == manager, holds_position(K) == manager)) ::: (C)
is_valid(And(holds_position(G) == manager, holds_position(L) == manager)) ::: (D)
is_valid(And(holds_position(K) == manager, holds_position(L) == manager)) ::: (E)"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
Which one of the following statements CANNOT be true at noon about the planes?

# Options:
A) K is within area T.
B) K is within area U.
C) L is within area R.
D) M is within area R.
E) M is within area U.","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
location = Function([planes] -> [areas])
# Constraints
ForAll([p:planes], Exists([a:areas], location(p) == a)) ::: Each plane is in at least one of the four areas
location(J) == S ::: J is in area S
ForAll([a:areas], Implies(location(J) == a, location(K) != a)) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(location(L) == a, location(M) != a)) ::: L is not in any detection area that M is in
Count([a:areas], location(M) == a) == 1 ::: M is in exactly one of the areas
# Options
is_unsat(location(K) == T) ::: (A)
is_unsat(location(K) == U) ::: (B)
is_unsat(location(L) == R) ::: (C)
is_unsat(location(M) == R) ::: (D)
is_unsat(location(M) == U) ::: (E)"
"# Context:
A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.

# Question:
Which one of the following could be the order, from first to last, in which the students deliver their speeches?

# Options:
A) H, J, R, S, T, K
B) H, R, T, K, S, J
C) K, J, T, H, S, R
D) R, J, K, T, H, S
E) T, R, J, S, K, H","# Declarations
students = EnumSort([H, J, K, R, S, T])
order = Function([students] -> [int])
# Constraints
ForAll([s1:students, s2:students], Implies(s1 != s2, order(s1) != order(s2))) ::: Each student delivers exactly one speech
ForAll([s1:students, s2:students, s3:students], Implies(And(s1 != s2, s2 != s3, s1 != s3), Not(And(order(s1) + 1 == order(s2), order(s2) + 1 == order(s3))))) ::: H, J, and K cannot form a sequence of three consecutive speeches
ForAll([s1:students, s2:students, s3:students], Implies(And(s1 != s2, s2 != s3, s1 != s3), Not(And(order(s1) + 1 == order(s2), order(s2) + 1 == order(s3))))) ::: R, S, and T cannot form a sequence of three consecutive speeches
order(H) < order(S) ::: H's speech must be earlier than S's speech
Not(order(J) == 1) ::: J's speech can be neither first nor sixth
Not(order(J) == 6) ::: J's speech can be neither first nor sixth
Not(And(order(T) == order(J) - 1, order(T) == order(J) + 1)) ::: T's speech can be neither immediately before nor immediately after J's speech
# Options
is_sat(And(order(H) == 1, order(J) == 2, order(R) == 3, order(S) == 4, order(T) == 5, order(K) == 6)) ::: (A)
is_sat(And(order(H) == 1, order(R) == 2, order(T) == 3, order(K) == 4, order(S) == 5, order(J) == 6)) ::: (B)
is_sat(And(order(K) == 1, order(J) == 2, order(T) == 3, order(H) == 4, order(S) == 5, order(R) == 6)) ::: (C)
is_sat(And(order(R) == 1, order(J) == 2, order(K) == 3, order(T) == 4, order(H) == 5, order(S) == 6)) ::: (D)
is_sat(And(order(T) == 1, order(R) == 2, order(J) == 3, order(S) == 4, order(K) == 5, order(H) == 6)) ::: (E)"
"# Context:
Ron washed a total of seven objects after eating his lunch. Two of the objects were pieces of china: a mug and a plate. Two were pieces of glassware: a water glass and a juice glass. Three were utensils: a fork, a knife, and a spoon. Ron washed the two pieces of china consecutively, the two glasses consecutively, and the three utensils consecutively. He washed the objects as follows: Ron washed each of the objects exactly once. Ron washed the glassware after either the china or the utensils but not after both. He washed the knife before the spoon, and he washed the mug before the plate. He did not wash any two objects at the same time.

# Question:
Which one of the following statements CANNOT be true?

# Options:
A) Ron washed the fork first.
B) Ron washed the fork second.
C) Ron washed the mug first.
D) Ron washed the plate second.
E) Ron washed the plate third.","# Declarations
objects = EnumSort([mug, plate, water_glass, juice_glass, fork, knife, spoon])
washed_order = Function([objects] -> [int])
# Constraints
Count([o:objects], True) == 7 ::: Ron washed a total of seven objects
ForAll([o:objects], Exists([o1:objects], washed_order(o) == washed_order(o1))) ::: Ron washed each of the objects exactly once
washed_order(mug) < washed_order(plate) ::: Ron washed the mug before the plate
washed_order(knife) < washed_order(spoon) ::: Ron washed the knife before the spoon
And(Exists([o:objects], And(washed_order(o) < washed_order(water_glass), washed_order(o) < washed_order(juice_glass))), Exists([o:objects], And(washed_order(o) > washed_order(water_glass), washed_order(o) > washed_order(juice_glass)))) ::: Ron washed the glassware after either the china or the utensils but not after both
ForAll([o1:objects, o2:objects], Implies(o1 != o2, washed_order(o1) != washed_order(o2))) ::: He did not wash any two objects at the same time
# Options
is_unsat(washed_order(fork) == 1) ::: (A)
is_unsat(washed_order(fork) == 2) ::: (B)
is_unsat(washed_order(mug) == 1) ::: (C)
is_unsat(washed_order(plate) == 2) ::: (D)
is_unsat(washed_order(plate) == 3) ::: (E)"
"# Context:
During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.

# Question:
If Nikki's fall sport is running, then which one of the following statements must be true?

# Options:
A) Nikki's spring sport is kayaking.
B) Nikki's summer sport is mountaineering.
C) Otto's fall sport is mountaineering.
D) Otto's spring sport is kayaking.
E) Otto's spring sport is running.","# Declarations
seasons = EnumSort([fall, winter, spring, summer])
sports = EnumSort([hockey, kayaking, mountaineering, running, volleyball])
children = EnumSort([Nikki, Otto])
participates = Function([children, seasons] -> [sports])
# Constraints
ForAll([c:children], Count([s:seasons], participates(c, s) == hockey) == 1) ::: Each child participates in exactly one hockey sport during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == kayaking) == 1) ::: Each child participates in exactly one kayaking sport during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == mountaineering) == 1) ::: Each child participates in exactly one mountaineering sport during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == running) == 1) ::: Each child participates in exactly one running sport during the year
ForAll([c:children], Count([s:seasons], participates(c, s) == volleyball) == 1) ::: Each child participates in exactly one volleyball sport during the year
ForAll([c:children], Or(participates(c, fall) == mountaineering, participates(c, fall) == running, participates(c, fall) == volleyball)) ::: In the fall, each child participates in mountaineering, running, or volleyball
ForAll([c:children], Or(participates(c, winter) == hockey, participates(c, winter) == volleyball)) ::: In the winter, each child participates in hockey or volleyball
ForAll([c:children], Or(participates(c, spring) == kayaking, participates(c, spring) == mountaineering, participates(c, spring) == running, participates(c, spring) == volleyball)) ::: In the spring, each child participates in kayaking, mountaineering, running, or volleyball
ForAll([c:children], Or(participates(c, summer) == kayaking, participates(c, summer) == mountaineering, participates(c, summer) == volleyball)) ::: In the summer, each child participates in kayaking, mountaineering, or volleyball
ForAll([s:seasons], participates(Nikki, s) != participates(Otto, s)) ::: Nikki and Otto do not participate in the same sport during the same season
participates(Otto, summer) == volleyball ::: Otto's summer sport is volleyball
participates(Nikki, fall) == running ::: Nikki's fall sport is running
# Options
is_valid(participates(Nikki, spring) == kayaking) ::: (A)
is_valid(participates(Nikki, summer) == mountaineering) ::: (B)
is_valid(participates(Otto, fall) == mountaineering) ::: (C)
is_valid(participates(Otto, spring) == kayaking) ::: (D)
is_valid(participates(Otto, spring) == running) ::: (E)"
"# Context:
An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.

# Question:
If oils and lithography are scheduled for the mornings of day 2 and day 3, respectively, which one of the following CANNOT be scheduled for any day?

# Options:
A) fresco
B) history
C) naturalism
D) pastels
E) sculpture","# Declarations
lectures = EnumSort([fresco, history, lithography, naturalism, oils, pastels, sculpture, watercolors])
days = EnumSort([1, 2, 3])
times = EnumSort([morning, afternoon])
scheduled = Function([lectures] -> [days])
scheduled_time = Function([lectures] -> [times])
# Constraints
ForAll([l:lectures], Exists([d:days, t:times], And(scheduled(l) == d, scheduled_time(l) == t))) ::: There will be exactly two lectures each day—morning and afternoon
Count([l:lectures], scheduled(l) == 2) == 2 ::: Day 2 is the only day for which oils can be scheduled
ForAll([l:lectures], Implies(Or(l == sculpture, l == watercolors), scheduled_time(l) != afternoon)) ::: Neither sculpture nor watercolors can be scheduled for the afternoon
ForAll([l:lectures], Implies(Or(l == oils, l == pastels), scheduled(l) != scheduled(lithography))) ::: Neither oils nor pastels can be scheduled for the same day as lithography
ForAll([d:days], Implies(Or(scheduled(pastels) == d, scheduled(pastels) == d - 1), And(Exists([l:lectures], And(scheduled(l) == d + 1, scheduled_time(l) == morning, l == fresco)), Exists([l:lectures], And(scheduled(l) == d + 1, scheduled_time(l) == morning, l == history))))) ::: If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order
scheduled(oils) == 2 ::: oils and lithography are scheduled for the mornings of day 2 and day 3, respectively
scheduled_time(oils) == morning ::: oils and lithography are scheduled for the mornings of day 2 and day 3, respectively
scheduled(lithography) == 3 ::: oils and lithography are scheduled for the mornings of day 2 and day 3, respectively
scheduled_time(lithography) == morning ::: oils and lithography are scheduled for the mornings of day 2 and day 3, respectively
# Options
is_unsat(Exists([d:days, t:times], And(scheduled(fresco) == d, scheduled_time(fresco) == t))) ::: (A)
is_unsat(Exists([d:days, t:times], And(scheduled(history) == d, scheduled_time(history) == t))) ::: (B)
is_unsat(Exists([d:days, t:times], And(scheduled(naturalism) == d, scheduled_time(naturalism) == t))) ::: (C)
is_unsat(Exists([d:days, t:times], And(scheduled(pastels) == d, scheduled_time(pastels) == t))) ::: (D)
is_unsat(Exists([d:days, t:times], And(scheduled(sculpture) == d, scheduled_time(sculpture) == t))) ::: (E)"
"# Context:
A science student has exactly four flasks—1, 2, 3, and 4—originally containing a red, a blue, a green, and an orange chemical, respectively. An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks. The following conditions apply: The product of an experiment cannot be used in further experiments. Mixing the contents of 1 and 2 produces a red chemical. Mixing the contents of 2 and 3 produces an orange chemical. Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical. Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical.

# Question:
If the student performs exactly two experiments, which one of the following could be the colors of the chemicals in the resulting two nonempty flasks?

# Options:
A) blue, blue
B) blue, orange
C) blue, red
D) green, red
E) orange, orange","# Declarations
flasks = EnumSort([1, 2, 3, 4])
colors = EnumSort([red, blue, green, orange])
initial_color = Function([flasks] -> [colors])
final_color = Function([flasks] -> [colors])
experiment = Function([flasks, flasks] -> [bool])
# Constraints
initial_color(1) == red ::: originally containing a red chemical in flask 1
initial_color(2) == blue ::: originally containing a blue chemical in flask 2
initial_color(3) == green ::: originally containing a green chemical in flask 3
initial_color(4) == orange ::: originally containing an orange chemical in flask 4
ForAll([f1:flasks, f2:flasks], Implies(experiment(f1, f2), And(f1 != f2, Not(Exists([f3:flasks], And(experiment(f1, f3), experiment(f2, f3))))))) ::: The product of an experiment cannot be used in further experiments
Count([f1:flasks, f2:flasks], experiment(f1, f2)) == 2 ::: the student performs exactly two experiments
ForAll([f1:flasks, f2:flasks], Implies(experiment(f1, f2), Or(And(f1 == 1, f2 == 2, final_color(f2) == red), And(f1 == 2, f2 == 1, final_color(f1) == red), And(f1 == 2, f2 == 3, final_color(f2) == orange), And(f1 == 3, f2 == 2, final_color(f1) == orange), And(Or(f1 == 3, f1 == 4), f2 == 1, final_color(f2) == blue), And(f1 == 1, Or(f2 == 3, f2 == 4), final_color(f1) == blue), And(Or(f1 == 4, f1 == 1), f2 == 2, final_color(f2) == green), And(f1 == 2, Or(f2 == 1, f2 == 4), final_color(f1) == green)))) ::: mixing conditions
ForAll([f:flasks], Implies(Not(Exists([f1:flasks, f2:flasks], experiment(f1, f2))), final_color(f) == initial_color(f))) ::: final color of non-experimented flasks remains the same
# Options
is_accurate_list([final_color(1) == blue, final_color(2) == blue]) ::: (A)
is_accurate_list([final_color(1) == blue, final_color(2) == orange]) ::: (B)
is_accurate_list([final_color(1) == blue, final_color(2) == red]) ::: (C)
is_accurate_list([final_color(1) == green, final_color(2) == red]) ::: (D)
is_accurate_list([final_color(1) == orange, final_color(2) == orange]) ::: (E)"
"# Context:
A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.

# Question:
Which one of the following must be true?

# Options:
A) There are at most three technicians.
B) There is exactly one technician.
C) There are at least two managers.
D) There are exactly two managers.
E) There are exactly two employees who supervise no one.","# Declarations
employees = EnumSort([F, G, H, K, L])
positions = EnumSort([president, manager, technician])
holds = Function([employees] -> [positions])
supervises = Function([employees, employees] -> [bool])
# Constraints
Exists([e:employees], holds(e) == president) ::: There is exactly one president
ForAll([e:employees], Implies(holds(e) != president, Exists([s:employees], And(holds(s) != technician, supervises(s, e))))) ::: Other employees are each supervised by exactly one employee, who is either the president or a manager
ForAll([e:employees], ForAll([s:employees], Implies(supervises(s, e), holds(s) != holds(e)))) ::: Each supervised employee holds a different position than his or her supervisor
Exists([e:employees], And(holds(e) == president, Exists([s:employees], And(holds(s) == manager, supervises(e, s))))) ::: At least one of the employees whom the president supervises is a manager
ForAll([e:employees], Implies(holds(e) == manager, Exists([s:employees], supervises(e, s)))) ::: Each manager supervises at least one employee
ForAll([e:employees], Not(Exists([s:employees], supervises(F, s)))) ::: F does not supervise any employee
Count([e:employees], supervises(G, e)) == 2 ::: G supervises exactly two employees
# Options
is_valid(Count([e:employees], holds(e) == technician) <= 3) ::: (A)
is_valid(Count([e:employees], holds(e) == technician) == 1) ::: (B)
is_valid(Count([e:employees], holds(e) == manager) >= 2) ::: (C)
is_valid(Count([e:employees], holds(e) == manager) == 2) ::: (D)
is_valid(Count([e:employees], ForAll([s:employees], Not(supervises(e, s)))) == 2) ::: (E)"
"# Context:
A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.

# Question:
If K supervises exactly two employees, which one of the following must be true?

# Options:
A) F is supervised by K.
B) G is a manager.
C) L is supervised.
D) There are exactly two managers.
E) There are exactly two technicians.","# Declarations
employees = EnumSort([F, G, H, K, L])
positions = EnumSort([president, manager, technician])
holds = Function([employees] -> [positions])
supervises = Function([employees, employees] -> [bool])
# Constraints
Exists([e:employees], holds(e) == president) ::: There is exactly one president
ForAll([e:employees], Implies(holds(e) != president, Exists([s:employees], And(holds(s) != technician, supervises(s, e))))) ::: Other employees are each supervised by exactly one employee, who is either the president or a manager
ForAll([e:employees], ForAll([s:employees], Implies(supervises(s, e), holds(s) != holds(e)))) ::: Each supervised employee holds a different position than his or her supervisor
Exists([e:employees], And(holds(e) == president, Exists([s:employees], And(holds(s) == manager, supervises(e, s))))) ::: At least one of the employees whom the president supervises is a manager
ForAll([e:employees], Implies(holds(e) == manager, Exists([s:employees], supervises(e, s)))) ::: Each manager supervises at least one employee
ForAll([e:employees], Not(supervises(F, e))) ::: F does not supervise any employee
Count([e:employees], supervises(G, e)) == 2 ::: G supervises exactly two employees
Count([e:employees], supervises(K, e)) == 2 ::: K supervises exactly two employees
# Options
is_valid(Exists([s:employees], And(supervises(K, s), s == F))) ::: (A)
is_valid(holds(G) == manager) ::: (B)
is_valid(Exists([s:employees], supervises(s, L))) ::: (C)
is_valid(Count([e:employees], holds(e) == manager) == 2) ::: (D)
is_valid(Count([e:employees], holds(e) == technician) == 2) ::: (E)"
"# Context:
A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.

# Question:
Which one of the following is an acceptable assignment of employees to the positions? President Manager Technician

# Options:
A) G H, K, L F
B) G H F, K, L
C) H F, G K, L
D) H, K G F, L
E) K F, G, H, L","# Declarations
employees = EnumSort([F, G, H, K, L])
positions = EnumSort([president, manager, technician])
supervises = Function([employees, employees] -> [bool])
holds_position = Function([employees] -> [positions])
# Constraints
Exists([e:employees], holds_position(e) == president) ::: There is exactly one president
ForAll([e:employees], Implies(holds_position(e) == president, ForAll([e1:employees], supervises(e, e1) == False))) ::: Only the president is not supervised
ForAll([e:employees], Implies(holds_position(e) != president, Exists([e1:employees], And(supervises(e1, e), holds_position(e1) != technician)))) ::: Other employees are each supervised by exactly one employee, who is either the president or a manager
ForAll([e:employees], Implies(supervises(e, e1), holds_position(e) != holds_position(e1))) ::: Each supervised employee holds a different position than his or her supervisor
Exists([e:employees], And(holds_position(e) == president, Exists([e1:employees], And(supervises(e, e1), holds_position(e1) == manager)))) ::: At least one of the employees whom the president supervises is a manager
ForAll([e:employees], Implies(holds_position(e) == manager, Exists([e1:employees], supervises(e, e1)))) ::: Each manager supervises at least one employee
ForAll([e:employees], supervises(F, e) == False) ::: F does not supervise any employee
Count([e:employees], supervises(G, e)) == 2 ::: G supervises exactly two employees
# Options
is_valid(And(holds_position(G) == president, holds_position(H) == manager, holds_position(K) == manager, holds_position(L) == manager, holds_position(F) == technician)) ::: (A)
is_valid(And(holds_position(G) == president, holds_position(H) == manager, holds_position(F) == manager, holds_position(K) == manager, holds_position(L) == technician)) ::: (B)
is_valid(And(holds_position(H) == president, holds_position(F) == manager, holds_position(G) == manager, holds_position(K) == technician, holds_position(L) == technician)) ::: (C)
is_valid(And(holds_position(H) == president, holds_position(K) == president, holds_position(G) == manager, holds_position(F) == technician, holds_position(L) == technician)) ::: (D)
is_valid(And(holds_position(K) == president, holds_position(F) == manager, holds_position(G) == manager, holds_position(H) == manager, holds_position(L) == technician)) ::: (E)"
"# Context:
A science student has exactly four flasks—1, 2, 3, and 4—originally containing a red, a blue, a green, and an orange chemical, respectively. An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks. The following conditions apply: The product of an experiment cannot be used in further experiments. Mixing the contents of 1 and 2 produces a red chemical. Mixing the contents of 2 and 3 produces an orange chemical. Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical. Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical.

# Question:
If the student performs exactly one experiment and none of the resulting three nonempty flasks contains an orange chemical, then the student must have mixed the contents of

# Options:
A) flask 1 with flask 2
B) flask 1 with flask 4
C) flask 2 with flask 4
D) flask 2 with one of the other flasks
E) flask 4 with one of the other flasks","# Declarations
flasks = EnumSort([1, 2, 3, 4])
chemicals = EnumSort([red, blue, green, orange])
original_contents = Function([flasks] -> [chemicals])
mixed_contents = Function([flasks, flasks] -> [chemicals])
# Constraints
original_contents(1) == red ::: originally containing a red chemical in flask 1
original_contents(2) == blue ::: originally containing a blue chemical in flask 2
original_contents(3) == green ::: originally containing a green chemical in flask 3
original_contents(4) == orange ::: originally containing an orange chemical in flask 4
mixed_contents(1, 2) == red ::: Mixing the contents of 1 and 2 produces a red chemical
mixed_contents(2, 3) == orange ::: Mixing the contents of 2 and 3 produces an orange chemical
Or(mixed_contents(3, 1) == blue, mixed_contents(3, 4) == blue) ::: Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical
Or(mixed_contents(4, 1) == green, mixed_contents(4, 2) == green) ::: Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical
ForAll([f1:flasks, f2:flasks], Implies(f1 != f2, mixed_contents(f1, f2) != orange)) ::: none of the resulting three nonempty flasks contains an orange chemical
# Options
is_valid(mixed_contents(1, 2) == red) ::: (A)
is_valid(mixed_contents(1, 4) == green) ::: (B)
is_valid(mixed_contents(2, 4) == green) ::: (C)
is_valid(Or(mixed_contents(2, 1) == red, mixed_contents(2, 3) == orange)) ::: (D)
is_valid(Or(mixed_contents(4, 1) == green, mixed_contents(4, 2) == green)) ::: (E)"
"# Context:
The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.

# Question:
Which one of the following is a complete and accurate list of those planes any one of which could be within area T at noon?

# Options:
A) M
B) J, L
C) J, L, M
D) K, L, M
E) J, K, L, M","# Declarations
areas = EnumSort([R, S, T, U])
planes = EnumSort([J, K, L, M])
in_area = Function([planes] -> [areas])
# Constraints
ForAll([p:planes], Exists([a:areas], in_area(p) == a)) ::: Each plane is in at least one of the four areas
in_area(J) == S ::: J is in area S
ForAll([a:areas], Implies(in_area(J) == a, in_area(K) != a)) ::: K is not in any detection area that J is in
ForAll([a:areas], Implies(in_area(L) == a, in_area(M) != a)) ::: L is not in any detection area that M is in
Count([a:areas], in_area(M) == a) == 1 ::: M is in exactly one of the areas
# Options
is_accurate_list([in_area(M) == T]) ::: (A)
is_accurate_list([in_area(J) == T, in_area(L) == T]) ::: (B)
is_accurate_list([in_area(J) == T, in_area(L) == T, in_area(M) == T]) ::: (C)
is_accurate_list([in_area(K) == T, in_area(L) == T, in_area(M) == T]) ::: (D)
is_accurate_list([in_area(J) == T, in_area(K) == T, in_area(L) == T, in_area(M) == T]) ::: (E)"
"# Context:
A science student has exactly four flasks—1, 2, 3, and 4—originally containing a red, a blue, a green, and an orange chemical, respectively. An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks. The following conditions apply: The product of an experiment cannot be used in further experiments. Mixing the contents of 1 and 2 produces a red chemical. Mixing the contents of 2 and 3 produces an orange chemical. Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical. Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical.

# Question:
If the student performs exactly two experiments and exactly one of the resulting two nonempty flasks contains an orange chemical, then it must be true that the contents of the other nonempty flask is

# Options:
A) obtained by mixing flasks 1 and 2
B) obtained by mixing flasks 2 and 4
C) blue
D) green
E) red","# Declarations
flasks = EnumSort([1, 2, 3, 4])
colors = EnumSort([red, blue, green, orange])
initial_contents = Function([flasks] -> [colors])
experiment = Function([flasks, flasks] -> [bool])
resulting_contents = Function([flasks] -> [colors])
# Constraints
initial_contents(1) == red ::: originally containing a red chemical in flask 1
initial_contents(2) == blue ::: originally containing a blue chemical in flask 2
initial_contents(3) == green ::: originally containing a green chemical in flask 3
initial_contents(4) == orange ::: originally containing an orange chemical in flask 4
ForAll([f1:flasks, f2:flasks], Implies(experiment(f1, f2), And(f1 != f2, Not(experiment(f2, f1))))) ::: An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks
ForAll([f1:flasks, f2:flasks], Implies(experiment(f1, f2), resulting_contents(f2) != initial_contents(f2))) ::: The product of an experiment cannot be used in further experiments
resulting_contents(2) == red ::: Mixing the contents of 1 and 2 produces a red chemical
resulting_contents(3) == orange ::: Mixing the contents of 2 and 3 produces an orange chemical
Or(resulting_contents(1) == blue, resulting_contents(4) == blue) ::: Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical
Or(resulting_contents(1) == green, resulting_contents(2) == green) ::: Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical
Count([f1:flasks, f2:flasks], experiment(f1, f2)) == 2 ::: the student performs exactly two experiments
Count([f:flasks], resulting_contents(f) == orange) == 1 ::: exactly one of the resulting two nonempty flasks contains an orange chemical
# Options
is_valid(Exists([f1:flasks, f2:flasks], And(experiment(f1, f2), resulting_contents(f2) == red))) ::: (A) obtained by mixing flasks 1 and 2
is_valid(Exists([f1:flasks, f2:flasks], And(experiment(f1, f2), resulting_contents(f2) == green))) ::: (B) obtained by mixing flasks 2 and 4
is_valid(Exists([f:flasks], resulting_contents(f) == blue)) ::: (C) blue
is_valid(Exists([f:flasks], resulting_contents(f) == green)) ::: (D) green
is_valid(Exists([f:flasks], resulting_contents(f) == red)) ::: (E) red"
"# Context:
The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.

# Question:
If, in a particular cycle, N, O, and T participate in the first year and if O and P participate in the fourth year, any of the following could be a clan that participates in the third year EXCEPT

# Options:
A) N
B) O
C) P
D) S
E) T","# Declarations
clans = EnumSort([N, O, P, S, T])
years = EnumSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
participates = Function([clans, years] -> [bool])
# Constraints
ForAll([y:years], Count([c:clans], participates(c, y)) == 3) ::: Each year exactly three of the five clans participate in the annual harvest ceremonies
ForAll([c:clans], ForAll([y:years], Implies(And(y <= 13, participates(c, y), participates(c, y+1)), participates(c, y+2)))) ::: Each clan must participate at least once in any two consecutive years
ForAll([c:clans], ForAll([y:years], Implies(And(y <= 12, participates(c, y), participates(c, y+1), participates(c, y+2)), False))) ::: No clan participates for three consecutive years
ForAll([c:clans], Count([y:years], participates(c, y)) <= 3) ::: No clan participates more than three times within any cycle
participates(N, 1) ::: N participates in the first year
participates(O, 1) ::: O participates in the first year
participates(T, 1) ::: T participates in the first year
participates(O, 4) ::: O participates in the fourth year
participates(P, 4) ::: P participates in the fourth year
# Options
is_unsat(participates(N, 3)) ::: (A)
is_unsat(participates(O, 3)) ::: (B)
is_unsat(participates(P, 3)) ::: (C)
is_unsat(participates(S, 3)) ::: (D)
is_unsat(participates(T, 3)) ::: (E)"
"# Context:
Ron washed a total of seven objects after eating his lunch. Two of the objects were pieces of china: a mug and a plate. Two were pieces of glassware: a water glass and a juice glass. Three were utensils: a fork, a knife, and a spoon. Ron washed the two pieces of china consecutively, the two glasses consecutively, and the three utensils consecutively. He washed the objects as follows: Ron washed each of the objects exactly once. Ron washed the glassware after either the china or the utensils but not after both. He washed the knife before the spoon, and he washed the mug before the plate. He did not wash any two objects at the same time.

# Question:
Which one of the following CANNOT be an accurate list of the objects Ron washed second, third, and fourth, respectively?

# Options:
A) fork, spoon, water glass
B) knife, fork, juice glass
C) knife, spoon, juice glass
D) knife, spoon, water glass
E) plate, water glass, juice glass","# Declarations
objects = EnumSort([mug, plate, water_glass, juice_glass, fork, knife, spoon])
washed_order = Function([objects] -> [int])
# Constraints
Count([o:objects], True) == 7 ::: Ron washed a total of seven objects
ForAll([o:objects], Exists([o1:objects], washed_order(o) == washed_order(o1))) ::: Ron washed each of the objects exactly once
And(washed_order(mug) + 1 == washed_order(plate), washed_order(water_glass) + 1 == washed_order(juice_glass), washed_order(fork) + 1 == washed_order(knife), washed_order(knife) + 1 == washed_order(spoon)) ::: Ron washed the two pieces of china consecutively, the two glasses consecutively, and the three utensils consecutively
Or(washed_order(water_glass) > washed_order(mug), washed_order(water_glass) > washed_order(spoon)) ::: Ron washed the glassware after either the china or the utensils but not after both
washed_order(knife) < washed_order(spoon) ::: Ron washed the knife before the spoon
washed_order(mug) < washed_order(plate) ::: Ron washed the mug before the plate
# Options
is_unsat(And(washed_order(fork) == 2, washed_order(spoon) == 3, washed_order(water_glass) == 4)) ::: (A)
is_unsat(And(washed_order(knife) == 2, washed_order(fork) == 3, washed_order(juice_glass) == 4)) ::: (B)
is_unsat(And(washed_order(knife) == 2, washed_order(spoon) == 3, washed_order(juice_glass) == 4)) ::: (C)
is_unsat(And(washed_order(knife) == 2, washed_order(spoon) == 3, washed_order(water_glass) == 4)) ::: (D)
is_unsat(And(washed_order(plate) == 2, washed_order(water_glass) == 3, washed_order(juice_glass) == 4)) ::: (E)"
"# Context:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.

# Question:
If L and M are in group 2, then a person who could be assigned either to group 1 or, alternatively, to group 2 is

# Options:
A) F
B) G
C) H
D) J
E) K","# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group1, group2])
assigned = Function([consumers] -> [groups])
# Constraints
ForAll([c:consumers], Exists([g:groups], assigned(c) == g)) ::: Each person is assigned to exactly one of the two groups
Count([c:consumers], assigned(c) == group1) == 4 ::: There are exactly two 4-person groups
Count([c:consumers], assigned(c) == group2) == 4 ::: There are exactly two 4-person groups
assigned(F) == assigned(J) ::: F must be in the same group as J
assigned(G) != assigned(M) ::: G must be in a different group from M
Implies(assigned(H) == group1, assigned(L) == group1) ::: If H is in group 1, then L must be in group 1
Implies(assigned(N) == group2, assigned(G) == group1) ::: If N is in group 2, then G must be in group 1
assigned(L) == group2 ::: L is in group 2
assigned(M) == group2 ::: M is in group 2
# Options
is_valid(Or(assigned(F) == group1, assigned(F) == group2)) ::: (A)
is_valid(Or(assigned(G) == group1, assigned(G) == group2)) ::: (B)
is_valid(Or(assigned(H) == group1, assigned(H) == group2)) ::: (C)
is_valid(Or(assigned(J) == group1, assigned(J) == group2)) ::: (D)
is_valid(Or(assigned(K) == group1, assigned(K) == group2)) ::: (E)"
"# Context:
An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.

# Question:
If the lectures scheduled for the mornings are fresco, history, and lithography, not necessarily in that order, which one of the following could be true?

# Options:
A) Lithography is scheduled for day 3.
B) Naturalism is scheduled for day 2.
C) Fresco is scheduled for the same day as naturalism.
D) History is scheduled for the same day as naturalism.
E) History is scheduled for the same day as oils.","# Declarations
lectures = EnumSort([fresco, history, lithography, naturalism, oils, pastels, sculpture, watercolors])
days = EnumSort([1, 2, 3])
times = EnumSort([morning, afternoon])
scheduled = Function([lectures, times] -> [days])
# Constraints
ForAll([d:days], And(Exists([l:lectures, t:times], scheduled(l, t) == d), Count([l:lectures, t:times], scheduled(l, t) == d) == 2)) ::: There will be exactly two lectures each day—morning and afternoon
scheduled(oils, morning) == 2 ::: Day 2 is the only day for which oils can be scheduled
ForAll([d:days], Or(scheduled(sculpture, afternoon) != d, scheduled(watercolors, afternoon) != d)) ::: Neither sculpture nor watercolors can be scheduled for the afternoon
ForAll([d:days], Or(scheduled(oils, morning) != d, scheduled(pastels, morning) != d, scheduled(lithography, morning) != d)) ::: Neither oils nor pastels can be scheduled for the same day as lithography
Implies(Or(scheduled(pastels, morning) == 1, scheduled(pastels, morning) == 2), And(Exists([l:lectures], And(scheduled(l, morning) == scheduled(pastels, morning) + 1, Or(l == fresco, l == history))), Exists([l:lectures], And(scheduled(l, afternoon) == scheduled(pastels, morning) + 1, Or(l == fresco, l == history))))) ::: If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order
Exists([d:days], And(scheduled(fresco, morning) == d, scheduled(history, morning) == d, scheduled(lithography, morning) == d)) ::: The lectures scheduled for the mornings are fresco, history, and lithography, not necessarily in that order
# Options
is_valid(scheduled(lithography, morning) == 3) ::: (A)
is_valid(scheduled(naturalism, morning) == 2) ::: (B)
is_valid(scheduled(fresco, morning) == scheduled(naturalism, morning)) ::: (C)
is_valid(scheduled(history, morning) == scheduled(naturalism, morning)) ::: (D)
is_valid(scheduled(history, morning) == scheduled(oils, morning)) ::: (E)"
"# Context:
An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.

# Question:
If lithography and history are scheduled for the mornings of day 2 and day 3, respectively, which one of the following lectures could be scheduled for the morning of day 1?

# Options:
A) fresco
B) naturalism
C) oils
D) pastels
E) sculpture","# Declarations
lectures = EnumSort([fresco, history, lithography, naturalism, oils, pastels, sculpture, watercolors])
days = EnumSort([1, 2, 3])
times = EnumSort([morning, afternoon])
scheduled = Function([lectures, times] -> [days])
# Constraints
ForAll([d:days], And(Exists([l:lectures, t:times], scheduled(l, t) == d), Count([l:lectures, t:times], scheduled(l, t) == d) == 2)) ::: There will be exactly two lectures each day—morning and afternoon
scheduled(oils, morning) == 2 ::: Day 2 is the only day for which oils can be scheduled
ForAll([d:days], Or(scheduled(sculpture, afternoon) != d, scheduled(watercolors, afternoon) != d)) ::: Neither sculpture nor watercolors can be scheduled for the afternoon
ForAll([d:days], Or(scheduled(oils, morning) != d, scheduled(pastels, morning) != d, scheduled(lithography, morning) != d)) ::: Neither oils nor pastels can be scheduled for the same day as lithography
Implies(Or(scheduled(pastels, morning) == 1, scheduled(pastels, morning) == 2), And(Exists([l:lectures], And(scheduled(l, morning) == scheduled(pastels, morning) + 1, Or(l == fresco, l == history))), Exists([l:lectures], And(scheduled(l, morning) == scheduled(pastels, morning) + 1, Or(l == fresco, l == history))))) ::: If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order
scheduled(lithography, morning) == 2 ::: lithography and history are scheduled for the mornings of day 2 and day 3, respectively
scheduled(history, morning) == 3 ::: lithography and history are scheduled for the mornings of day 2 and day 3, respectively
# Options
is_valid(scheduled(fresco, morning) == 1) ::: (A)
is_valid(scheduled(naturalism, morning) == 1) ::: (B)
is_valid(scheduled(oils, morning) == 1) ::: (C)
is_valid(scheduled(pastels, morning) == 1) ::: (D)
is_valid(scheduled(sculpture, morning) == 1) ::: (E)"
"# Context:
An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.

# Question:
If lithography and fresco are scheduled for the afternoons of day 2 and day 3, respectively, which one of the following is a lecture that could be scheduled for the afternoon of day 1?

# Options:
A) history
B) oils
C) pastels
D) sculpture
E) watercolors","# Declarations
lectures = EnumSort([fresco, history, lithography, naturalism, oils, pastels, sculpture, watercolors])
days = EnumSort([1, 2, 3])
times = EnumSort([morning, afternoon])
scheduled = Function([lectures] -> [days])
time_slot = Function([lectures] -> [times])
# Constraints
ForAll([l:lectures], Exists([d:days], scheduled(l) == d)) ::: Each lecture is scheduled for exactly one day
ForAll([d:days], Count([l:lectures], scheduled(l) == d) == 2) ::: There will be exactly two lectures each day
scheduled(oils) == 2 ::: Day 2 is the only day for which oils can be scheduled
ForAll([l:lectures], Implies(time_slot(l) == afternoon, And(l != sculpture, l != watercolors))) ::: Neither sculpture nor watercolors can be scheduled for the afternoon
ForAll([l:lectures], Implies(scheduled(lithography) == scheduled(l), And(l != oils, l != pastels))) ::: Neither oils nor pastels can be scheduled for the same day as lithography
ForAll([d:days], Implies(Or(scheduled(pastels) == d, scheduled(pastels) == d - 1), And(Exists([l:lectures], And(scheduled(l) == d + 1, time_slot(l) == morning, Or(l == fresco, l == history))), Exists([l:lectures], And(scheduled(l) == d + 1, time_slot(l) == morning, Or(l == fresco, l == history)))))) ::: If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order
scheduled(lithography) == 2 ::: lithography is scheduled for the afternoon of day 2
time_slot(lithography) == afternoon ::: lithography is scheduled for the afternoon of day 2
scheduled(fresco) == 3 ::: fresco is scheduled for the afternoon of day 3
time_slot(fresco) == afternoon ::: fresco is scheduled for the afternoon of day 3
# Options
is_valid(And(scheduled(history) == 1, time_slot(history) == afternoon)) ::: (A)
is_valid(And(scheduled(oils) == 1, time_slot(oils) == afternoon)) ::: (B)
is_valid(And(scheduled(pastels) == 1, time_slot(pastels) == afternoon)) ::: (C)
is_valid(And(scheduled(sculpture) == 1, time_slot(sculpture) == afternoon)) ::: (D)
is_valid(And(scheduled(watercolors) == 1, time_slot(watercolors) == afternoon)) ::: (E)"
"# Context:
Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.

# Question:
If Lara and Mendel buy exactly two kinds of food each, which one of the following statements must be true.

# Options:
A) Lara buys a fruit cup.
B) Lara buys a hot dog.
C) Mendel buys a fruit cup.
D) There is exactly one kind of food that Lara and Mendel both buy.
E) There is exactly one kind of food that Lara and Nastassia both buy.","# Declarations
people = EnumSort([Lara, Mendel, Nastassia])
foods = EnumSort([fruit_cups, hot_dogs, pretzels, shish_kebabs])
buys = Function([people, foods] -> [bool])
# Constraints
ForAll([p:people], Exists([f:foods], buys(p, f))) ::: Each person buys at least one kind of food
ForAll([p:people, f:foods], Not(And(buys(p, f), buys(p, f)))) ::: None of the three buys more than one portion of each kind of food
ForAll([p:people], Implies(buys(p, hot_dogs), Not(buys(p, shish_kebabs)))) ::: If any of the three buys a hot dog, that person does not also buy a shish kebab
Exists([p:people], buys(p, hot_dogs)) ::: At least one of the three buys a hot dog
Exists([p:people], buys(p, pretzels)) ::: At least one of the three buys a pretzel
buys(Mendel, shish_kebabs) ::: Mendel buys a shish kebab
buys(Nastassia, fruit_cups) ::: Nastassia buys a fruit cup
ForAll([f:foods], Not(And(buys(Lara, f), buys(Nastassia, f)))) ::: Neither Lara nor Nastassia buys a pretzel
ForAll([f:foods], Not(And(buys(Mendel, f), buys(Nastassia, f)))) ::: Mendel does not buy any kind of food that Nastassia buys
Count([f:foods], buys(Lara, f)) == 2 ::: Lara buys exactly two kinds of food
Count([f:foods], buys(Mendel, f)) == 2 ::: Mendel buys exactly two kinds of food
# Options
is_valid(buys(Lara, fruit_cups)) ::: (A)
is_valid(buys(Lara, hot_dogs)) ::: (B)
is_valid(buys(Mendel, fruit_cups)) ::: (C)
is_valid(Count([f:foods], And(buys(Lara, f), buys(Mendel, f))) == 1) ::: (D)
is_valid(Count([f:foods], And(buys(Lara, f), buys(Nastassia, f))) == 1) ::: (E)"
"# Context:
Six cities are located within the numbered areas as follows: Within the six-city area there are exactly four hospitals, two jails, and two universities. These eight institutions are located as follows: No institution is in more than one of the cities. None of the cities contains more than one jail, and none contains more than one university. None of the cities contains both a jail and a university. Each jail is located in a city that contains at least one hospital. The universities are located in two cities that do not share a common boundary. City 3 contains a university, and city 6 contains a jail.

# Question:
Which one of the following could be true?

# Options:
A) City 1 contains exactly one hospital.
B) City 1 contains exactly one university.
C) City 2 contains exactly one jail.
D) City 5 contains exactly one university.
E) City 6 contains exactly one university.","# Declarations
cities = EnumSort([City1, City2, City3, City4, City5, City6])
institutions = EnumSort([Hospital1, Hospital2, Hospital3, Hospital4, Jail1, Jail2, University1, University2])
located_in = Function([institutions] -> [cities])
# Constraints
Count([i:institutions], located_in(i) == City1) <= 1 ::: No city contains more than one institution
Count([i:institutions], located_in(i) == City2) <= 1 ::: No city contains more than one institution
Count([i:institutions], located_in(i) == City3) <= 1 ::: No city contains more than one institution
Count([i:institutions], located_in(i) == City4) <= 1 ::: No city contains more than one institution
Count([i:institutions], located_in(i) == City5) <= 1 ::: No city contains more than one institution
Count([i:institutions], located_in(i) == City6) <= 1 ::: No city contains more than one institution
Count([i:institutions], located_in(i) == City1) >= 1 ::: Each city contains at least one institution
Count([i:institutions], located_in(i) == City2) >= 1 ::: Each city contains at least one institution
Count([i:institutions], located_in(i) == City3) >= 1 ::: Each city contains at least one institution
Count([i:institutions], located_in(i) == City4) >= 1 ::: Each city contains at least one institution
Count([i:institutions], located_in(i) == City5) >= 1 ::: Each city contains at least one institution
Count([i:institutions], located_in(i) == City6) >= 1 ::: Each city contains at least one institution
Count([i:institutions], located_in(i) == City1) != 2 ::: No city contains both a jail and a university
Count([i:institutions], located_in(i) == City2) != 2 ::: No city contains both a jail and a university
Count([i:institutions], located_in(i) == City3) != 2 ::: No city contains both a jail and a university
Count([i:institutions], located_in(i) == City4) != 2 ::: No city contains both a jail and a university
Count([i:institutions], located_in(i) == City5) != 2 ::: No city contains both a jail and a university
Count([i:institutions], located_in(i) == City6) != 2 ::: No city contains both a jail and a university
located_in(Jail1) == City6 ::: City 6 contains a jail
located_in(University1) == City3 ::: City 3 contains a university
ForAll([j:institutions], Implies(located_in(j) == City6, Exists([h:institutions], And(located_in(h) == City6, h != j)))) ::: Each jail is located in a city that contains at least one hospital
ForAll([u:institutions], Implies(located_in(u) == City3, ForAll([c:cities], Implies(c != City3, Not(located_in(u) == c))))) ::: The universities are located in two cities that do not share a common boundary
# Options
is_sat(Count([h:institutions], located_in(h) == City1) == 1) ::: (A)
is_sat(Count([u:institutions], located_in(u) == City1) == 1) ::: (B)
is_sat(Count([j:institutions], located_in(j) == City2) == 1) ::: (C)
is_sat(Count([u:institutions], located_in(u) == City5) == 1) ::: (D)
is_sat(Count([u:institutions], located_in(u) == City6) == 1) ::: (E)"
"# Context:
A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.

# Question:
Suppose that it is no longer part of the specifications that two lights on the north side be on. If all of the other original specifications remain the same, and if exactly one light on the north side is on, which one of the following statements could be false?

# Options:
A) Light 1 is off.
B) Light 2 is on.
C) Light 3 is off.
D) Light 4 is on.
E) Light 5 is on.","# Declarations
lights = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
is_on = Function([lights] -> [bool])
# Constraints
ForAll([i:lights], Implies(And(i >= 1, i <= 6), Not(And(is_on(i), is_on(i+1), is_on(i+2))))) ::: At least one of any three consecutively numbered lights is off
is_on(8) ::: Light 8 is on
Implies(is_on(1), And(Not(is_on(2)), Not(is_on(7)))) ::: Neither light 2 nor light 7 is on when light 1 is on
Or(is_on(1), is_on(2), is_on(3)) ::: At least one of the three lights on each side is on
Or(is_on(3), is_on(4), is_on(5)) ::: At least one of the three lights on each side is on
Or(is_on(5), is_on(6), is_on(7)) ::: At least one of the three lights on each side is on
Or(is_on(7), is_on(8), is_on(1)) ::: At least one of the three lights on each side is on
Implies(Count([i:lights], And(i >= 1, i <= 3, is_on(i))) == 1, is_on(2)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(Count([i:lights], And(i >= 3, i <= 5, is_on(i))) == 1, is_on(4)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(Count([i:lights], And(i >= 5, i <= 7, is_on(i))) == 1, is_on(6)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(Count([i:lights], And(i >= 7, i <= 8, Or(i == 1, is_on(i)))) == 1, is_on(8)) ::: If any side has exactly one of its three lights on, then that light is its center light
Count([i:lights], And(i >= 1, i <= 3, is_on(i))) == 1 ::: Exactly one light on the north side is on
# Options
is_unsat(Not(is_on(1))) ::: (A)
is_unsat(is_on(2)) ::: (B)
is_unsat(Not(is_on(3))) ::: (C)
is_unsat(is_on(4)) ::: (D)
is_unsat(is_on(5)) ::: (E)"
"# Context:
Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.

# Question:
Which one of the following is a pair of counselors who could together be assigned to supervise tennis?

# Options:
A) Fran and Kathy
B) George and Nathan
C) Henry and Lewis
D) Joan and Nathan
E) Joan and Olga","# Declarations
counselors = EnumSort([Fran, George, Henry, Joan, Kathy, Lewis, Nathan, Olga])
activities = EnumSort([swimming, tennis, volleyball])
assigned = Function([counselors] -> [activities])
# Constraints
ForAll([a:activities], And(Count([c:counselors], assigned(c) == a) >= 2, Count([c:counselors], assigned(c) == a) <= 3)) ::: Each activity is supervised by at least two, but not more than three, of the eight counselors
assigned(Henry) == swimming ::: Henry supervises swimming
ForAll([c:counselors], Or(assigned(Kathy) != tennis, assigned(Olga) != tennis)) ::: Neither Kathy nor Olga supervises tennis
ForAll([c:counselors], Or(assigned(Kathy) != assigned(Joan), assigned(Nathan) != assigned(Joan))) ::: Neither Kathy nor Nathan supervises the same activity as Joan
Implies(assigned(George) == swimming, And(assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: If George supervises swimming, both Nathan and Olga supervise volleyball
# Options
is_valid(And(assigned(Fran) == tennis, assigned(Kathy) == tennis)) ::: (A)
is_valid(And(assigned(George) == tennis, assigned(Nathan) == tennis)) ::: (B)
is_valid(And(assigned(Henry) == tennis, assigned(Lewis) == tennis)) ::: (C)
is_valid(And(assigned(Joan) == tennis, assigned(Nathan) == tennis)) ::: (D)
is_valid(And(assigned(Joan) == tennis, assigned(Olga) == tennis)) ::: (E)"
"# Context:
Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.

# Question:
Which one of the following could be true after only one reassignment during the year?

# Options:
A) Louis is assigned to project T.
B) Nora is assigned to project R.
C) Oliver is assigned to project Q.
D) Louis and Nora each remain assigned to the same projects as before.
E) Nora and Oliver each remain assigned to the same projects as before.","# Declarations
apprentices = EnumSort([Louis, Madelyn, Nora, Oliver])
projects = EnumSort([Q, R, S, T])
assigned = Function([apprentices] -> [projects])
# Constraints
assigned(Louis) == Q ::: Louis is initially assigned to project Q
assigned(Madelyn) == R ::: Madelyn is initially assigned to project R
assigned(Nora) == S ::: Nora is initially assigned to project S
assigned(Oliver) == T ::: Oliver is initially assigned to project T
# Options
is_valid(assigned(Louis) == T) ::: (A)
is_valid(assigned(Nora) == R) ::: (B)
is_valid(assigned(Oliver) == Q) ::: (C)
is_valid(And(assigned(Louis) == Q, assigned(Nora) == S)) ::: (D)
is_valid(And(assigned(Nora) == S, assigned(Oliver) == T)) ::: (E)"
"# Context:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.

# Question:
Which one of the following could be the four people selected to attend the retirement dinner?

# Options:
A) J, K, M, P
B) J, L, N, Q
C) J, M, N, Q
D) K, M, P, Q
E) L, M, N, P","# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])
# Constraints
Count([p:people], selected(p)) == 4 ::: exactly four people will be selected
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected
# Options
is_sat(And(selected(J), selected(K), selected(M), selected(P))) ::: (A)
is_sat(And(selected(J), selected(L), selected(N), selected(Q))) ::: (B)
is_sat(And(selected(J), selected(M), selected(N), selected(Q))) ::: (C)
is_sat(And(selected(K), selected(M), selected(P), selected(Q))) ::: (D)
is_sat(And(selected(L), selected(M), selected(N), selected(P))) ::: (E)"
"# Context:
Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.

# Question:
Which one of the following is an acceptable assignment of the counselors to the activities?

# Options:
A) Swimming: Fran, George, Henry; Tennis: Joan, Lewis; Volleyball: Kathy, Nathan, Olga
B) Swimming: George, Henry, Olga; Tennis: Fran, Joan, Lewis; Volleyball: Kathy, Nathan
C) Swimming: Henry; Tennis: Fran, George, Joan, Lewis; Volleyball: Kathy, Nathan, Olga
D) Swimming: Henry, Joan, Kathy; Tennis: George, Nathan; Volleyball: Fran, Lewis, Olga
E) Swimming: Henry, Nathan; Tennis: Fran, Kathy, Lewis; Volleyball: George, Joan, Olga","# Declarations
counselors = EnumSort([Fran, George, Henry, Joan, Kathy, Lewis, Nathan, Olga])
activities = EnumSort([swimming, tennis, volleyball])
assigned = Function([counselors] -> [activities])
# Constraints
ForAll([a:activities], And(Count([c:counselors], assigned(c) == a) >= 2, Count([c:counselors], assigned(c) == a) <= 3)) ::: Each activity is supervised by at least two, but not more than three, of the eight counselors
assigned(Henry) == swimming ::: Henry supervises swimming
And(assigned(Kathy) != tennis, assigned(Olga) != tennis) ::: Neither Kathy nor Olga supervises tennis
And(assigned(Kathy) != assigned(Joan), assigned(Nathan) != assigned(Joan)) ::: Neither Kathy nor Nathan supervises the same activity as Joan
Implies(assigned(George) == swimming, And(assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: If George supervises swimming, both Nathan and Olga supervise volleyball
# Options
is_sat(And(assigned(Fran) == swimming, assigned(George) == swimming, assigned(Henry) == swimming, assigned(Joan) == tennis, assigned(Lewis) == tennis, assigned(Kathy) == volleyball, assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: (A)
is_sat(And(assigned(George) == swimming, assigned(Henry) == swimming, assigned(Olga) == swimming, assigned(Fran) == tennis, assigned(Joan) == tennis, assigned(Lewis) == tennis, assigned(Kathy) == volleyball, assigned(Nathan) == volleyball)) ::: (B)
is_sat(And(assigned(Henry) == swimming, assigned(Fran) == tennis, assigned(George) == tennis, assigned(Joan) == tennis, assigned(Lewis) == tennis, assigned(Kathy) == volleyball, assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: (C)
is_sat(And(assigned(Henry) == swimming, assigned(Joan) == swimming, assigned(Kathy) == swimming, assigned(George) == tennis, assigned(Nathan) == tennis, assigned(Fran) == volleyball, assigned(Lewis) == volleyball, assigned(Olga) == volleyball)) ::: (D)
is_sat(And(assigned(Henry) == swimming, assigned(Nathan) == swimming, assigned(Fran) == tennis, assigned(Kathy) == tennis, assigned(Lewis) == tennis, assigned(George) == volleyball, assigned(Joan) == volleyball, assigned(Olga) == volleyball)) ::: (E)"
"# Context:
Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.

# Question:
If Joan is assigned to supervise the same activity as Olga, which one of the following CANNOT be true of the assignment?

# Options:
A) Fran supervises swimming.
B) George supervises swimming.
C) Kathy supervises volleyball.
D) Lewis supervises volleyball.
E) Nathan supervises tennis.","# Declarations
counselors = EnumSort([Fran, George, Henry, Joan, Kathy, Lewis, Nathan, Olga])
activities = EnumSort([swimming, tennis, volleyball])
assigned = Function([counselors] -> [activities])
# Constraints
ForAll([a:activities], And(Count([c:counselors], assigned(c) == a) >= 2, Count([c:counselors], assigned(c) == a) <= 3)) ::: Each activity is supervised by at least two, but not more than three, of the eight counselors
assigned(Henry) == swimming ::: Henry supervises swimming
assigned(Kathy) != tennis ::: Neither Kathy nor Olga supervises tennis
assigned(Olga) != tennis ::: Neither Kathy nor Olga supervises tennis
assigned(Kathy) != assigned(Joan) ::: Neither Kathy nor Nathan supervises the same activity as Joan
assigned(Nathan) != assigned(Joan) ::: Neither Kathy nor Nathan supervises the same activity as Joan
Implies(assigned(George) == swimming, And(assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: If George supervises swimming, both Nathan and Olga supervise volleyball
assigned(Joan) == assigned(Olga) ::: Joan is assigned to supervise the same activity as Olga
# Options
is_unsat(assigned(Fran) == swimming) ::: (A)
is_unsat(assigned(George) == swimming) ::: (B)
is_unsat(assigned(Kathy) == volleyball) ::: (C)
is_unsat(assigned(Lewis) == volleyball) ::: (D)
is_unsat(assigned(Nathan) == tennis) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
Which one of the following could be true?

# Options:
A) Exactly one of the organisms responds to ferromycin.
B) All four of the organisms respond to heptocillin.
C) At least one of the organisms responds both to ferromycin and to heptocillin.
D) At least one of the organisms responds neither to ganocyclene nor to heptocillin.
E) At least one of the organisms responds to ganocyclene but does not respond to ferromycin.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: At least two but not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
# Options
is_sat(Count([o:organisms], responds(o, ferromycin)) == 1) ::: (A)
is_sat(ForAll([o:organisms], responds(o, heptocillin))) ::: (B)
is_sat(Exists([o:organisms], And(responds(o, ferromycin), responds(o, heptocillin)))) ::: (C)
is_sat(Exists([o:organisms], And(Not(responds(o, ganocyclene)), Not(responds(o, heptocillin))))) ::: (D)
is_sat(Exists([o:organisms], And(responds(o, ganocyclene), Not(responds(o, ferromycin))))) ::: (E)"
"# Context:
On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.

# Question:
The composition of each class can be completely determined if which one of the following pairs of students is known to be in the level 2 class?

# Options:
A) Fred and Kathy
B) Fred and Mike
C) Hilary and Jan
D) Kathy and Laura
E) Laura and Mike","# Declarations
students = EnumSort([Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, Nick])
classes = EnumSort([level1, level2, level3])
assigned = Function([students] -> [classes])
# Constraints
ForAll([c:classes], Count([s:students], assigned(s) == c) == 3) ::: Each class has exactly three students
Count([s:students], assigned(s) == level1) == 3 ::: The three highest scorers are placed in the level 1 class
Count([s:students], assigned(s) == level3) == 3 ::: The three lowest scorers are placed in the level 3 class
Count([s:students], assigned(s) == level2) == 3 ::: The remaining three are placed in the level 2 class
assigned(Ida) != assigned(Glen) ::: Ida scores higher than Glen
assigned(Glen) != assigned(Jan) ::: Glen scores higher than Jan
assigned(Glen) != assigned(Kathy) ::: Glen scores higher than Kathy
assigned(Jan) != assigned(Mike) ::: Jan scores higher than Mike
assigned(Mike) != assigned(Hilary) ::: Mike scores higher than Hilary
assigned(Hilary) != assigned(Nick) ::: Hilary scores higher than Nick
assigned(Kathy) != assigned(Fred) ::: Kathy scores higher than Fred
assigned(Kathy) != assigned(Laura) ::: Kathy scores higher than Laura
# Options
is_accurate_list([assigned(Fred) == level2, assigned(Kathy) == level2]) ::: (A)
is_accurate_list([assigned(Fred) == level2, assigned(Mike) == level2]) ::: (B)
is_accurate_list([assigned(Hilary) == level2, assigned(Jan) == level2]) ::: (C)
is_accurate_list([assigned(Kathy) == level2, assigned(Laura) == level2]) ::: (D)
is_accurate_list([assigned(Laura) == level2, assigned(Mike) == level2]) ::: (E)"
"# Context:
Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.

# Question:
If Fran and Lewis are two of three counselors assigned to supervise swimming, which one of the following must be true of the assignment?

# Options:
A) George supervises volleyball.
B) Henry supervises volleyball.
C) Joan supervises tennis.
D) Kathy supervises swimming.
E) Nathan supervises tennis.","# Declarations
counselors = EnumSort([Fran, George, Henry, Joan, Kathy, Lewis, Nathan, Olga])
activities = EnumSort([swimming, tennis, volleyball])
assigned = Function([counselors] -> [activities])
# Constraints
ForAll([a:activities], And(Count([c:counselors], assigned(c) == a) >= 2, Count([c:counselors], assigned(c) == a) <= 3)) ::: Each activity is supervised by at least two, but not more than three, of the eight counselors
assigned(Henry) == swimming ::: Henry supervises swimming
ForAll([c:counselors], Or(c != Kathy, assigned(c) != tennis)) ::: Neither Kathy nor Olga supervises tennis
ForAll([c:counselors], Or(c != Olga, assigned(c) != tennis)) ::: Neither Kathy nor Olga supervises tennis
ForAll([c:counselors], Or(c != Kathy, assigned(c) != assigned(Joan))) ::: Neither Kathy nor Nathan supervises the same activity as Joan
ForAll([c:counselors], Or(c != Nathan, assigned(c) != assigned(Joan))) ::: Neither Kathy nor Nathan supervises the same activity as Joan
Implies(assigned(George) == swimming, And(assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: If George supervises swimming, both Nathan and Olga supervise volleyball
Count([c:counselors], assigned(c) == swimming) == 3 ::: Fran and Lewis are two of three counselors assigned to supervise swimming
# Options
is_valid(assigned(George) == volleyball) ::: (A)
is_valid(assigned(Henry) == volleyball) ::: (B)
is_valid(assigned(Joan) == tennis) ::: (C)
is_valid(assigned(Kathy) == swimming) ::: (D)
is_valid(assigned(Nathan) == tennis) ::: (E)"
"# Context:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.

# Question:
If F is in the same group as H, which one of the following must be true?

# Options:
A) G is in group 2.
B) J is in group 1.
C) K is in group 1.
D) L is in group 2.
E) M is in group 2.","# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group1, group2])
assigned = Function([consumers] -> [groups])
# Constraints
Count([c:consumers], assigned(c) == group1) == 4 ::: The eight will be divided into exactly two 4-person groups
Count([c:consumers], assigned(c) == group2) == 4 ::: The eight will be divided into exactly two 4-person groups
assigned(F) == assigned(J) ::: F must be in the same group as J
assigned(G) != assigned(M) ::: G must be in a different group from M
Implies(assigned(H) == group1, assigned(L) == group1) ::: If H is in group 1, then L must be in group 1
Implies(assigned(N) == group2, assigned(G) == group1) ::: If N is in group 2, then G must be in group 1
assigned(F) == assigned(H) ::: If F is in the same group as H
# Options
is_valid(assigned(G) == group2) ::: (A)
is_valid(assigned(J) == group1) ::: (B)
is_valid(assigned(K) == group1) ::: (C)
is_valid(assigned(L) == group2) ::: (D)
is_valid(assigned(M) == group2) ::: (E)"
"# Context:
The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.

# Question:
Which one of the following must be true about the three clans that participate in the ceremonies in the first year?

# Options:
A) At most two of them participate together in the third year.
B) At least two of them participate together in the second year.
C) All three of them participate together in the fourth year.
D) All three of them participate together in the fifth year.
E) None of them participates in the third year.","# Declarations
clans = EnumSort([N, O, P, S, T])
years = EnumSort([first, second, third, fourth, fifth])
participates = Function([clans, years] -> [bool])
# Constraints
ForAll([y:years], Count([c:clans], participates(c, y)) == 3) ::: Each year exactly three of the five clans participate in the annual harvest ceremonies
ForAll([c:clans], And(Exists([y:years], participates(c, y)), Exists([y:years], participates(c, y)))) ::: Each clan must participate at least once in any two consecutive years
ForAll([c:clans], Not(And(participates(c, first), participates(c, second), participates(c, third)))) ::: No clan participates for three consecutive years
ForAll([c:clans], Count([y:years], participates(c, y)) <= 3) ::: No clan participates more than three times within any cycle
# Options
is_valid(Count([c:clans], And(participates(c, first), participates(c, third))) <= 2) ::: (A)
is_valid(Count([c:clans], And(participates(c, first), participates(c, second))) >= 2) ::: (B)
is_valid(ForAll([c:clans], participates(c, first) == participates(c, fourth))) ::: (C)
is_valid(ForAll([c:clans], participates(c, first) == participates(c, fifth))) ::: (D)
is_valid(ForAll([c:clans], Not(participates(c, first) == participates(c, third)))) ::: (E)"
"# Context:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.

# Question:
If L is in group 2, then each of the following is a pair of people who could be in group 1 together EXCEPT

# Options:
A) F and M
B) G and N
C) J and N
D) K and M
E) M and N","# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group1, group2])
assigned = Function([consumers] -> [groups])
# Constraints
ForAll([c:consumers], Exists([g:groups], assigned(c) == g)) ::: Each person is assigned to exactly one of the two groups
Count([c:consumers], assigned(c) == group1) == 4 ::: There are exactly two 4-person groups
Count([c:consumers], assigned(c) == group2) == 4 ::: There are exactly two 4-person groups
assigned(F) == assigned(J) ::: F must be in the same group as J
assigned(G) != assigned(M) ::: G must be in a different group from M
Implies(assigned(H) == group1, assigned(L) == group1) ::: If H is in group 1, then L must be in group 1
Implies(assigned(N) == group2, assigned(G) == group1) ::: If N is in group 2, then G must be in group 1
assigned(L) == group2 ::: If L is in group 2
# Options
is_unsat(And(assigned(F) == group1, assigned(M) == group1)) ::: (A)
is_unsat(And(assigned(G) == group1, assigned(N) == group1)) ::: (B)
is_unsat(And(assigned(J) == group1, assigned(N) == group1)) ::: (C)
is_unsat(And(assigned(K) == group1, assigned(M) == group1)) ::: (D)
is_unsat(And(assigned(M) == group1, assigned(N) == group1)) ::: (E)"
"# Context:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.

# Question:
If K is in the same group as N, which one of the following must be true?

# Options:
A) G is in group 1.
B) H is in group 2.
C) J is in group 1.
D) K is in group 2.
E) M is in group 1.","# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group1, group2])
assigned = Function([consumers] -> [groups])
# Constraints
Count([c:consumers], assigned(c) == group1) == 4 ::: The eight will be divided into exactly two 4-person groups
Count([c:consumers], assigned(c) == group2) == 4 ::: The eight will be divided into exactly two 4-person groups
assigned(F) == assigned(J) ::: F must be in the same group as J
assigned(G) != assigned(M) ::: G must be in a different group from M
Implies(assigned(H) == group1, assigned(L) == group1) ::: If H is in group 1, then L must be in group 1
Implies(assigned(N) == group2, assigned(G) == group1) ::: If N is in group 2, then G must be in group 1
assigned(K) == assigned(N) ::: K is in the same group as N
# Options
is_valid(assigned(G) == group1) ::: (A)
is_valid(assigned(H) == group2) ::: (B)
is_valid(assigned(J) == group1) ::: (C)
is_valid(assigned(K) == group2) ::: (D)
is_valid(assigned(M) == group1) ::: (E)"
"# Context:
A science student has exactly four flasks—1, 2, 3, and 4—originally containing a red, a blue, a green, and an orange chemical, respectively. An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks. The following conditions apply: The product of an experiment cannot be used in further experiments. Mixing the contents of 1 and 2 produces a red chemical. Mixing the contents of 2 and 3 produces an orange chemical. Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical. Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical.

# Question:
If the student performs exactly one experiment, which one of the following could be the colors of the chemicals in the resulting three nonempty flasks?

# Options:
A) blue, blue, green
B) blue, orange, orange
C) blue, orange, red
D) green, green, red
E) green, orange, orange","# Declarations
flasks = EnumSort([1, 2, 3, 4])
colors = EnumSort([red, blue, green, orange])
contains = Function([flasks] -> [colors])
mixed = Function([flasks, flasks] -> [bool])
# Constraints
ForAll([f:flasks], Exists([c:colors], contains(f) == c)) ::: Each flask originally contains exactly one color
ForAll([f1:flasks, f2:flasks], Implies(mixed(f1, f2), And(f1 != f2, Not(Exists([f3:flasks], And(mixed(f3, f1), mixed(f3, f2))))))) ::: The product of an experiment cannot be used in further experiments
mixed(1, 2) ::: Mixing the contents of 1 and 2 produces a red chemical
mixed(2, 3) ::: Mixing the contents of 2 and 3 produces an orange chemical
Or(mixed(3, 1), mixed(3, 4)) ::: Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical
Or(mixed(4, 1), mixed(4, 2)) ::: Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical
Count([f1:flasks, f2:flasks], mixed(f1, f2)) == 1 ::: The student performs exactly one experiment
# Options
is_sat(And(Count([f:flasks], contains(f) == blue) == 2, Count([f:flasks], contains(f) == green) == 1)) ::: (A) blue, blue, green
is_sat(And(Count([f:flasks], contains(f) == blue) == 1, Count([f:flasks], contains(f) == orange) == 2)) ::: (B) blue, orange, orange
is_sat(And(Count([f:flasks], contains(f) == blue) == 1, Count([f:flasks], contains(f) == orange) == 1, Count([f:flasks], contains(f) == red) == 1)) ::: (C) blue, orange, red
is_sat(And(Count([f:flasks], contains(f) == green) == 2, Count([f:flasks], contains(f) == red) == 1)) ::: (D) green, green, red
is_sat(And(Count([f:flasks], contains(f) == green) == 1, Count([f:flasks], contains(f) == orange) == 2)) ::: (E) green, orange, orange"
"# Context:
Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.

# Question:
Which one of the following is an acceptable assignment of apprentices to the projects after only one reassignment during the year?

# Options:
A) Q: Louis; R: Madelyn; S: Nora; T: Oliver
B) Q: Madelyn; R: Louis; S: Nora; T: Oliver
C) Q: Madelyn; R: Oliver; S: Nora; T: Louis
D) Q: Nora; R: Louis; S: Oliver; T: Madelyn
E) Q: Nora; R: Madelyn; S: Oliver; T: Louis","# Declarations
apprentices = EnumSort([Louis, Madelyn, Nora, Oliver])
projects = EnumSort([Q, R, S, T])
assigned = Function([apprentices] -> [projects])
# Constraints
assigned(Louis) == Q ::: Louis is initially assigned to project Q
assigned(Madelyn) == R ::: Madelyn is initially assigned to project R
assigned(Nora) == S ::: Nora is initially assigned to project S
assigned(Oliver) == T ::: Oliver is initially assigned to project T
# Options
is_sat(And(assigned(Louis) == Q, assigned(Madelyn) == R, assigned(Nora) == S, assigned(Oliver) == T)) ::: (A)
is_sat(And(assigned(Madelyn) == Q, assigned(Louis) == R, assigned(Nora) == S, assigned(Oliver) == T)) ::: (B)
is_sat(And(assigned(Madelyn) == Q, assigned(Oliver) == R, assigned(Nora) == S, assigned(Louis) == T)) ::: (C)
is_sat(And(assigned(Nora) == Q, assigned(Louis) == R, assigned(Oliver) == S, assigned(Madelyn) == T)) ::: (D)
is_sat(And(assigned(Nora) == Q, assigned(Madelyn) == R, assigned(Oliver) == S, assigned(Louis) == T)) ::: (E)"
"# Context:
Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.

# Question:
If George and Kathy are two of three counselors assigned to supervise swimming, which one of the following could be true of the assignment?

# Options:
A) Fran supervises swimming.
B) Henry supervises tennis.
C) Joan supervises volleyball.
D) Lewis supervises volleyball.
E) Nathan supervises tennis.","# Declarations
counselors = EnumSort([Fran, George, Henry, Joan, Kathy, Lewis, Nathan, Olga])
activities = EnumSort([swimming, tennis, volleyball])
assigned = Function([counselors] -> [activities])
# Constraints
ForAll([a:activities], And(Count([c:counselors], assigned(c) == a) >= 2, Count([c:counselors], assigned(c) == a) <= 3)) ::: Each activity is supervised by at least two, but not more than three, of the eight counselors
assigned(Henry) == swimming ::: Henry supervises swimming
And(assigned(Kathy) != tennis, assigned(Olga) != tennis) ::: Neither Kathy nor Olga supervises tennis
And(assigned(Kathy) != assigned(Joan), assigned(Nathan) != assigned(Joan)) ::: Neither Kathy nor Nathan supervises the same activity as Joan
Implies(assigned(George) == swimming, And(assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: If George supervises swimming, both Nathan and Olga supervise volleyball
And(assigned(George) == swimming, assigned(Kathy) == swimming) ::: If George and Kathy are two of three counselors assigned to supervise swimming
# Options
is_valid(assigned(Fran) == swimming) ::: (A)
is_valid(assigned(Henry) == tennis) ::: (B)
is_valid(assigned(Joan) == volleyball) ::: (C)
is_valid(assigned(Lewis) == volleyball) ::: (D)
is_valid(assigned(Nathan) == tennis) ::: (E)"
"# Context:
Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.

# Question:
If the vendor charges $1 for each portion of food, what is the greatest amount the three people could spend?

# Options:
A) $5
B) $6
C) $7
D) $8
E) $9","# Declarations
people = EnumSort([Lara, Mendel, Nastassia])
foods = EnumSort([fruit_cups, hot_dogs, pretzels, shish_kebabs])
buys = Function([people, foods] -> [bool])
# Constraints
ForAll([p:people], Exists([f:foods], buys(p, f))) ::: Each person buys at least one kind of food
ForAll([p:people, f:foods], Not(And(buys(p, f), buys(p, f)))) ::: None of the three buys more than one portion of each kind of food
ForAll([p:people], Implies(buys(p, hot_dogs), Not(buys(p, shish_kebabs)))) ::: If any of the three buys a hot dog, that person does not also buy a shish kebab
Exists([p:people], buys(p, hot_dogs)) ::: At least one of the three buys a hot dog
Exists([p:people], buys(p, pretzels)) ::: At least one of the three buys a pretzel
buys(Mendel, shish_kebabs) ::: Mendel buys a shish kebab
buys(Nastassia, fruit_cups) ::: Nastassia buys a fruit cup
ForAll([f:foods], Not(And(buys(Lara, f), buys(Nastassia, f)))) ::: Neither Lara nor Nastassia buys a pretzel
ForAll([f:foods], Not(And(buys(Mendel, f), buys(Nastassia, f)))) ::: Mendel does not buy any kind of food that Nastassia buys
# Options
is_valid(Count([p:people, f:foods], buys(p, f)) == 5) ::: (A)
is_valid(Count([p:people, f:foods], buys(p, f)) == 6) ::: (B)
is_valid(Count([p:people, f:foods], buys(p, f)) == 7) ::: (C)
is_valid(Count([p:people, f:foods], buys(p, f)) == 8) ::: (D)
is_valid(Count([p:people, f:foods], buys(p, f)) == 9) ::: (E)"
"# Context:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.

# Question:
Group 1 could consist of

# Options:
A) F, G, H, and J
B) F, H, L, and M
C) F, J, K, and L
D) G, H, L, and N
E) G, K, M, and N","# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group1, group2])
assigned = Function([consumers] -> [groups])
# Constraints
ForAll([c:consumers], Exists([g:groups], assigned(c) == g)) ::: Each person is assigned to exactly one of the two groups
Count([c:consumers], assigned(c) == group1) == 4 ::: Group 1 consists of exactly 4 people
Count([c:consumers], assigned(c) == group2) == 4 ::: Group 2 consists of exactly 4 people
assigned(F) == assigned(J) ::: F must be in the same group as J
assigned(G) != assigned(M) ::: G must be in a different group from M
Implies(assigned(H) == group1, assigned(L) == group1) ::: If H is in group 1, then L must be in group 1
Implies(assigned(N) == group2, assigned(G) == group1) ::: If N is in group 2, then G must be in group 1
# Options
is_accurate_list([assigned(F) == group1, assigned(G) == group1, assigned(H) == group1, assigned(J) == group1]) ::: (A)
is_accurate_list([assigned(F) == group1, assigned(H) == group1, assigned(L) == group1, assigned(M) == group1]) ::: (B)
is_accurate_list([assigned(F) == group1, assigned(J) == group1, assigned(K) == group1, assigned(L) == group1]) ::: (C)
is_accurate_list([assigned(G) == group1, assigned(H) == group1, assigned(L) == group1, assigned(N) == group1]) ::: (D)
is_accurate_list([assigned(G) == group1, assigned(K) == group1, assigned(M) == group1, assigned(N) == group1]) ::: (E)"
"# Context:
Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.

# Question:
Each of the following is a pair of people who could be in group 1 together EXCEPT

# Options:
A) F and G
B) F and H
C) F and L
D) H and G
E) H and N","# Declarations
consumers = EnumSort([F, G, H, J, K, L, M, N])
groups = EnumSort([group1, group2])
assigned = Function([consumers] -> [groups])
# Constraints
ForAll([c:consumers], Exists([g:groups], assigned(c) == g)) ::: Each person is assigned to exactly one of the two groups
Count([c:consumers], assigned(c) == group1) == 4 ::: There are exactly two 4-person groups
Count([c:consumers], assigned(c) == group2) == 4 ::: There are exactly two 4-person groups
assigned(F) == assigned(J) ::: F must be in the same group as J
assigned(G) != assigned(M) ::: G must be in a different group from M
Implies(assigned(H) == group1, assigned(L) == group1) ::: If H is in group 1, then L must be in group 1
Implies(assigned(N) == group2, assigned(G) == group1) ::: If N is in group 2, then G must be in group 1
# Options
is_unsat(And(assigned(F) == group1, assigned(G) == group1)) ::: (A)
is_unsat(And(assigned(F) == group1, assigned(H) == group1)) ::: (B)
is_unsat(And(assigned(F) == group1, assigned(L) == group1)) ::: (C)
is_unsat(And(assigned(H) == group1, assigned(G) == group1)) ::: (D)
is_unsat(And(assigned(H) == group1, assigned(N) == group1)) ::: (E)"
"# Context:
A science student has exactly four flasks—1, 2, 3, and 4—originally containing a red, a blue, a green, and an orange chemical, respectively. An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks. The following conditions apply: The product of an experiment cannot be used in further experiments. Mixing the contents of 1 and 2 produces a red chemical. Mixing the contents of 2 and 3 produces an orange chemical. Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical. Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical.

# Question:
If the student performs exactly one experiment and exactly one of the resulting three nonempty flasks contains a blue chemical, which one of the following must be the colors of the chemicals in the other two flasks?

# Options:
A) both green
B) both orange
C) both red
D) one green and one red
E) one orange and one red","# Declarations
flasks = EnumSort([1, 2, 3, 4])
colors = EnumSort([red, blue, green, orange])
contains = Function([flasks] -> [colors])
mixed = Function([flasks, flasks] -> [bool])
# Constraints
ForAll([f:flasks], Exists([c:colors], contains(f) == c)) ::: each flask originally contains exactly one chemical
ForAll([f1:flasks, f2:flasks], Implies(mixed(f1, f2), And(f1 != f2, Not(Exists([f3:flasks], And(mixed(f3, f1), mixed(f3, f2))))))) ::: the product of an experiment cannot be used in further experiments
mixed(1, 2) ::: mixing the contents of 1 and 2 produces a red chemical
mixed(2, 3) ::: mixing the contents of 2 and 3 produces an orange chemical
Or(mixed(3, 1), mixed(3, 4)) ::: mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical
Or(mixed(4, 1), mixed(4, 2)) ::: mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical
Count([f1:flasks, f2:flasks], mixed(f1, f2)) == 1 ::: the student performs exactly one experiment
Exists([f:flasks], contains(f) == blue) ::: exactly one of the resulting three nonempty flasks contains a blue chemical
# Options
is_valid(And(contains(1) == green, contains(2) == green)) ::: (A) both green
is_valid(And(contains(1) == orange, contains(2) == orange)) ::: (B) both orange
is_valid(And(contains(1) == red, contains(2) == red)) ::: (C) both red
is_valid(Or(And(contains(1) == green, contains(2) == red), And(contains(1) == red, contains(2) == green))) ::: (D) one green and one red
is_valid(Or(And(contains(1) == orange, contains(2) == red), And(contains(1) == red, contains(2) == orange))) ::: (E) one orange and one red"
"# Context:
Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.

# Question:
If the vendor charges $1 for each portion of food, what is the minimum amount the three people could spend?

# Options:
A) $3
B) $4
C) $5
D) $6
E) $7","# Declarations
people = EnumSort([Lara, Mendel, Nastassia])
foods = EnumSort([fruit_cups, hot_dogs, pretzels, shish_kebabs])
buys = Function([people, foods] -> [bool])
# Constraints
ForAll([p:people], Exists([f:foods], buys(p, f))) ::: Each person buys at least one kind of food
ForAll([p:people, f:foods], Not(And(buys(p, f), buys(p, f)))) ::: None of the three buys more than one portion of each kind of food
ForAll([p:people], Implies(buys(p, hot_dogs), Not(buys(p, shish_kebabs)))) ::: If any of the three buys a hot dog, that person does not also buy a shish kebab
Exists([p:people], buys(p, hot_dogs)) ::: At least one of the three buys a hot dog
Exists([p:people], buys(p, pretzels)) ::: At least one of the three buys a pretzel
buys(Mendel, shish_kebabs) ::: Mendel buys a shish kebab
buys(Nastassia, fruit_cups) ::: Nastassia buys a fruit cup
ForAll([f:foods], Not(And(buys(Lara, f), buys(Lara, pretzels)))) ::: Neither Lara nor Nastassia buys a pretzel
ForAll([f:foods], Not(And(buys(Nastassia, f), buys(Nastassia, pretzels)))) ::: Neither Lara nor Nastassia buys a pretzel
ForAll([f:foods], Not(And(buys(Mendel, f), buys(Nastassia, f)))) ::: Mendel does not buy any kind of food that Nastassia buys
# Options
is_valid(Count([p:people, f:foods], buys(p, f)) == 3) ::: (A)
is_valid(Count([p:people, f:foods], buys(p, f)) == 4) ::: (B)
is_valid(Count([p:people, f:foods], buys(p, f)) == 5) ::: (C)
is_valid(Count([p:people, f:foods], buys(p, f)) == 6) ::: (D)
is_valid(Count([p:people, f:foods], buys(p, f)) == 7) ::: (E)"
"# Context:
A soloist will play six different guitar concertos, exactly one each Sunday for six consecutive weeks. Two concertos will be selected from among three concertos by Giuliani—H, J, and K; two from among four concertos by Rodrigo—M, N, O, and P; and two from among three concertos by Vivaldi—X, Y, and Z. The following conditions apply without exception: If N is selected, then J is also selected. If M is selected, then neither J nor O can be selected. If X is selected, then neither Z nor P can be selected. If both J and O are selected, then J is played at some time before O. X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.

# Question:
Which one of the following is a concerto that CANNOT be selected together with N?

# Options:
A) M
B) O
C) P
D) X
E) Z","# Declarations
concertos = EnumSort([H, J, K, M, N, O, P, X, Y, Z])
selected = Function([concertos] -> [bool])
played_on = Function([concertos] -> [int])
# Constraints
Count([c:concertos], selected(c)) == 6 ::: exactly six different guitar concertos will be selected
Count([c:concertos], And(selected(c), Or(c == H, c == J, c == K))) == 2 ::: two concertos by Giuliani will be selected
Count([c:concertos], And(selected(c), Or(c == M, c == N, c == O, c == P))) == 2 ::: two concertos by Rodrigo will be selected
Count([c:concertos], And(selected(c), Or(c == X, c == Y, c == Z))) == 2 ::: two concertos by Vivaldi will be selected
Implies(selected(N), selected(J)) ::: If N is selected, then J is also selected
Implies(selected(M), And(Not(selected(J)), Not(selected(O)))) ::: If M is selected, then neither J nor O can be selected
Implies(selected(X), And(Not(selected(Z)), Not(selected(P)))) ::: If X is selected, then neither Z nor P can be selected
Implies(And(selected(J), selected(O)), played_on(J) < played_on(O)) ::: If both J and O are selected, then J is played at some time before O
Implies(played_on(X) == 5, Exists([c:concertos], And(Or(c == M, c == N, c == O, c == P), played_on(c) == 1))) ::: X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday
# Options
is_unsat(And(selected(N), selected(M))) ::: (A)
is_unsat(And(selected(N), selected(O))) ::: (B)
is_unsat(And(selected(N), selected(P))) ::: (C)
is_unsat(And(selected(N), selected(X))) ::: (D)
is_unsat(And(selected(N), selected(Z))) ::: (E)"
"# Context:
Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.

# Question:
Which one of the following is a pair of counselors who could be two of three counselors assigned to supervise swimming?

# Options:
A) George and Nathan
B) George and Olga
C) Joan and Kathy
D) Joan and Nathan
E) Joan and Olga","# Declarations
counselors = EnumSort([Fran, George, Henry, Joan, Kathy, Lewis, Nathan, Olga])
activities = EnumSort([swimming, tennis, volleyball])
assigned = Function([counselors] -> [activities])
# Constraints
ForAll([a:activities], And(Count([c:counselors], assigned(c) == a) >= 2, Count([c:counselors], assigned(c) == a) <= 3)) ::: Each activity is supervised by at least two, but not more than three, of the eight counselors
assigned(Henry) == swimming ::: Henry supervises swimming
assigned(Kathy) != tennis ::: Neither Kathy nor Olga supervises tennis
assigned(Olga) != tennis ::: Neither Kathy nor Olga supervises tennis
assigned(Kathy) != assigned(Joan) ::: Neither Kathy nor Nathan supervises the same activity as Joan
assigned(Nathan) != assigned(Joan) ::: Neither Kathy nor Nathan supervises the same activity as Joan
Implies(assigned(George) == swimming, And(assigned(Nathan) == volleyball, assigned(Olga) == volleyball)) ::: If George supervises swimming, both Nathan and Olga supervise volleyball
# Options
is_accurate_list([assigned(George) == swimming, assigned(Nathan) == swimming]) ::: (A)
is_accurate_list([assigned(George) == swimming, assigned(Olga) == swimming]) ::: (B)
is_accurate_list([assigned(Joan) == swimming, assigned(Kathy) == swimming]) ::: (C)
is_accurate_list([assigned(Joan) == swimming, assigned(Nathan) == swimming]) ::: (D)
is_accurate_list([assigned(Joan) == swimming, assigned(Olga) == swimming]) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
If three of the organisms respond to exactly the same set of antibiotics as each other, and if Z does not respond to ferromycin, then each of the following must be true EXCEPT:

# Options:
A) W responds to ferromycin.
B) X responds to ganocyclene.
C) Z responds to ganocyclene.
D) W responds to exactly the same set of antibiotics as Y.
E) X responds to exactly the same set of antibiotics as Y.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: At least two but not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
Count([o:organisms], ForAll([a:antibiotics], responds(o, a) == responds(Y, a))) == 3 ::: Three of the organisms respond to exactly the same set of antibiotics as each other
Not(responds(Z, ferromycin)) ::: Z does not respond to ferromycin
# Options
is_unsat(responds(W, ferromycin)) ::: (A)
is_unsat(responds(X, ganocyclene)) ::: (B)
is_unsat(responds(Z, ganocyclene)) ::: (C)
is_unsat(ForAll([a:antibiotics], responds(W, a) == responds(Y, a))) ::: (D)
is_unsat(ForAll([a:antibiotics], responds(X, a) == responds(Y, a))) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
If none of the organisms responds to heptocillin, then which one of the following must be true?

# Options:
A) W responds to ferromycin.
B) X responds to ferromycin.
C) Z responds to ferromycin.
D) Exactly three of the organisms respond to ganocyclene.
E) Exactly four of the organisms respond to ganocyclene.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: At least two but not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
ForAll([o:organisms], Not(responds(o, heptocillin))) ::: If none of the organisms responds to heptocillin
# Options
is_valid(responds(W, ferromycin)) ::: (A)
is_valid(responds(X, ferromycin)) ::: (B)
is_valid(responds(Z, ferromycin)) ::: (C)
is_valid(Count([o:organisms], responds(o, ganocyclene)) == 3) ::: (D)
is_valid(Count([o:organisms], responds(o, ganocyclene)) == 4) ::: (E)"
"# Context:
Six cities are located within the numbered areas as follows: Within the six-city area there are exactly four hospitals, two jails, and two universities. These eight institutions are located as follows: No institution is in more than one of the cities. None of the cities contains more than one jail, and none contains more than one university. None of the cities contains both a jail and a university. Each jail is located in a city that contains at least one hospital. The universities are located in two cities that do not share a common boundary. City 3 contains a university, and city 6 contains a jail.

# Question:
Which one of the following could be true?

# Options:
A) City 5 contains a university.
B) City 6 contains a university.
C) City 2 contains a jail.
D) City 3 contains a jail.
E) City 3 contains a hospital.","# Declarations
cities = EnumSort([City1, City2, City3, City4, City5, City6])
institutions = EnumSort([Hospital1, Hospital2, Hospital3, Hospital4, Jail1, Jail2, University1, University2])
located_in = Function([institutions] -> [cities])
# Constraints
Count([i:institutions], located_in(i) == City3) == 1 ::: City 3 contains a university
Count([i:institutions], located_in(i) == City6) == 1 ::: City 6 contains a jail
ForAll([i:institutions], Count([c:cities], located_in(i) == c) == 1) ::: No institution is in more than one of the cities
ForAll([c:cities], Count([i:institutions], And(located_in(i) == c, Or(i == Jail1, i == Jail2))) <= 1) ::: None of the cities contains more than one jail
ForAll([c:cities], Count([i:institutions], And(located_in(i) == c, Or(i == University1, i == University2))) <= 1) ::: None of the cities contains more than one university
ForAll([c:cities], Not(And(Exists([i:institutions], And(located_in(i) == c, Or(i == Jail1, i == Jail2))), Exists([i:institutions], And(located_in(i) == c, Or(i == University1, i == University2)))))) ::: None of the cities contains both a jail and a university
ForAll([j:institutions], Implies(Or(j == Jail1, j == Jail2), Exists([h:institutions], And(Or(h == Hospital1, h == Hospital2, h == Hospital3, h == Hospital4), located_in(j) == located_in(h))))) ::: Each jail is located in a city that contains at least one hospital
Exists([c1:cities, c2:cities], And(c1 != c2, Or(And(located_in(University1) == c1, located_in(University2) == c2), And(located_in(University1) == c2, located_in(University2) == c1)), Not(Or(c1 == City1, c1 == City2, c1 == City3, c1 == City4, c1 == City5, c1 == City6, c2 == City1, c2 == City2, c2 == City3, c2 == City4, c2 == City5, c2 == City6)))) ::: The universities are located in two cities that do not share a common boundary
# Options
is_sat(Exists([i:institutions], And(Or(i == University1, i == University2), located_in(i) == City5))) ::: (A)
is_sat(Exists([i:institutions], And(Or(i == University1, i == University2), located_in(i) == City6))) ::: (B)
is_sat(Exists([i:institutions], And(Or(i == Jail1, i == Jail2), located_in(i) == City2))) ::: (C)
is_sat(Exists([i:institutions], And(Or(i == Jail1, i == Jail2), located_in(i) == City3))) ::: (D)
is_sat(Exists([i:institutions], And(Or(i == Hospital1, i == Hospital2, i == Hospital3, i == Hospital4), located_in(i) == City3))) ::: (E)"
"# Context:
A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.

# Question:
If light 4 is on, each of the following statements must be true EXCEPT:

# Options:
A) Light 1 is on.
B) Light 2 is on.
C) Light 5 is off.
D) Light 6 is on.
E) Light 7 is off.","# Declarations
lights = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
is_on = Function([lights] -> [bool])
# Constraints
ForAll([i:lights], Implies(And(i >= 1, i <= 6), Not(And(is_on(i), is_on(i+1), is_on(i+2))))) ::: At least one of any three consecutively numbered lights is off
is_on(8) ::: Light 8 is on
Implies(is_on(1), And(Not(is_on(2)), Not(is_on(7)))) ::: Neither light 2 nor light 7 is on when light 1 is on
ForAll([i:lights], Implies(And(i >= 1, i <= 6), Or(is_on(i), is_on(i+1), is_on(i+2)))) ::: At least one of the three lights on each side is on
ForAll([i:lights], Implies(And(i >= 1, i <= 6), Implies(Count([j:lights], And(j >= i, j <= i+2, is_on(j))) == 1, is_on(i+1)))) ::: If any side has exactly one of its three lights on, then that light is its center light
Count([i:lights], And(i >= 1, i <= 3, is_on(i))) == 2 ::: Two of the lights on the north side are on
is_on(4) ::: Light 4 is on
# Options
is_unsat(is_on(1)) ::: (A)
is_unsat(is_on(2)) ::: (B)
is_unsat(Not(is_on(5))) ::: (C)
is_unsat(is_on(6)) ::: (D)
is_unsat(Not(is_on(7))) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
Which one of the following is an acceptable assignment of reviewers to movies? Mystery Retreat Seasonings Wolves

# Options:
A) George Frank, Hilda Jackie, Lena Karl
B) George Frank, Hilda Karl, Lena Jackie
C) George Karl, Lena Jackie Frank, Hilda
D) George, Karl Frank, Hilda Lena Jackie
E) Jackie George, Lena Frank, Hilda Karl","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
ForAll([r:reviewers], Exists([m:movies], reviews(r) == m)) ::: each reviewer reviews exactly one movie
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Count([r:reviewers], reviews(r) == reviews(Lena)) == 1 ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
# Options
is_sat(And(reviews(George) == Mystery, reviews(Frank) == Retreat, reviews(Hilda) == Retreat, reviews(Jackie) == Seasonings, reviews(Lena) == Seasonings, reviews(Karl) == Wolves)) ::: (A)
is_sat(And(reviews(George) == Mystery, reviews(Frank) == Retreat, reviews(Hilda) == Retreat, reviews(Karl) == Seasonings, reviews(Lena) == Seasonings, reviews(Jackie) == Wolves)) ::: (B)
is_sat(And(reviews(George) == Mystery, reviews(Karl) == Retreat, reviews(Lena) == Retreat, reviews(Jackie) == Seasonings, reviews(Frank) == Seasonings, reviews(Hilda) == Wolves)) ::: (C)
is_sat(And(reviews(George) == Mystery, reviews(Karl) == Retreat, reviews(Frank) == Retreat, reviews(Hilda) == Retreat, reviews(Lena) == Seasonings, reviews(Jackie) == Wolves)) ::: (D)
is_sat(And(reviews(Jackie) == Mystery, reviews(George) == Mystery, reviews(Lena) == Retreat, reviews(Frank) == Retreat, reviews(Hilda) == Seasonings, reviews(Karl) == Wolves)) ::: (E)"
"# Context:
Six cities are located within the numbered areas as follows: Within the six-city area there are exactly four hospitals, two jails, and two universities. These eight institutions are located as follows: No institution is in more than one of the cities. None of the cities contains more than one jail, and none contains more than one university. None of the cities contains both a jail and a university. Each jail is located in a city that contains at least one hospital. The universities are located in two cities that do not share a common boundary. City 3 contains a university, and city 6 contains a jail.

# Question:
In which one of the following cities must there be fewer than three hospitals?

# Options:
A) 1
B) 2
C) 4
D) 5
E) 6","# Declarations
cities = EnumSort([1, 2, 3, 4, 5, 6])
institutions = EnumSort([hospital, jail, university])
located = Function([institutions, cities] -> [bool])
# Constraints
Count([c:cities], Exists([i:institutions], located(i, c))) == 6 ::: Six cities are located within the numbered areas
Count([c:cities], located(hospital, c)) == 4 ::: There are exactly four hospitals
Count([c:cities], located(jail, c)) == 2 ::: There are exactly two jails
Count([c:cities], located(university, c)) == 2 ::: There are exactly two universities
ForAll([c:cities], Implies(located(jail, c), Not(located(university, c)))) ::: None of the cities contains both a jail and a university
ForAll([c:cities], Implies(located(jail, c), Exists([c1:cities], And(c1 != c, located(hospital, c1))))) ::: Each jail is located in a city that contains at least one hospital
located(university, 3) ::: City 3 contains a university
located(jail, 6) ::: City 6 contains a jail
ForAll([c:cities], Implies(located(university, c), ForAll([c1:cities], Implies(c1 != c, Not(And(located(university, c1), Exists([c2:cities], And(c2 != c, c2 != c1, Exists([i:institutions], located(i, c2)))))))))) ::: The universities are located in two cities that do not share a common boundary
# Options
is_valid(Count([c:cities], located(hospital, c)) < 3) ::: (A)
is_valid(Count([c:cities], located(hospital, c)) < 3) ::: (B)
is_valid(Count([c:cities], located(hospital, c)) < 3) ::: (C)
is_valid(Count([c:cities], located(hospital, c)) < 3) ::: (D)
is_valid(Count([c:cities], located(hospital, c)) < 3) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
Which one of the following is a complete and accurate list of the movies each of which could be the movie that Lena reviews?

# Options:
A) Mystery, Retreat
B) Retreat, Seasonings
C) Mystery, Seasonings, Wolves
D) Retreat, Seasonings, Wolves
E) Mystery, Retreat, Seasonings, Wolves","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Exists([r:reviewers], And(r != Lena, reviews(Lena) == reviews(r))) ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
# Options
is_accurate_list([reviews(Lena) == Mystery, reviews(Lena) == Retreat]) ::: (A)
is_accurate_list([reviews(Lena) == Retreat, reviews(Lena) == Seasonings]) ::: (B)
is_accurate_list([reviews(Lena) == Mystery, reviews(Lena) == Seasonings, reviews(Lena) == Wolves]) ::: (C)
is_accurate_list([reviews(Lena) == Retreat, reviews(Lena) == Seasonings, reviews(Lena) == Wolves]) ::: (D)
is_accurate_list([reviews(Lena) == Mystery, reviews(Lena) == Retreat, reviews(Lena) == Seasonings, reviews(Lena) == Wolves]) ::: (E)"
"# Context:
On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.

# Question:
Which one of the following students could be placed in any one of the three classes?

# Options:
A) Fred
B) Jan
C) Kathy
D) Laura
E) Mike","# Declarations
students = EnumSort([Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, Nick])
classes = EnumSort([Level1, Level2, Level3])
placed = Function([students] -> [classes])
# Constraints
Count([s:students], placed(s) == Level1) == 3 ::: The three highest scorers are placed in the level 1 class
Count([s:students], placed(s) == Level2) == 3 ::: The remaining three are placed in the level 2 class
Count([s:students], placed(s) == Level3) == 3 ::: The three lowest scorers are placed in the level 3 class
placed(Ida) != placed(Glen) ::: Ida scores higher than Glen
placed(Glen) != placed(Jan) ::: Glen scores higher than Jan
placed(Glen) != placed(Kathy) ::: Glen scores higher than Kathy
placed(Jan) != placed(Mike) ::: Jan scores higher than Mike
placed(Mike) != placed(Hilary) ::: Mike scores higher than Hilary
placed(Hilary) != placed(Nick) ::: Hilary scores higher than Nick
placed(Kathy) != placed(Fred) ::: Kathy scores higher than Fred
placed(Kathy) != placed(Laura) ::: Kathy scores higher than Laura
# Options
is_valid(Or(placed(Fred) == Level1, placed(Fred) == Level2, placed(Fred) == Level3)) ::: (A)
is_valid(Or(placed(Jan) == Level1, placed(Jan) == Level2, placed(Jan) == Level3)) ::: (B)
is_valid(Or(placed(Kathy) == Level1, placed(Kathy) == Level2, placed(Kathy) == Level3)) ::: (C)
is_valid(Or(placed(Laura) == Level1, placed(Laura) == Level2, placed(Laura) == Level3)) ::: (D)
is_valid(Or(placed(Mike) == Level1, placed(Mike) == Level2, placed(Mike) == Level3)) ::: (E)"
"# Context:
Three boys—Karl, Luis, and Miguel—and three girls—Rita, Sarah, and Tura—are giving a dance recital. Three dances—1, 2, and 3—are to be performed. Each dance involves three pairs of children, a boy and a girl partnering each other in each pair, according to the following conditions: Karl partners Sarah in either dance 1 or dance 2. Whoever partners Rita in dance 2 must partner Sarah in dance 3. No two children can partner each other in more than one dance.

# Question:
If Miguel partners Sarah in dance 1, which one of the following is a pair of children who must partner each other in dance 3?

# Options:
A) Karl and Rita
B) Karl and Tura
C) Luis and Rita
D) Luis and Tura
E) Miguel and Tura","# Declarations
boys = EnumSort([Karl, Luis, Miguel])
girls = EnumSort([Rita, Sarah, Tura])
dances = EnumSort([1, 2, 3])
partners = Function([boys, girls, dances] -> [bool])
# Constraints
ForAll([d:dances], And(Exists([b:boys], Exists([g:girls], partners(b, g, d))), Count([b:boys], Exists([g:girls], partners(b, g, d))) == 3)) ::: Each dance involves three pairs of children
Or(partners(Karl, Sarah, 1), partners(Karl, Sarah, 2)) ::: Karl partners Sarah in either dance 1 or dance 2
ForAll([b:boys], Implies(partners(b, Rita, 2), partners(b, Sarah, 3))) ::: Whoever partners Rita in dance 2 must partner Sarah in dance 3
ForAll([b:boys], ForAll([g:girls], Count([d:dances], partners(b, g, d)) <= 1)) ::: No two children can partner each other in more than one dance
partners(Miguel, Sarah, 1) ::: Miguel partners Sarah in dance 1
# Options
is_valid(And(partners(Karl, Rita, 3), partners(Karl, Tura, 3))) ::: (A)
is_valid(And(partners(Karl, Tura, 3), partners(Karl, Rita, 3))) ::: (B)
is_valid(And(partners(Luis, Rita, 3), partners(Luis, Tura, 3))) ::: (C)
is_valid(And(partners(Luis, Tura, 3), partners(Luis, Rita, 3))) ::: (D)
is_valid(And(partners(Miguel, Tura, 3), partners(Miguel, Rita, 3))) ::: (E)"
"# Context:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.

# Question:
If P is not selected to attend the retirement dinner, then exactly how many different groups of four are there each of which would be an acceptable selection?

# Options:
A) one
B) two
C) three
D) four
E) five","# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])
# Constraints
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected
Not(selected(P)) ::: P is not selected to attend the retirement dinner
Count([p:people], selected(p)) == 4 ::: Exactly four people will be selected
# Options
is_accurate_list([Count([p:people], selected(p)) == 4]) ::: (A)
is_accurate_list([Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4]) ::: (B)
is_accurate_list([Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4]) ::: (C)
is_accurate_list([Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4]) ::: (D)
is_accurate_list([Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4, Count([p:people], selected(p)) == 4]) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
Which one of the following could be true?

# Options:
A) W, X, and Z all respond to ferromycin.
B) W, X, and Z all respond to ganocyclene.
C) W and exactly one other organism respond to ganocyclene.
D) W responds to more of the antibiotics than X does.
E) More of the organisms respond to ferromycin than to ganocyclene.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: At least two but not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
# Options
is_sat(And(responds(W, ferromycin), responds(X, ferromycin), responds(Z, ferromycin))) ::: (A)
is_sat(And(responds(W, ganocyclene), responds(X, ganocyclene), responds(Z, ganocyclene))) ::: (B)
is_sat(And(responds(W, ganocyclene), Count([o:organisms], responds(o, ganocyclene)) == 2)) ::: (C)
is_sat(Count([a:antibiotics], responds(W, a)) > Count([a:antibiotics], responds(X, a))) ::: (D)
is_sat(Count([o:organisms], responds(o, ferromycin)) > Count([o:organisms], responds(o, ganocyclene))) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
If Karl does not review Seasonings, which one of the following must be true?

# Options:
A) Lena reviews Mystery.
B) Lena reviews Retreat.
C) Lena reviews Seasonings.
D) Frank and Hilda review Retreat.
E) Frank and Hilda review Seasonings.","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
ForAll([r:reviewers], Exists([m:movies], reviews(r) == m)) ::: each reviewer reviews exactly one movie
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Count([r:reviewers], reviews(r) == reviews(Lena)) == 2 ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
reviews(Karl) != Seasonings ::: Karl does not review Seasonings
# Options
is_valid(reviews(Lena) == Mystery) ::: (A)
is_valid(reviews(Lena) == Retreat) ::: (B)
is_valid(reviews(Lena) == Seasonings) ::: (C)
is_valid(And(reviews(Frank) == Retreat, reviews(Hilda) == Retreat)) ::: (D)
is_valid(And(reviews(Frank) == Seasonings, reviews(Hilda) == Seasonings)) ::: (E)"
"# Context:
A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.

# Question:
If light 5 is on, which one of the following could be true?

# Options:
A) Light 1 is off and light 6 is off.
B) Light 1 is on and light 7 is on.
C) Light 2 is off and light 4 is on.
D) Light 2 is off and light 6 is off.
E) Light 6 is on and light 7 is on.","# Declarations
lights = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
is_on = Function([lights] -> [bool])
# Constraints
ForAll([i:lights], Implies(And(i >= 1, i <= 6), Not(And(is_on(i), is_on(i+1), is_on(i+2))))) ::: At least one of any three consecutively numbered lights is off
is_on(8) ::: Light 8 is on
Implies(is_on(1), And(Not(is_on(2)), Not(is_on(7)))) ::: Neither light 2 nor light 7 is on when light 1 is on
Or(is_on(1), is_on(2), is_on(3)) ::: At least one of the three lights on each side is on
Or(is_on(3), is_on(4), is_on(5)) ::: At least one of the three lights on each side is on
Or(is_on(5), is_on(6), is_on(7)) ::: At least one of the three lights on each side is on
Or(is_on(7), is_on(8), is_on(1)) ::: At least one of the three lights on each side is on
Implies(And(is_on(1), Not(is_on(2)), Not(is_on(3))), is_on(2)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(And(is_on(3), Not(is_on(4)), Not(is_on(5))), is_on(4)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(And(is_on(5), Not(is_on(6)), Not(is_on(7))), is_on(6)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(And(is_on(7), Not(is_on(8)), Not(is_on(1))), is_on(8)) ::: If any side has exactly one of its three lights on, then that light is its center light
And(is_on(1), is_on(2)) ::: Two of the lights on the north side are on
is_on(5) ::: Light 5 is on
# Options
is_valid(And(Not(is_on(1)), Not(is_on(6)))) ::: (A)
is_valid(And(is_on(1), is_on(7))) ::: (B)
is_valid(And(Not(is_on(2)), is_on(4))) ::: (C)
is_valid(And(Not(is_on(2)), Not(is_on(6)))) ::: (D)
is_valid(And(is_on(6), is_on(7))) ::: (E)"
"# Context:
A florist is making three corsages from four types of flowers: gardenias, orchids, roses, and violets. Each of the corsages will contain exactly three flowers. The nine flowers used in the corsages must include at least one flower from each of the four types, and at least twice as many roses as orchids must be used. The corsages must also meet the following specifications: Corsage 1 must contain exactly two types of flowers. Corsage 2 must contain at least one rose. Corsage 3 must contain at least one gardenia but no orchids.

# Question:
If the greatest possible number of violets is used in the three corsages, the florist must use

# Options:
A) exactly one rose and exactly one gardenia
B) exactly one orchid and exactly four violets
C) exactly two orchids
D) exactly two roses
E) exactly six violets","# Declarations
flowers = EnumSort([gardenias, orchids, roses, violets])
corsages = EnumSort([Corsage1, Corsage2, Corsage3])
contains = Function([corsages, flowers] -> [bool])
# Constraints
ForAll([c:corsages], Count([f:flowers], contains(c, f)) == 3) ::: Each corsage will contain exactly three flowers
Exists([c:corsages], contains(c, gardenias)) ::: At least one gardenia must be used
Exists([c:corsages], contains(c, orchids)) ::: At least one orchid must be used
Exists([c:corsages], contains(c, roses)) ::: At least one rose must be used
Exists([c:corsages], contains(c, violets)) ::: At least one violet must be used
Count([f:flowers], contains(Corsage1, f)) == 2 ::: Corsage 1 must contain exactly two types of flowers
Exists([f:flowers], contains(Corsage2, roses)) ::: Corsage 2 must contain at least one rose
Exists([f:flowers], contains(Corsage3, gardenias)) ::: Corsage 3 must contain at least one gardenia
ForAll([f:flowers], Not(contains(Corsage3, orchids))) ::: Corsage 3 must contain no orchids
2 * Count([f:flowers], contains(Corsage2, orchids)) <= Count([f:flowers], contains(Corsage2, roses)) ::: At least twice as many roses as orchids must be used
# Options
is_valid(And(Count([c:corsages, f:flowers], contains(c, roses)) == 1, Count([c:corsages, f:flowers], contains(c, gardenias)) == 1)) ::: (A)
is_valid(And(Count([c:corsages, f:flowers], contains(c, orchids)) == 1, Count([c:corsages, f:flowers], contains(c, violets)) == 4)) ::: (B)
is_valid(Count([c:corsages, f:flowers], contains(c, orchids)) == 2) ::: (C)
is_valid(Count([c:corsages, f:flowers], contains(c, roses)) == 2) ::: (D)
is_valid(Count([c:corsages, f:flowers], contains(c, violets)) == 6) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
If Karl reviews the same movie as exactly one other reviewer, which one of the following is a complete and accurate list of the movies any one of which could be the movie that these two reviewers review?

# Options:
A) Mystery, Retreat
B) Mystery, Seasonings
C) Retreat, Seasonings
D) Mystery, Seasonings, Wolves
E) Retreat, Seasonings, Wolves","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Exists([r:reviewers], And(r != Lena, reviews(Lena) == reviews(r))) ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
Exists([r:reviewers], And(r != Karl, reviews(Karl) == reviews(r))) ::: Karl reviews the same movie as exactly one other reviewer
# Options
is_accurate_list([reviews(Karl) == Mystery, reviews(Karl) == Retreat]) ::: (A)
is_accurate_list([reviews(Karl) == Mystery, reviews(Karl) == Seasonings]) ::: (B)
is_accurate_list([reviews(Karl) == Retreat, reviews(Karl) == Seasonings]) ::: (C)
is_accurate_list([reviews(Karl) == Mystery, reviews(Karl) == Seasonings, reviews(Karl) == Wolves]) ::: (D)
is_accurate_list([reviews(Karl) == Retreat, reviews(Karl) == Seasonings, reviews(Karl) == Wolves]) ::: (E)"
"# Context:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.

# Question:
If M is not selected to attend the retirement dinner, the four people selected to attend must include which one of the following pairs of people?

# Options:
A) J and Q
B) K and L
C) K and P
D) L and P
E) N and Q","# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])
# Constraints
Count([p:people], selected(p)) == 4 ::: exactly four people will be selected
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected
Not(selected(M)) ::: M is not selected to attend the retirement dinner
# Options
is_accurate_list([selected(J), selected(Q)]) ::: (A)
is_accurate_list([selected(K), selected(L)]) ::: (B)
is_accurate_list([selected(K), selected(P)]) ::: (C)
is_accurate_list([selected(L), selected(P)]) ::: (D)
is_accurate_list([selected(N), selected(Q)]) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
If any of the organisms responds to two of the antibiotics, then which one of the following is true about such an organism?

# Options:
A) It must respond to ferromycin.
B) It must respond to ganocyclene.
C) It must respond to heptocillin.
D) It cannot respond to ferromycin.
E) It cannot respond to ganocyclene.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: At least two but not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
# Options
is_valid(ForAll([o:organisms], Implies(Count([a:antibiotics], responds(o, a)) == 2, responds(o, ferromycin)))) ::: (A)
is_valid(ForAll([o:organisms], Implies(Count([a:antibiotics], responds(o, a)) == 2, responds(o, ganocyclene)))) ::: (B)
is_valid(ForAll([o:organisms], Implies(Count([a:antibiotics], responds(o, a)) == 2, responds(o, heptocillin)))) ::: (C)
is_valid(ForAll([o:organisms], Implies(Count([a:antibiotics], responds(o, a)) == 2, Not(responds(o, ferromycin))))) ::: (D)
is_valid(ForAll([o:organisms], Implies(Count([a:antibiotics], responds(o, a)) == 2, Not(responds(o, ganocyclene))))) ::: (E)"
"# Context:
Three boys—Karl, Luis, and Miguel—and three girls—Rita, Sarah, and Tura—are giving a dance recital. Three dances—1, 2, and 3—are to be performed. Each dance involves three pairs of children, a boy and a girl partnering each other in each pair, according to the following conditions: Karl partners Sarah in either dance 1 or dance 2. Whoever partners Rita in dance 2 must partner Sarah in dance 3. No two children can partner each other in more than one dance.

# Question:
If Miguel partners Rita in dance 1, which one of the following must be true?

# Options:
A) Karl partners Rita in dance 2.
B) Karl partners Sarah in dance 3.
C) Karl partners Tura in dance 1.
D) Luis partners Rita in dance 2.
E) Luis partners Tura in dance 3.","# Declarations
boys = EnumSort([Karl, Luis, Miguel])
girls = EnumSort([Rita, Sarah, Tura])
dances = EnumSort([1, 2, 3])
partners = Function([boys, girls, dances] -> [bool])
# Constraints
ForAll([d:dances], Exists([b:boys, g:girls], partners(b, g, d))) ::: Each dance involves three pairs of children
ForAll([b:boys, g:girls], Count([d:dances], partners(b, g, d)) <= 1) ::: No two children can partner each other in more than one dance
Or(partners(Karl, Sarah, 1), partners(Karl, Sarah, 2)) ::: Karl partners Sarah in either dance 1 or dance 2
ForAll([b:boys], Implies(partners(b, Rita, 2), partners(b, Sarah, 3))) ::: Whoever partners Rita in dance 2 must partner Sarah in dance 3
partners(Miguel, Rita, 1) ::: Miguel partners Rita in dance 1
# Options
is_valid(partners(Karl, Rita, 2)) ::: (A)
is_valid(partners(Karl, Sarah, 3)) ::: (B)
is_valid(partners(Karl, Tura, 1)) ::: (C)
is_valid(partners(Luis, Rita, 2)) ::: (D)
is_valid(partners(Luis, Tura, 3)) ::: (E)"
"# Context:
Three boys—Karl, Luis, and Miguel—and three girls—Rita, Sarah, and Tura—are giving a dance recital. Three dances—1, 2, and 3—are to be performed. Each dance involves three pairs of children, a boy and a girl partnering each other in each pair, according to the following conditions: Karl partners Sarah in either dance 1 or dance 2. Whoever partners Rita in dance 2 must partner Sarah in dance 3. No two children can partner each other in more than one dance.

# Question:
If Miguel partners Rita in dance 2, which one of the following could be true?

# Options:
A) Karl partners Tura in dance 1.
B) Luis partners Sarah in dance 2.
C) Luis partners Sarah in dance 3.
D) Miguel partners Sarah in dance 1.
E) Miguel partners Tura in dance 3.","# Declarations
boys = EnumSort([Karl, Luis, Miguel])
girls = EnumSort([Rita, Sarah, Tura])
dances = EnumSort([1, 2, 3])
partners = Function([boys, girls, dances] -> [bool])
# Constraints
ForAll([d:dances], And(Exists([b:boys], Exists([g:girls], partners(b, g, d))), Count([b:boys], Exists([g:girls], partners(b, g, d))) == 3)) ::: Each dance involves three pairs of children
Or(partners(Karl, Sarah, 1), partners(Karl, Sarah, 2)) ::: Karl partners Sarah in either dance 1 or dance 2
ForAll([b:boys], Implies(partners(b, Rita, 2), partners(b, Sarah, 3))) ::: Whoever partners Rita in dance 2 must partner Sarah in dance 3
ForAll([b:boys], ForAll([g:girls], Count([d:dances], partners(b, g, d)) <= 1)) ::: No two children can partner each other in more than one dance
partners(Miguel, Rita, 2) ::: Miguel partners Rita in dance 2
# Options
is_valid(partners(Karl, Tura, 1)) ::: (A)
is_valid(partners(Luis, Sarah, 2)) ::: (B)
is_valid(partners(Luis, Sarah, 3)) ::: (C)
is_valid(partners(Miguel, Sarah, 1)) ::: (D)
is_valid(partners(Miguel, Tura, 3)) ::: (E)"
"# Context:
On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.

# Question:
Which one of the following students could be in the level 2 class but cannot be in the level 3 class?

# Options:
A) Fred
B) Glen
C) Jan
D) Kathy
E) Nick","# Declarations
students = EnumSort([Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, Nick])
classes = EnumSort([level1, level2, level3])
assigned = Function([students] -> [classes])
# Constraints
ForAll([c:classes], Count([s:students], assigned(s) == c) == 3) ::: Each class has exactly three students
Count([s:students], assigned(s) == level1) == 3 ::: The three highest scorers are placed in the level 1 class
Count([s:students], assigned(s) == level3) == 3 ::: The three lowest scorers are placed in the level 3 class
Count([s:students], assigned(s) == level2) == 3 ::: The remaining three are placed in the level 2 class
assigned(Ida) != level3 ::: Ida scores higher than Glen
assigned(Glen) != level3 ::: Glen scores higher than both Jan and Kathy
assigned(Jan) != level3 ::: Jan scores higher than Mike
assigned(Mike) != level3 ::: Mike scores higher than Hilary
assigned(Hilary) != level3 ::: Hilary scores higher than Nick
assigned(Kathy) != level3 ::: Kathy scores higher than both Fred and Laura
# Options
is_valid(And(assigned(Fred) == level2, assigned(Fred) != level3)) ::: (A)
is_valid(And(assigned(Glen) == level2, assigned(Glen) != level3)) ::: (B)
is_valid(And(assigned(Jan) == level2, assigned(Jan) != level3)) ::: (C)
is_valid(And(assigned(Kathy) == level2, assigned(Kathy) != level3)) ::: (D)
is_valid(And(assigned(Nick) == level2, assigned(Nick) != level3)) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
Lena can review any of the following EXCEPT

# Options:
A) Mystery with George
B) Mystery with Karl
C) Retreat with Karl
D) Seasonings with Karl
E) Wolves with Jackie","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
ForAll([r:reviewers], Exists([m:movies], reviews(r) == m)) ::: each reviewer reviews exactly one movie
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Count([r:reviewers], reviews(r) == reviews(Lena)) == 2 ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
# Options
is_unsat(And(reviews(Lena) == Mystery, reviews(George) == Mystery)) ::: (A)
is_unsat(And(reviews(Lena) == Mystery, reviews(Karl) == Mystery)) ::: (B)
is_unsat(And(reviews(Lena) == Retreat, reviews(Karl) == Retreat)) ::: (C)
is_unsat(And(reviews(Lena) == Seasonings, reviews(Karl) == Seasonings)) ::: (D)
is_unsat(And(reviews(Lena) == Wolves, reviews(Jackie) == Wolves)) ::: (E)"
"# Context:
Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.

# Question:
Which one of the following statements must be true?

# Options:
A) One of the men orders pork chops or veal cutlet.
B) One of the men orders swordfish or veal cutlet.
C) Two of the women order tilefish.
D) None of the men orders a fish entree.
E) Exactly one of the women orders a fish entree.","# Declarations
people = EnumSort([John, Kate, Lewis, Marie, Nat, Olive])
entrees = EnumSort([pork_chops, roast_beef, swordfish, tilefish, veal_cutlet])
gender = EnumSort([male, female])
order = Function([people] -> [entrees])
person_gender = Function([people] -> [gender])
# Constraints
ForAll([p:people], Exists([e:entrees], order(p) == e)) ::: Each person orders one and only one entree.
Not(order(John) == order(Kate)) ::: John and Kate do not order the same entree.
Not(order(Lewis) == order(Marie)) ::: Lewis and Marie do not order the same entree.
Not(order(Nat) == order(Olive)) ::: Nat and Olive do not order the same entree.
Not(order(John) == order(Lewis)) ::: John and Lewis do not order the same entree.
Not(order(John) == order(Nat)) ::: John and Nat do not order the same entree.
Not(order(Lewis) == order(Nat)) ::: Lewis and Nat do not order the same entree.
order(Marie) == swordfish ::: Marie orders swordfish.
Not(order(John) == swordfish) ::: John does not order swordfish.
Not(order(John) == tilefish) ::: John does not order tilefish.
Not(order(Nat) == swordfish) ::: Nat does not order swordfish.
Not(order(Nat) == tilefish) ::: Nat does not order tilefish.
order(Olive) == roast_beef ::: Olive orders roast beef.
# Options
is_valid(Or(order(John) == pork_chops, order(John) == veal_cutlet, order(Lewis) == pork_chops, order(Lewis) == veal_cutlet, order(Nat) == pork_chops, order(Nat) == veal_cutlet)) ::: (A)
is_valid(Or(order(John) == swordfish, order(John) == veal_cutlet, order(Lewis) == swordfish, order(Lewis) == veal_cutlet, order(Nat) == swordfish, order(Nat) == veal_cutlet)) ::: (B)
is_valid(Count([w:people], And(person_gender(w) == female, order(w) == tilefish)) == 2) ::: (C)
is_valid(And(Not(order(John) == swordfish), Not(order(John) == tilefish), Not(order(Lewis) == swordfish), Not(order(Lewis) == tilefish), Not(order(Nat) == swordfish), Not(order(Nat) == tilefish))) ::: (D)
is_valid(Count([w:people], And(person_gender(w) == female, Or(order(w) == swordfish, order(w) == tilefish))) == 1) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
Each of the following can be true EXCEPT:

# Options:
A) W responds to heptocillin.
B) X responds to ganocyclene.
C) X responds to heptocillin.
D) Y responds to heptocillin.
E) Z responds to ganocyclene.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: Not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
# Options
is_unsat(responds(W, heptocillin)) ::: (A)
is_unsat(responds(X, ganocyclene)) ::: (B)
is_unsat(responds(X, heptocillin)) ::: (C)
is_unsat(responds(Y, heptocillin)) ::: (D)
is_unsat(responds(Z, ganocyclene)) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
If Lena reviews Seasonings, which one of the following must be true?

# Options:
A) Hilda reviews Retreat.
B) Jackie reviews Seasonings.
C) Karl reviews Mystery.
D) Karl reviews Retreat.
E) Karl reviews Wolves.","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
ForAll([r:reviewers], Exists([m:movies], reviews(r) == m)) ::: each reviewer reviews exactly one movie
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Count([r:reviewers], reviews(r) == reviews(Lena)) == 2 ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
reviews(Lena) == Seasonings ::: Lena reviews Seasonings
# Options
is_valid(reviews(Hilda) == Retreat) ::: (A)
is_valid(reviews(Jackie) == Seasonings) ::: (B)
is_valid(reviews(Karl) == Mystery) ::: (C)
is_valid(reviews(Karl) == Retreat) ::: (D)
is_valid(reviews(Karl) == Wolves) ::: (E)"
"# Context:
A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.

# Question:
Which one of the following statements must be true?

# Options:
A) If light 2 is on, then light 6 is off.
B) If light 3 is on, then light 2 is on.
C) If light 4 is on, then light 3 is off.
D) If light 5 is off, then light 4 is on.
E) If light 6 is off, then light 1 is on.","# Declarations
lights = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
is_on = Function([lights] -> [bool])
# Constraints
ForAll([i:lights], Implies(And(i >= 1, i <= 6), Not(And(is_on(i), is_on(i+1), is_on(i+2))))) ::: At least one of any three consecutively numbered lights is off
is_on(8) ::: Light 8 is on
Implies(is_on(1), And(Not(is_on(2)), Not(is_on(7)))) ::: Neither light 2 nor light 7 is on when light 1 is on
Or(is_on(1), is_on(2), is_on(3)) ::: At least one of the three lights on each side is on
Or(is_on(3), is_on(4), is_on(5)) ::: At least one of the three lights on each side is on
Or(is_on(5), is_on(6), is_on(7)) ::: At least one of the three lights on each side is on
Or(is_on(7), is_on(8), is_on(1)) ::: At least one of the three lights on each side is on
Implies(Count([i:lights], And(i >= 1, i <= 3, is_on(i))) == 1, is_on(2)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(Count([i:lights], And(i >= 3, i <= 5, is_on(i))) == 1, is_on(4)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(Count([i:lights], And(i >= 5, i <= 7, is_on(i))) == 1, is_on(6)) ::: If any side has exactly one of its three lights on, then that light is its center light
Implies(Count([i:lights], And(i >= 7, i <= 8, Or(i == 1, i == 7), is_on(i))) == 1, is_on(8)) ::: If any side has exactly one of its three lights on, then that light is its center light
Count([i:lights], And(i >= 1, i <= 3, is_on(i))) == 2 ::: Two of the lights on the north side are on
# Options
is_valid(Implies(is_on(2), Not(is_on(6)))) ::: (A)
is_valid(Implies(is_on(3), is_on(2))) ::: (B)
is_valid(Implies(is_on(4), Not(is_on(3)))) ::: (C)
is_valid(Implies(Not(is_on(5)), is_on(4))) ::: (D)
is_valid(Implies(Not(is_on(6)), is_on(1))) ::: (E)"
"# Context:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.

# Question:
Which one of the following is a pair of people who CANNOT both be selected to attend the retirement dinner?

# Options:
A) J and N
B) J and Q
C) K and L
D) K and N
E) N and Q","# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])
# Constraints
Count([p:people], selected(p)) == 4 ::: exactly four people will be selected
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected
# Options
is_unsat(And(selected(J), selected(N))) ::: (A)
is_unsat(And(selected(J), selected(Q))) ::: (B)
is_unsat(And(selected(K), selected(L))) ::: (C)
is_unsat(And(selected(K), selected(N))) ::: (D)
is_unsat(And(selected(N), selected(Q))) ::: (E)"
"# Context:
Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.

# Question:
Which one of the following can be true?

# Options:
A) Frank and George review Mystery.
B) Frank and Lena review Wolves.
C) George and Jackie review Mystery.
D) Karl reviews Wolves and Lena reviews Mystery.
E) Lena reviews Retreat and Frank reviews Seasonings.","# Declarations
reviewers = EnumSort([Frank, George, Hilda, Jackie, Karl, Lena])
movies = EnumSort([Mystery, Retreat, Seasonings, Wolves])
reviews = Function([reviewers] -> [movies])
# Constraints
ForAll([m:movies], Exists([r:reviewers], reviews(r) == m)) ::: each movie is reviewed by at least one of the six reviewers
reviews(Hilda) == reviews(Frank) ::: Hilda reviews the same movie as Frank
Count([r:reviewers], reviews(r) == reviews(Lena)) == 1 ::: Lena reviews the same movie as exactly one other reviewer
reviews(George) == Mystery ::: George reviews Mystery
Or(reviews(Jackie) == Mystery, reviews(Jackie) == Wolves) ::: Jackie reviews either Mystery or else Wolves
reviews(Hilda) != Wolves ::: Hilda does not review Wolves
# Options
is_sat(And(reviews(Frank) == Mystery, reviews(George) == Mystery)) ::: (A)
is_sat(And(reviews(Frank) == Wolves, reviews(Lena) == Wolves)) ::: (B)
is_sat(And(reviews(George) == Mystery, reviews(Jackie) == Mystery)) ::: (C)
is_sat(And(reviews(Karl) == Wolves, reviews(Lena) == Mystery)) ::: (D)
is_sat(And(reviews(Lena) == Retreat, reviews(Frank) == Seasonings)) ::: (E)"
"# Context:
Three boys—Karl, Luis, and Miguel—and three girls—Rita, Sarah, and Tura—are giving a dance recital. Three dances—1, 2, and 3—are to be performed. Each dance involves three pairs of children, a boy and a girl partnering each other in each pair, according to the following conditions: Karl partners Sarah in either dance 1 or dance 2. Whoever partners Rita in dance 2 must partner Sarah in dance 3. No two children can partner each other in more than one dance.

# Question:
If Luis partners Sarah in dance 2, which one of the following is a pair of children who must partner each other in dance 1?

# Options:
A) Karl and Rita
B) Karl and Tura
C) Luis and Rita
D) Luis and Tura
E) Miguel and Rita","# Declarations
boys = EnumSort([Karl, Luis, Miguel])
girls = EnumSort([Rita, Sarah, Tura])
dances = EnumSort([1, 2, 3])
partners = Function([boys, girls, dances] -> [bool])
# Constraints
ForAll([d:dances], And(Exists([b:boys], Exists([g:girls], partners(b, g, d))), Count([b:boys], Exists([g:girls], partners(b, g, d))) == 3)) ::: Each dance involves three pairs of children
Or(partners(Karl, Sarah, 1), partners(Karl, Sarah, 2)) ::: Karl partners Sarah in either dance 1 or dance 2
ForAll([b:boys], Implies(partners(b, Rita, 2), partners(b, Sarah, 3))) ::: Whoever partners Rita in dance 2 must partner Sarah in dance 3
ForAll([b:boys], ForAll([g:girls], Count([d:dances], partners(b, g, d)) <= 1)) ::: No two children can partner each other in more than one dance
partners(Luis, Sarah, 2) ::: Luis partners Sarah in dance 2
# Options
is_valid(And(partners(Karl, Rita, 1), Not(partners(Karl, Rita, 2)), Not(partners(Karl, Rita, 3)))) ::: (A)
is_valid(And(partners(Karl, Tura, 1), Not(partners(Karl, Tura, 2)), Not(partners(Karl, Tura, 3)))) ::: (B)
is_valid(And(partners(Luis, Rita, 1), Not(partners(Luis, Rita, 2)), Not(partners(Luis, Rita, 3)))) ::: (C)
is_valid(And(partners(Luis, Tura, 1), Not(partners(Luis, Tura, 2)), Not(partners(Luis, Tura, 3)))) ::: (D)
is_valid(And(partners(Miguel, Rita, 1), Not(partners(Miguel, Rita, 2)), Not(partners(Miguel, Rita, 3)))) ::: (E)"
"# Context:
Six cities are located within the numbered areas as follows: Within the six-city area there are exactly four hospitals, two jails, and two universities. These eight institutions are located as follows: No institution is in more than one of the cities. None of the cities contains more than one jail, and none contains more than one university. None of the cities contains both a jail and a university. Each jail is located in a city that contains at least one hospital. The universities are located in two cities that do not share a common boundary. City 3 contains a university, and city 6 contains a jail.

# Question:
Which one of the following is a complete and accurate list of the cities any one of which could contain the jail that is not in city 6?

# Options:
A) 1, 4
B) 2, 4
C) 4, 5
D) 1, 4, 5
E) 1, 2, 4, 5","# Declarations
cities = EnumSort([1, 2, 3, 4, 5, 6])
institutions = EnumSort([hospital, jail, university])
located = Function([institutions, cities] -> [bool])
# Constraints
Count([c:cities], located(jail, c)) == 2 ::: There are exactly two jails
Count([c:cities], located(university, c)) == 2 ::: There are exactly two universities
Count([c:cities], located(hospital, c)) == 4 ::: There are exactly four hospitals
ForAll([c:cities], Implies(located(jail, c), Count([i:institutions], located(i, c)) == 1)) ::: No city contains more than one institution
ForAll([c:cities], Implies(located(university, c), Count([i:institutions], located(i, c)) == 1)) ::: No city contains more than one institution
ForAll([c:cities], Not(And(located(jail, c), located(university, c)))) ::: No city contains both a jail and a university
ForAll([c:cities], Implies(located(jail, c), Exists([c1:cities], And(c1 != c, located(hospital, c1))))) ::: Each jail is located in a city that contains at least one hospital
located(university, 3) ::: City 3 contains a university
located(jail, 6) ::: City 6 contains a jail
ForAll([c:cities], Implies(located(university, c), ForAll([c1:cities], Implies(located(university, c1), c != c1)))) ::: The universities are located in two cities that do not share a common boundary
# Options
is_accurate_list([located(jail, 1), located(jail, 4)]) ::: (A)
is_accurate_list([located(jail, 2), located(jail, 4)]) ::: (B)
is_accurate_list([located(jail, 4), located(jail, 5)]) ::: (C)
is_accurate_list([located(jail, 1), located(jail, 4), located(jail, 5)]) ::: (D)
is_accurate_list([located(jail, 1), located(jail, 2), located(jail, 4), located(jail, 5)]) ::: (E)"
"# Context:
Seven children are to be seated in seven chairs arranged in a row that runs from west to east. All seven children will face north. Four of the children are boys: Frank, Harry, Ivan, and Joel. Three are girls: Ruby, Sylvia, and Thelma. The children are assigned to chairs according to the following conditions: Exactly one child sits in each chair. No boy sits next to another boy. Ivan sits next to and east of the fourth child in the row. Sylvia sits east of Ivan. Frank sits next to Ruby.

# Question:
What is the maximum possible number of different pairs of chairs in which Frank and Ruby could sit?

# Options:
A) one
B) two
C) three
D) four
E) five","# Declarations
children = EnumSort([Frank, Harry, Ivan, Joel, Ruby, Sylvia, Thelma])
chairs = EnumSort([chair1, chair2, chair3, chair4, chair5, chair6, chair7])
seated = Function([children] -> [chairs])
# Constraints
ForAll([c:children], Exists([ch:chairs], seated(c) == ch)) ::: Exactly one child sits in each chair
ForAll([c1:children, c2:children], Implies(And(c1 != c2, Or(seated(c1) == chair1, seated(c1) == chair7)), Not(And(seated(c2) == chair1, seated(c2) == chair7)))) ::: No boy sits next to another boy
seated(Ivan) == chair5 ::: Ivan sits next to and east of the fourth child in the row
seated(Sylvia) == chair6 ::: Sylvia sits east of Ivan
Or(seated(Frank) == chair4, seated(Frank) == chair6) ::: Frank sits next to Ruby
# Options
is_valid(Count([ch1:chairs, ch2:chairs], And(seated(Frank) == ch1, seated(Ruby) == ch2)) == 1) ::: (A)
is_valid(Count([ch1:chairs, ch2:chairs], And(seated(Frank) == ch1, seated(Ruby) == ch2)) == 2) ::: (B)
is_valid(Count([ch1:chairs, ch2:chairs], And(seated(Frank) == ch1, seated(Ruby) == ch2)) == 3) ::: (C)
is_valid(Count([ch1:chairs, ch2:chairs], And(seated(Frank) == ch1, seated(Ruby) == ch2)) == 4) ::: (D)
is_valid(Count([ch1:chairs, ch2:chairs], And(seated(Frank) == ch1, seated(Ruby) == ch2)) == 5) ::: (E)"
"# Context:
On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.

# Question:
Which one of the following pairs of students cannot be in the same class as Fred?

# Options:
A) Hilary and Nick
B) Jan and Laura
C) Kathy and Laura
D) Jan and Mike
E) Laura and Mike","# Declarations
students = EnumSort([Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, Nick])
classes = EnumSort([level1, level2, level3])
assigned = Function([students] -> [classes])
# Constraints
ForAll([c:classes], Count([s:students], assigned(s) == c) == 3) ::: Each class has exactly three students
Count([s:students], assigned(s) == level1) == 3 ::: The three highest scorers are placed in the level 1 class
Count([s:students], assigned(s) == level3) == 3 ::: The three lowest scorers are placed in the level 3 class
Count([s:students], assigned(s) == level2) == 3 ::: The remaining three are placed in the level 2 class
assigned(Ida) != assigned(Glen) ::: Ida scores higher than Glen
assigned(Glen) != assigned(Jan) ::: Glen scores higher than Jan
assigned(Glen) != assigned(Kathy) ::: Glen scores higher than Kathy
assigned(Jan) != assigned(Mike) ::: Jan scores higher than Mike
assigned(Mike) != assigned(Hilary) ::: Mike scores higher than Hilary
assigned(Hilary) != assigned(Nick) ::: Hilary scores higher than Nick
assigned(Kathy) != assigned(Fred) ::: Kathy scores higher than Fred
assigned(Kathy) != assigned(Laura) ::: Kathy scores higher than Laura
# Options
is_unsat(And(assigned(Fred) == assigned(Hilary), assigned(Fred) == assigned(Nick))) ::: (A)
is_unsat(And(assigned(Fred) == assigned(Jan), assigned(Fred) == assigned(Laura))) ::: (B)
is_unsat(And(assigned(Fred) == assigned(Kathy), assigned(Fred) == assigned(Laura))) ::: (C)
is_unsat(And(assigned(Fred) == assigned(Jan), assigned(Fred) == assigned(Mike))) ::: (D)
is_unsat(And(assigned(Fred) == assigned(Laura), assigned(Fred) == assigned(Mike))) ::: (E)"
"# Context:
On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.

# Question:
How many different combinations of students could form the level 1 class?

# Options:
A) one
B) two
C) three
D) four
E) six","# Declarations
students = EnumSort([Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, Nick])
classes = EnumSort([Level1, Level2, Level3])
assigned = Function([students] -> [classes])
# Constraints
ForAll([c:classes], Count([s:students], assigned(s) == c) == 3) ::: Each class has exactly three students
ForAll([s:students], Exists([c:classes], assigned(s) == c)) ::: Each student is placed in exactly one class
assigned(Ida) == Level1 ::: Ida scores higher than Glen
assigned(Glen) == Level1 ::: Glen scores higher than both Jan and Kathy
assigned(Jan) == Level2 ::: Jan scores higher than Mike
assigned(Mike) == Level2 ::: Mike scores higher than Hilary
assigned(Hilary) == Level2 ::: Hilary scores higher than Nick
assigned(Kathy) == Level3 ::: Kathy scores higher than both Fred and Laura
assigned(Fred) == Level3 ::: Fred is in Level 3
assigned(Laura) == Level3 ::: Laura is in Level 3
assigned(Nick) == Level3 ::: Nick is in Level 3
# Options
is_accurate_list([Count([s:students], assigned(s) == Level1) == 1]) ::: (A)
is_accurate_list([Count([s:students], assigned(s) == Level1) == 2]) ::: (B)
is_accurate_list([Count([s:students], assigned(s) == Level1) == 3]) ::: (C)
is_accurate_list([Count([s:students], assigned(s) == Level1) == 4]) ::: (D)
is_accurate_list([Count([s:students], assigned(s) == Level1) == 6]) ::: (E)"
"# Context:
The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.

# Question:
If X does not respond to ferromycin, then which one of the following must be true?

# Options:
A) W responds to ganocyclene.
B) X responds to ganocyclene.
C) X responds to heptocillin.
D) Z responds to ferromycin.
E) Z responds to heptocillin.","# Declarations
organisms = EnumSort([W, X, Y, Z])
antibiotics = EnumSort([ferromycin, ganocyclene, heptocillin])
responds = Function([organisms, antibiotics] -> [bool])
# Constraints
ForAll([o:organisms], Exists([a:antibiotics], responds(o, a))) ::: Each of the organisms responds to at least one of the antibiotics
ForAll([o:organisms], Not(And(responds(o, ferromycin), responds(o, ganocyclene), responds(o, heptocillin)))) ::: No organism responds to all three antibiotics
Count([o:organisms], responds(o, ferromycin)) >= 2 ::: At least two but not all four of the organisms respond to ferromycin
Count([o:organisms], responds(o, ferromycin)) < 4 ::: Not all four of the organisms respond to ferromycin
ForAll([a:antibiotics], Implies(responds(W, a), responds(X, a))) ::: If W responds to any antibiotic, then X responds to that antibiotic
ForAll([o:organisms], Implies(responds(o, ferromycin), responds(o, ganocyclene))) ::: If an organism responds to ferromycin, then it responds to ganocyclene
responds(Y, ferromycin) ::: Y responds to ferromycin
Not(responds(X, ferromycin)) ::: X does not respond to ferromycin
# Options
is_valid(responds(W, ganocyclene)) ::: (A)
is_valid(responds(X, ganocyclene)) ::: (B)
is_valid(responds(X, heptocillin)) ::: (C)
is_valid(responds(Z, ferromycin)) ::: (D)
is_valid(responds(Z, heptocillin)) ::: (E)"
"# Context:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.

# Question:
There is only one acceptable group of four that can be selected to attend the retirement dinner if which one of the following pairs of people is selected?

# Options:
A) J and L
B) K and M
C) L and N
D) L and Q
E) M and Q","# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])
# Constraints
Count([p:people], selected(p)) == 4 ::: exactly four people will be selected
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected
# Options
is_accurate_list([selected(J), selected(L)]) ::: (A)
is_accurate_list([selected(K), selected(M)]) ::: (B)
is_accurate_list([selected(L), selected(N)]) ::: (C)
is_accurate_list([selected(L), selected(Q)]) ::: (D)
is_accurate_list([selected(M), selected(Q)]) ::: (E)"
"# Context:
Seven children are to be seated in seven chairs arranged in a row that runs from west to east. All seven children will face north. Four of the children are boys: Frank, Harry, Ivan, and Joel. Three are girls: Ruby, Sylvia, and Thelma. The children are assigned to chairs according to the following conditions: Exactly one child sits in each chair. No boy sits next to another boy. Ivan sits next to and east of the fourth child in the row. Sylvia sits east of Ivan. Frank sits next to Ruby.

# Question:
If Frank sits east of Ruby, which one of the following pairs of children CANNOT sit next to each other?

# Options:
A) Frank and Thelma
B) Harry and Ruby
C) Harry and Sylvia
D) Ivan and Ruby
E) Joel and Ruby","# Declarations
children = EnumSort([Frank, Harry, Ivan, Joel, Ruby, Sylvia, Thelma])
chairs = EnumSort([chair1, chair2, chair3, chair4, chair5, chair6, chair7])
seated = Function([children] -> [chairs])
# Constraints
ForAll([c:children], Exists([ch:chairs], seated(c) == ch)) ::: Exactly one child sits in each chair
ForAll([c1:children, c2:children], Implies(And(c1 != c2, Or(seated(c1) == chair1, seated(c1) == chair7)), Not(Or(seated(c2) == chair2, seated(c2) == chair6)))) ::: No boy sits next to another boy
seated(Ivan) == chair5 ::: Ivan sits next to and east of the fourth child in the row
seated(Sylvia) == chair6 ::: Sylvia sits east of Ivan
seated(Frank) == chair2 ::: Frank sits next to Ruby
seated(Ruby) == chair1 ::: Frank sits east of Ruby
# Options
is_unsat(And(seated(Frank) == chair2, seated(Thelma) == chair3)) ::: (A)
is_unsat(And(seated(Harry) == chair2, seated(Ruby) == chair1)) ::: (B)
is_unsat(And(seated(Harry) == chair2, seated(Sylvia) == chair3)) ::: (C)
is_unsat(And(seated(Ivan) == chair5, seated(Ruby) == chair4)) ::: (D)
is_unsat(And(seated(Joel) == chair2, seated(Ruby) == chair1)) ::: (E)"
"# Context:
J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.

# Question:
If one segment of the path directly connects chalets K and N, then the two chalets in which one of the following pairs must be directly connected to each other by a segment?

# Options:
A) J and K
B) K and O
C) L and O
D) M and N
E) N and O","# Declarations
chalets = EnumSort([J, K, L, M, N, O])
connected = Function([chalets, chalets] -> [bool])
# Constraints
ForAll([c1:chalets, c2:chalets], connected(c1, c2) == connected(c2, c1)) ::: The path is composed of five straight segments, each of which directly connects exactly two of the chalets.
ForAll([c:chalets], Exists([c1:chalets, c2:chalets], And(connected(c, c1), connected(c, c2), c1 != c2))) ::: Each chalet is directly connected by a segment of the path to another chalet.
ForAll([c:chalets], Count([c1:chalets], connected(c, c1)) <= 2) ::: No chalet is directly connected by segments of the path to more than two other chalets.
connected(J, M) ::: J is directly opposite M.
connected(K, N) ::: K is directly opposite N.
connected(L, O) ::: L is directly opposite O.
connected(J, N) ::: One segment of the path directly connects chalets J and N.
connected(K, L) ::: Another segment directly connects chalets K and L.
# Options
is_valid(connected(J, K)) ::: (A)
is_valid(connected(K, O)) ::: (B)
is_valid(connected(L, O)) ::: (C)
is_valid(connected(M, N)) ::: (D)
is_valid(connected(N, O)) ::: (E)"
"# Context:
At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.

# Question:
Which one of the following statements must be true?

# Options:
A) There are production models on floor 1.
B) There are research models on floor 1.
C) There are production models on floor 2.
D) There are production models on floor 3.
E) There are research models on floor 3.","# Declarations
cars = EnumSort([car1, car2, car3, car4, car5, car6])
floors = EnumSort([floor1, floor2, floor3])
car_types = EnumSort([family, sports])
car_conditions = EnumSort([new, used])
car_models = EnumSort([production, research])
display_floor = Function([cars] -> [floors])
car_type = Function([cars] -> [car_types])
car_condition = Function([cars] -> [car_conditions])
car_model = Function([cars] -> [car_models])
# Constraints
ForAll([c:cars], Or(And(car_type(c) == family, display_floor(c) == floor1), And(car_type(c) == sports, display_floor(c) != floor1))) ::: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car.
ForAll([c:cars], Not(And(car_condition(c) == used, car_model(c) == research))) ::: The exhibition includes no used research models.
ForAll([c:cars], Not(And(car_model(c) == research, car_type(c) == sports))) ::: The exhibition includes no research models that are sports cars.
Exists([c:cars], And(car_condition(c) == new, display_floor(c) == floor1)) ::: There are new cars on floor 1.
Exists([c:cars], And(car_condition(c) == used, display_floor(c) == floor3)) ::: There are used cars on floor 3.
# Options
is_valid(Exists([c:cars], And(car_model(c) == production, display_floor(c) == floor1))) ::: (A) There are production models on floor 1.
is_valid(Exists([c:cars], And(car_model(c) == research, display_floor(c) == floor1))) ::: (B) There are research models on floor 1.
is_valid(Exists([c:cars], And(car_model(c) == production, display_floor(c) == floor2))) ::: (C) There are production models on floor 2.
is_valid(Exists([c:cars], And(car_model(c) == production, display_floor(c) == floor3))) ::: (D) There are production models on floor 3.
is_valid(Exists([c:cars], And(car_model(c) == research, display_floor(c) == floor3))) ::: (E) There are research models on floor 3."
"# Context:
From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.

# Question:
Among the people selected to attend the retirement dinner there must be

# Options:
A) K or Q or both
B) L or M or both
C) N or M or both
D) N or Q or both
E) P or Q or both","# Declarations
people = EnumSort([J, K, L, M, N, P, Q])
selected = Function([people] -> [bool])
# Constraints
Count([p:people], selected(p)) == 4 ::: exactly four people will be selected
Or(selected(J), selected(K)) ::: Either J or K must be selected
Not(And(selected(J), selected(K))) ::: J and K cannot both be selected
Or(selected(N), selected(P)) ::: Either N or P must be selected
Not(And(selected(N), selected(P))) ::: N and P cannot both be selected
Implies(selected(N), selected(L)) ::: N cannot be selected unless L is selected
Implies(selected(Q), selected(K)) ::: Q cannot be selected unless K is selected
# Options
is_valid(Or(selected(K), selected(Q))) ::: (A)
is_valid(Or(selected(L), selected(M))) ::: (B)
is_valid(Or(selected(N), selected(M))) ::: (C)
is_valid(Or(selected(N), selected(Q))) ::: (D)
is_valid(Or(selected(P), selected(Q))) ::: (E)"
"# Context:
A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.

# Question:
If Nassar's salary is the same as that of one other partner of the firm, which one of the following must be false?

# Options:
A) Inman's salary is less than Lopez's.
B) Jacoby's salary is less than Lopez's.
C) Lopez's salary is less than Fox's.
D) Lopez's salary is less than Hae's.
E) Nassar's salary is less than Glassen's.","# Declarations
partners = EnumSort([Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, Nassar])
salary = Function([partners] -> [int])
# Constraints
ForAll([p:partners], salary(p) > 0) ::: All partners have a positive salary.
salary(Kohn) > salary(Inman) ::: Kohn's salary is greater than Inman's.
salary(Kohn) > salary(Lopez) ::: Kohn's salary is greater than Lopez's.
salary(Lopez) > salary(Nassar) ::: Lopez's salary is greater than Nassar's.
salary(Inman) > salary(Fox) ::: Inman's salary is greater than Fox's.
salary(Fox) > salary(Malloy) ::: Fox's salary is greater than Malloy's.
salary(Malloy) > salary(Glassen) ::: Malloy's salary is greater than Glassen's.
salary(Glassen) > salary(Jacoby) ::: Glassen's salary is greater than Jacoby's.
salary(Jacoby) > salary(Hae) ::: Jacoby's salary is greater than Hae's.
Exists([p:partners], And(salary(Nassar) == salary(p), Not(Nassar == p))) ::: Nassar's salary is the same as that of one other partner of the firm.
# Options
is_unsat(salary(Inman) < salary(Lopez)) ::: (A) Inman's salary is less than Lopez's.
is_unsat(salary(Jacoby) < salary(Lopez)) ::: (B) Jacoby's salary is less than Lopez's.
is_unsat(salary(Lopez) < salary(Fox)) ::: (C) Lopez's salary is less than Fox's.
is_unsat(salary(Lopez) < salary(Hae)) ::: (D) Lopez's salary is less than Hae's.
is_unsat(salary(Nassar) < salary(Glassen)) ::: (E) Nassar's salary is less than Glassen's."
"# Context:
A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.

# Question:
Which one of the following statements could be true?

# Options:
A) Both the line 1 tickets for January and the line 2 tickets for February are green.
B) Both the line 1 tickets for January and the line 2 tickets for February are yellow.
C) Both the line 1 tickets for January and the line 3 tickets for February are yellow.
D) The line 1 tickets for January are green, and the line 3 tickets for February are red.
E) The line 3 tickets for January are yellow, and the line 1 tickets for February are red.","# Declarations
lines = EnumSort([line1, line2, line3])
months = EnumSort([January, February])
colors = EnumSort([green, purple, red, yellow])
ticket_color = Function([lines, months] -> [colors])
# Constraints
ForAll([l:lines, m:months], Exists([c:colors], ticket_color(l, m) == c)) ::: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow.
ForAll([l:lines], ticket_color(l, January) != ticket_color(l, February)) ::: For each line, the January tickets are a different color than the February tickets.
ForAll([m:months], ForAll([l1:lines, l2:lines], Implies(l1 != l2, ticket_color(l1, m) != ticket_color(l2, m)))) ::: For each month, tickets for different lines are in different colors.
Count([l:lines], ticket_color(l, January) == red) == 1 ::: Exactly one set of January tickets is red.
(ticket_color(line3, January) == green) != (ticket_color(line3, February) == green) ::: For line 3, either the January tickets or the February tickets, but not both, are green.
ticket_color(line2, January) == purple ::: The January tickets for line 2 are purple.
ForAll([l:lines], ticket_color(l, February) != purple) ::: No February tickets are purple.
# Options
is_sat(And(ticket_color(line1, January) == green, ticket_color(line2, February) == green)) ::: (A)
is_sat(And(ticket_color(line1, January) == yellow, ticket_color(line2, February) == yellow)) ::: (B)
is_sat(And(ticket_color(line1, January) == yellow, ticket_color(line3, February) == yellow)) ::: (C)
is_sat(And(ticket_color(line1, January) == green, ticket_color(line3, February) == red)) ::: (D)
is_sat(And(ticket_color(line3, January) == yellow, ticket_color(line1, February) == red)) ::: (E)"
"# Context:
A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.

# Question:
If the line 3 tickets for January are red, then which one of the following statements must be true?

# Options:
A) The line 1 tickets for January are green.
B) The line 1 tickets for January are yellow.
C) The line 1 tickets for February are red.
D) The line 2 tickets for February are yellow.
E) The line 3 tickets for February are green.","# Declarations
lines = EnumSort([line1, line2, line3])
months = EnumSort([January, February])
colors = EnumSort([green, purple, red, yellow])
ticket_color = Function([lines, months] -> [colors])
# Constraints
ForAll([l:lines, m:months], Exists([c:colors], ticket_color(l, m) == c)) ::: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow.
ForAll([l:lines], ticket_color(l, January) != ticket_color(l, February)) ::: For each line, the January tickets are a different color than the February tickets.
ForAll([m:months], ForAll([l1:lines, l2:lines], Implies(l1 != l2, ticket_color(l1, m) != ticket_color(l2, m)))) ::: For each month, tickets for different lines are in different colors.
Exists([l:lines], ticket_color(l, January) == red) ::: Exactly one set of January tickets is red.
Or(ticket_color(line3, January) == green, ticket_color(line3, February) == green) ::: For line 3, either the January tickets or the February tickets, but not both, are green.
Not(And(ticket_color(line3, January) == green, ticket_color(line3, February) == green)) ::: For line 3, either the January tickets or the February tickets, but not both, are green.
ticket_color(line2, January) == purple ::: The January tickets for line 2 are purple.
ForAll([l:lines], ticket_color(l, February) != purple) ::: No February tickets are purple.
ticket_color(line3, January) == red ::: If the line 3 tickets for January are red.
# Options
is_valid(ticket_color(line1, January) == green) ::: (A) The line 1 tickets for January are green.
is_valid(ticket_color(line1, January) == yellow) ::: (B) The line 1 tickets for January are yellow.
is_valid(ticket_color(line1, February) == red) ::: (C) The line 1 tickets for February are red.
is_valid(ticket_color(line2, February) == yellow) ::: (D) The line 2 tickets for February are yellow.
is_valid(ticket_color(line3, February) == green) ::: (E) The line 3 tickets for February are green."
"# Context:
Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.

# Question:
If John orders veal cutlet, then which one of the following statements must be true?

# Options:
A) Kate orders roast beef.
B) Kate orders swordfish.
C) Lewis orders tilefish.
D) Lewis orders veal cutlet.
E) Nat orders pork chops.","# Declarations
people = EnumSort([John, Kate, Lewis, Marie, Nat, Olive])
entrees = EnumSort([pork_chops, roast_beef, swordfish, tilefish, veal_cutlet])
order = Function([people] -> [entrees])
# Constraints
order(John) != order(Kate) ::: The two people in each couple do not order the same kind of entree as each other.
order(Lewis) != order(Marie) ::: The two people in each couple do not order the same kind of entree as each other.
order(Nat) != order(Olive) ::: The two people in each couple do not order the same kind of entree as each other.
order(John) != order(Lewis) ::: None of the men orders the same kind of entree as any of the other men.
order(John) != order(Nat) ::: None of the men orders the same kind of entree as any of the other men.
order(Lewis) != order(Nat) ::: None of the men orders the same kind of entree as any of the other men.
order(Marie) == swordfish ::: Marie orders swordfish.
order(John) != swordfish ::: Neither John nor Nat orders a fish entree.
order(John) != tilefish ::: Neither John nor Nat orders a fish entree.
order(Nat) != swordfish ::: Neither John nor Nat orders a fish entree.
order(Nat) != tilefish ::: Neither John nor Nat orders a fish entree.
order(Olive) == roast_beef ::: Olive orders roast beef.
# Options
is_valid(Implies(order(John) == veal_cutlet, order(Kate) == roast_beef)) ::: (A) Kate orders roast beef.
is_valid(Implies(order(John) == veal_cutlet, order(Kate) == swordfish)) ::: (B) Kate orders swordfish.
is_valid(Implies(order(John) == veal_cutlet, order(Lewis) == tilefish)) ::: (C) Lewis orders tilefish.
is_valid(Implies(order(John) == veal_cutlet, order(Lewis) == veal_cutlet)) ::: (D) Lewis orders veal cutlet.
is_valid(Implies(order(John) == veal_cutlet, order(Nat) == pork_chops)) ::: (E) Nat orders pork chops."
"# Context:
Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.

# Question:
Which one of the following is a complete and accurate list of the entrees any one of which Lewis could order?

# Options:
A) pork chops, roast beef
B) pork chops, veal cutlet
C) pork chops, swordfish, veal cutlet
D) pork chops, roast beef, tilefish, veal cutlet
E) pork chops, roast beef, swordfish, tilefish, veal cutlet","# Declarations
entrees = EnumSort([pork_chops, roast_beef, swordfish, tilefish, veal_cutlet])
people = EnumSort([John, Kate, Lewis, Marie, Nat, Olive])
genders = EnumSort([male, female])
order = Function([people] -> [entrees])
gender = Function([people] -> [genders])
# Constraints
ForAll([p:people], Exists([e:entrees], order(p) == e)) ::: Each person orders one and only one entree.
Not(order(John) == order(Kate)) ::: John and Kate do not order the same entree.
Not(order(Lewis) == order(Marie)) ::: Lewis and Marie do not order the same entree.
Not(order(Nat) == order(Olive)) ::: Nat and Olive do not order the same entree.
Not(order(John) == order(Lewis)) ::: John and Lewis do not order the same entree.
Not(order(John) == order(Nat)) ::: John and Nat do not order the same entree.
Not(order(Lewis) == order(Nat)) ::: Lewis and Nat do not order the same entree.
order(Marie) == swordfish ::: Marie orders swordfish.
Not(order(John) == swordfish) ::: John does not order swordfish.
Not(order(John) == tilefish) ::: John does not order tilefish.
Not(order(Nat) == swordfish) ::: Nat does not order swordfish.
Not(order(Nat) == tilefish) ::: Nat does not order tilefish.
order(Olive) == roast_beef ::: Olive orders roast beef.
# Options
is_accurate_list([order(Lewis) == pork_chops, order(Lewis) == roast_beef]) ::: (A)
is_accurate_list([order(Lewis) == pork_chops, order(Lewis) == veal_cutlet]) ::: (B)
is_accurate_list([order(Lewis) == pork_chops, order(Lewis) == swordfish, order(Lewis) == veal_cutlet]) ::: (C)
is_accurate_list([order(Lewis) == pork_chops, order(Lewis) == roast_beef, order(Lewis) == tilefish, order(Lewis) == veal_cutlet]) ::: (D)
is_accurate_list([order(Lewis) == pork_chops, order(Lewis) == roast_beef, order(Lewis) == swordfish, order(Lewis) == tilefish, order(Lewis) == veal_cutlet]) ::: (E)"
"# Context:
Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.

# Question:
If L3 is not running and a traveler goes by subway from Urstine to Rincon making the fewest possible stops, which one of the following lists all of the intermediate stations in sequence along one of the routes that the traveler could take?

# Options:
A) Quetzal, Tonka
B) Semplain, French
C) Semplain, Park
D) Quetzal, Park, Greene
E) Semplain, French, Tonka","# Declarations
stations = EnumSort([Rincon, Tonka, French, Semplain, Urstine, Quetzal, Park, Greene])
lines = EnumSort([L1, L2, L3, L4, L5])
connects = Function([lines, stations, stations] -> [bool])
stops = Function([lines, stations] -> [bool])
# Constraints
ForAll([s:stations], And(connects(L1, Rincon, Tonka), connects(L1, Tonka, French), connects(L1, French, Semplain), connects(L1, Semplain, Urstine), connects(L1, Urstine, Quetzal), connects(L1, Quetzal, Park), connects(L1, Park, Rincon))) ::: L1 runs in a loop connecting exactly seven stations.
ForAll([s:stations], And(connects(L2, Tonka, Semplain), connects(L2, Semplain, Tonka))) ::: L2 connects Tonka with Semplain, and with no other station.
ForAll([s:stations], And(connects(L3, Rincon, Urstine), connects(L3, Urstine, Rincon))) ::: L3 connects Rincon with Urstine, and with no other station.
ForAll([s:stations], And(connects(L4, Quetzal, Greene), connects(L4, Greene, Rincon))) ::: L4 runs from Quetzal through exactly one other station, Greene, to Rincon.
ForAll([s:stations], And(connects(L5, Quetzal, Tonka), connects(L5, Tonka, Quetzal))) ::: L5 connects Quetzal with Tonka, and with no other station.
ForAll([l:lines, s:stations], stops(l, s) == Exists([s1:stations, s2:stations], And(connects(l, s1, s), connects(l, s, s2)))) ::: Trains run in both directions, stopping at every station.
ForAll([s:stations], Not(connects(L3, s, s))) ::: L3 is not running.
# Options
is_valid(And(connects(L4, Quetzal, Greene), connects(L4, Greene, Rincon), connects(L5, Quetzal, Tonka), connects(L5, Tonka, Quetzal))) ::: (A) Quetzal, Tonka
is_valid(And(connects(L2, Semplain, French), connects(L2, French, Semplain), connects(L1, French, Semplain), connects(L1, Semplain, Urstine), connects(L1, Urstine, Quetzal), connects(L1, Quetzal, Park), connects(L1, Park, Rincon))) ::: (B) Semplain, French
is_valid(And(connects(L2, Semplain, Park), connects(L2, Park, Semplain), connects(L1, Park, Rincon))) ::: (C) Semplain, Park
is_valid(And(connects(L4, Quetzal, Park), connects(L4, Park, Greene), connects(L4, Greene, Rincon))) ::: (D) Quetzal, Park, Greene
is_valid(And(connects(L2, Semplain, French), connects(L2, French, Tonka), connects(L2, Tonka, Quetzal), connects(L2, Quetzal, Park), connects(L2, Park, Rincon))) ::: (E) Semplain, French, Tonka"
"# Context:
A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.

# Question:
Which one of the following is an acceptable selection of fish and plants for the aquarium? Fish Plants

# Options:
A) G, H, K W, Y
B) G, J, K W, X
C) G, J, L X, Z
D) H, J, L W, Z
E) H, K, L Y, Z","# Declarations
fish = EnumSort([G, H, J, K, L])
plants = EnumSort([W, X, Y, Z])
selected_fish = Function([fish] -> [bool])
selected_plants = Function([plants] -> [bool])
# Constraints
ForAll([f:fish], Implies(selected_fish(f), Count([f:fish], selected_fish(f)) == 3)) ::: She will stock exactly three fish of different types.
ForAll([p:plants], Implies(selected_plants(p), Count([p:plants], selected_plants(p)) == 2)) ::: She will stock exactly two species of plants.
Implies(selected_fish(G), Not(selected_fish(H))) ::: If she selects the G, she can select neither the H nor a Y.
Implies(selected_fish(G), Not(selected_plants(Y))) ::: If she selects the G, she can select neither the H nor a Y.
Implies(selected_fish(H), selected_fish(K)) ::: She cannot select the H unless she selects the K.
Implies(selected_fish(J), selected_plants(W)) ::: She cannot select the J unless she selects a W.
Implies(selected_fish(K), selected_plants(X)) ::: If she selects the K, she must select an X.
# Options
is_sat(And(selected_fish(G), selected_fish(H), selected_fish(K), selected_plants(W), selected_plants(Y))) ::: (A)
is_sat(And(selected_fish(G), selected_fish(J), selected_fish(K), selected_plants(W), selected_plants(X))) ::: (B)
is_sat(And(selected_fish(G), selected_fish(J), selected_fish(L), selected_plants(X), selected_plants(Z))) ::: (C)
is_sat(And(selected_fish(H), selected_fish(J), selected_fish(L), selected_plants(W), selected_plants(Z))) ::: (D)
is_sat(And(selected_fish(H), selected_fish(K), selected_fish(L), selected_plants(Y), selected_plants(Z))) ::: (E)"
"# Context:
A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.

# Question:
If the ranks of Ping, Oboy, and Kola were consecutive, then which one of the following statements would have to be false?

# Options:
A) Jazz received more votes than Luck.
B) Jazz received more votes than Ping.
C) Nipi received more votes than Oboy.
D) Nipi received more votes than Mist.
E) Oboy received more votes than Nipi.","# Declarations
names = EnumSort([Jazz, Kola, Luck, Mist, Nipi, Oboy, Ping])
votes = Function([names] -> [int])
rank = Function([names] -> [int])
# Constraints
ForAll([n:names], rank(n) == votes(n)) ::: Every name received a different number of votes.
ForAll([n1:names, n2:names], Implies(n1 != n2, votes(n1) != votes(n2))) ::: Every name received a different number of votes.
votes(Jazz) > votes(Oboy) ::: Jazz received more votes than Oboy.
votes(Oboy) > votes(Kola) ::: Oboy received more votes than Kola.
votes(Kola) > votes(Mist) ::: Kola received more votes than Mist.
votes(Nipi) != 1 ::: Nipi did not receive the fewest votes.
votes(Ping) < votes(Luck) ::: Ping received fewer votes than Luck.
votes(Ping) > votes(Nipi) ::: Ping received more votes than Nipi.
votes(Ping) > votes(Oboy) ::: Ping received more votes than Oboy.
rank(Ping) == rank(Oboy) + 1 ::: If the ranks of Ping, Oboy, and Kola were consecutive.
rank(Oboy) == rank(Kola) + 1 ::: If the ranks of Ping, Oboy, and Kola were consecutive.
# Options
is_unsat(votes(Jazz) > votes(Luck)) ::: (A) Jazz received more votes than Luck.
is_unsat(votes(Jazz) > votes(Ping)) ::: (B) Jazz received more votes than Ping.
is_unsat(votes(Nipi) > votes(Oboy)) ::: (C) Nipi received more votes than Oboy.
is_unsat(votes(Nipi) > votes(Mist)) ::: (D) Nipi received more votes than Mist.
is_unsat(votes(Oboy) > votes(Nipi)) ::: (E) Oboy received more votes than Nipi."
"# Context:
Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.

# Question:
Which one of the following statements must be false?

# Options:
A) Illness J has exactly two symptoms.
B) Illness K has exactly one symptom.
C) Illness L has exactly two symptoms.
D) Illness M has exactly three symptoms.
E) Illness N has exactly two symptoms.","# Declarations
illnesses = EnumSort([J, K, L, M, N])
symptoms = EnumSort([fever, headache, sneezing])
has_symptom = Function([illnesses, symptoms] -> [bool])
# Constraints
ForAll([i:illnesses], Or(has_symptom(i, fever), has_symptom(i, headache), has_symptom(i, sneezing))) ::: Each illness has at least one symptom.
And(has_symptom(J, headache), has_symptom(J, sneezing)) ::: Illness J is characterized by headache and sneezing.
ForAll([s:symptoms], Not(And(has_symptom(J, s), has_symptom(K, s)))) ::: Illnesses J and K have no symptoms in common.
Exists([s:symptoms], And(has_symptom(J, s), has_symptom(L, s))) ::: Illnesses J and L have at least one symptom in common.
Count([s:symptoms], has_symptom(L, s)) > Count([s:symptoms], has_symptom(K, s)) ::: Illness L has a greater number of symptoms than illness K.
ForAll([s:symptoms], Not(And(has_symptom(L, s), has_symptom(N, s)))) ::: Illnesses L and N have no symptoms in common.
Count([s:symptoms], has_symptom(M, s)) > Count([s:symptoms], has_symptom(J, s)) ::: Illness M has more symptoms than illness J.
# Options
is_unsat(Count([s:symptoms], has_symptom(J, s)) == 2) ::: (A) Illness J has exactly two symptoms.
is_unsat(Count([s:symptoms], has_symptom(K, s)) == 1) ::: (B) Illness K has exactly one symptom.
is_unsat(Count([s:symptoms], has_symptom(L, s)) == 2) ::: (C) Illness L has exactly two symptoms.
is_unsat(Count([s:symptoms], has_symptom(M, s)) == 3) ::: (D) Illness M has exactly three symptoms.
is_unsat(Count([s:symptoms], has_symptom(N, s)) == 2) ::: (E) Illness N has exactly two symptoms."
"# Context:
A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.

# Question:
If one set of the line 2 tickets is green, then which one of the following statements must be true?

# Options:
A) The line 1 tickets for January are red.
B) The line 3 tickets for January are red.
C) The line 1 tickets for February are red.
D) The line 3 tickets for February are green.
E) The line 3 tickets for February are yellow.","# Declarations
colors = EnumSort([green, purple, red, yellow])
lines = EnumSort([line1, line2, line3])
months = EnumSort([January, February])
ticket_color = Function([lines, months] -> [colors])
# Constraints
ForAll([l:lines, m:months], Exists([c:colors], ticket_color(l, m) == c)) ::: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow.
ForAll([l:lines], ticket_color(l, January) != ticket_color(l, February)) ::: For each line, the January tickets are a different color than the February tickets.
ForAll([m:months], ForAll([l1:lines, l2:lines], Implies(l1 != l2, ticket_color(l1, m) != ticket_color(l2, m)))) ::: For each month, tickets for different lines are in different colors.
Count([l:lines], ticket_color(l, January) == red) == 1 ::: Exactly one set of January tickets is red.
Or(And(ticket_color(line3, January) == green, ticket_color(line3, February) != green), And(ticket_color(line3, January) != green, ticket_color(line3, February) == green)) ::: For line 3, either the January tickets or the February tickets, but not both, are green.
ticket_color(line2, January) == purple ::: The January tickets for line 2 are purple.
ForAll([l:lines], ticket_color(l, February) != purple) ::: No February tickets are purple.
ticket_color(line2, February) == green ::: One set of the line 2 tickets is green.
# Options
is_valid(ticket_color(line1, January) == red) ::: (A)
is_valid(ticket_color(line3, January) == red) ::: (B)
is_valid(ticket_color(line1, February) == red) ::: (C)
is_valid(ticket_color(line3, February) == green) ::: (D)
is_valid(ticket_color(line3, February) == yellow) ::: (E)"
"# Context:
There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.

# Question:
Which one of the following families could live in the house that is the farthest east?

# Options:
A) the Kahns
B) the Muirs
C) the Newmans
D) the Piatts
E) the Rutans","# Declarations
houses = EnumSort([house1, house2, house3, house4, house5, house6, house7])
families = EnumSort([Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans])
occupies = Function([houses] -> [families])
# Constraints
ForAll([h:houses], Exists([f:families], occupies(h) == f)) ::: Each house is occupied by exactly one family
Count([h:houses], occupies(h) == Kahns) == 1 ::: There is exactly one house occupied by the Kahns
Count([h:houses], occupies(h) == Lowes) == 1 ::: There is exactly one house occupied by the Lowes
Count([h:houses], occupies(h) == Muirs) == 1 ::: There is exactly one house occupied by the Muirs
Count([h:houses], occupies(h) == Newmans) == 1 ::: There is exactly one house occupied by the Newmans
Count([h:houses], occupies(h) == Owens) == 1 ::: There is exactly one house occupied by the Owens
Count([h:houses], occupies(h) == Piatts) == 1 ::: There is exactly one house occupied by the Piatts
Count([h:houses], occupies(h) == Rutans) == 1 ::: There is exactly one house occupied by the Rutans
occupies(house4) == Kahns ::: The Kahns live in the fourth house from the west end of the street
Exists([h:houses], And(h != house1, h != house7, occupies(h) == Rutans)) ::: The Rutans do not live in the first or the last house on the street
Exists([h:houses], And(Or(h == house3, h == house5), occupies(h) == Muirs)) ::: The Muirs live next to the Kahns
Exists([h:houses], And(h == house6, occupies(h) == Piatts)) ::: The Piatts live east of both the Kahns and the Muirs but west of the Lowes
# Options
is_sat(occupies(house7) == Kahns) ::: (A) the Kahns
is_sat(occupies(house7) == Muirs) ::: (B) the Muirs
is_sat(occupies(house7) == Newmans) ::: (C) the Newmans
is_sat(occupies(house7) == Piatts) ::: (D) the Piatts
is_sat(occupies(house7) == Rutans) ::: (E) the Rutans"
"# Context:
A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.

# Question:
If the computer in office 3 was bought in 1988, then which one of the following statements could be true?

# Options:
A) The printer in office 1 was bought in 1988.
B) The computer in office 2 was bought in 1987.
C) The printer in office 2 was bought in 1988.
D) The computer in office 4 was bought in 1987.
E) The printer in office 4 was bought in 1989.","# Declarations
offices = EnumSort([1, 2, 3, 4])
machines = EnumSort([computer, printer])
years = EnumSort([1987, 1988, 1989])
bought = Function([offices, machines] -> [years])
# Constraints
ForAll([o:offices], bought(o, computer) <= bought(o, printer)) ::: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.
bought(2, computer) == bought(1, printer) ::: The computer in office 2 and the printer in office 1 were bought in the same year.
bought(3, computer) == bought(4, printer) ::: The computer in office 3 and the printer in office 4 were bought in the same year.
bought(2, computer) != bought(3, computer) ::: The computer in office 2 and the computer in office 3 were bought in different years.
bought(1, computer) == 1988 ::: The computer in office 1 and the printer in office 3 were bought in 1988.
bought(3, computer) == 1988 ::: The computer in office 3 was bought in 1988.
# Options
is_sat(bought(1, printer) == 1988) ::: (A) The printer in office 1 was bought in 1988.
is_sat(bought(2, computer) == 1987) ::: (B) The computer in office 2 was bought in 1987.
is_sat(bought(2, printer) == 1988) ::: (C) The printer in office 2 was bought in 1988.
is_sat(bought(4, computer) == 1987) ::: (D) The computer in office 4 was bought in 1987.
is_sat(bought(4, printer) == 1989) ::: (E) The printer in office 4 was bought in 1989."
"# Context:
A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.

# Question:
If the line 3 tickets for February are yellow, then each of the following statements must be true EXCEPT:

# Options:
A) One set of January tickets is green.
B) One set of line 1 tickets is red.
C) One set of line 2 tickets is red.
D) The tickets in two of the six sets are red.
E) The tickets in two of the six sets are yellow.","# Declarations
colors = EnumSort([green, purple, red, yellow])
lines = EnumSort([line1, line2, line3])
months = EnumSort([January, February])
ticket_color = Function([lines, months] -> [colors])
# Constraints
ForAll([l:lines, m:months], Exists([c:colors], ticket_color(l, m) == c)) ::: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow.
ForAll([l:lines], ticket_color(l, January) != ticket_color(l, February)) ::: For each line, the January tickets are a different color than the February tickets.
ForAll([m:months], ForAll([l1:lines, l2:lines], Implies(l1 != l2, ticket_color(l1, m) != ticket_color(l2, m)))) ::: For each month, tickets for different lines are in different colors.
Count([l:lines], ticket_color(l, January) == red) == 1 ::: Exactly one set of January tickets is red.
Or(And(ticket_color(line3, January) == green, ticket_color(line3, February) != green), And(ticket_color(line3, January) != green, ticket_color(line3, February) == green)) ::: For line 3, either the January tickets or the February tickets, but not both, are green.
ticket_color(line2, January) == purple ::: The January tickets for line 2 are purple.
ForAll([l:lines], ticket_color(l, February) != purple) ::: No February tickets are purple.
ticket_color(line3, February) == yellow ::: The line 3 tickets for February are yellow.
# Options
is_unsat(Count([l:lines], ticket_color(l, January) == green) == 1) ::: (A)
is_unsat(Exists([m:months], ticket_color(line1, m) == red)) ::: (B)
is_unsat(Exists([m:months], ticket_color(line2, m) == red)) ::: (C)
is_unsat(Count([l:lines, m:months], ticket_color(l, m) == red) == 2) ::: (D)
is_unsat(Count([l:lines, m:months], ticket_color(l, m) == yellow) == 2) ::: (E)"
"# Context:
At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.

# Question:
If there are research models on exactly two floors, then which one of the following statements can be false?

# Options:
A) There are family cars on floor 1.
B) There are research models on floor 1.
C) There are new cars on floor 2.
D) There are research models on floor 2.
E) There are family cars on floor 3.","# Declarations
cars = EnumSort([car1, car2, car3])
floors = EnumSort([floor1, floor2, floor3])
car_types = EnumSort([family, sports])
car_conditions = EnumSort([new, used])
car_models = EnumSort([production, research])
displayed_on = Function([cars] -> [floors])
car_type = Function([cars] -> [car_types])
car_condition = Function([cars] -> [car_conditions])
car_model = Function([cars] -> [car_models])
# Constraints
ForAll([c:cars], Implies(car_type(c) == family, displayed_on(c) != floor3)) ::: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car.
ForAll([c:cars], Implies(car_condition(c) == used, car_model(c) != research)) ::: The exhibition includes no used research models.
ForAll([c:cars], Implies(car_model(c) == research, car_type(c) != sports)) ::: The exhibition includes no research models that are sports cars.
Exists([c:cars], And(displayed_on(c) == floor1, car_condition(c) == new)) ::: There are new cars on floor 1.
Exists([c:cars], And(displayed_on(c) == floor3, car_condition(c) == used)) ::: There are used cars on floor 3.
Count([f:floors], Exists([c:cars], And(displayed_on(c) == f, car_model(c) == research))) == 2 ::: There are research models on exactly two floors.
# Options
is_unsat(Exists([c:cars], And(displayed_on(c) == floor1, car_type(c) == family))) ::: (A) There are family cars on floor 1.
is_unsat(Exists([c:cars], And(displayed_on(c) == floor1, car_model(c) == research))) ::: (B) There are research models on floor 1.
is_unsat(Exists([c:cars], And(displayed_on(c) == floor2, car_condition(c) == new))) ::: (C) There are new cars on floor 2.
is_unsat(Exists([c:cars], And(displayed_on(c) == floor2, car_model(c) == research))) ::: (D) There are research models on floor 2.
is_unsat(Exists([c:cars], And(displayed_on(c) == floor3, car_type(c) == family))) ::: (E) There are family cars on floor 3."
"# Context:
A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.

# Question:
If the computer in office 4 was bought in 1988, then which one of the following statements must be true?

# Options:
A) The printer in office 1 was bought in 1988.
B) The printer in office 1 was bought in 1989.
C) The computer in office 2 was bought in 1988.
D) The computer in office 3 was bought in 1987.
E) The printer in office 4 was bought in 1989.","# Declarations
offices = EnumSort([1, 2, 3, 4])
years = EnumSort([1987, 1988, 1989])
machines = EnumSort([computer, printer])
bought_in = Function([offices, machines] -> [years])
# Constraints
ForAll([o:offices], bought_in(o, computer) <= bought_in(o, printer)) ::: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.
bought_in(2, computer) == bought_in(1, printer) ::: The computer in office 2 and the printer in office 1 were bought in the same year.
bought_in(3, computer) == bought_in(4, printer) ::: The computer in office 3 and the printer in office 4 were bought in the same year.
bought_in(2, computer) != bought_in(3, computer) ::: The computer in office 2 and the computer in office 3 were bought in different years.
bought_in(1, computer) == 1988 ::: The computer in office 1 and the printer in office 3 were bought in 1988.
bought_in(3, printer) == 1988 ::: The computer in office 1 and the printer in office 3 were bought in 1988.
bought_in(4, computer) == 1988 ::: The computer in office 4 was bought in 1988.
# Options
is_sat(bought_in(1, printer) == 1988) ::: (A) The printer in office 1 was bought in 1988.
is_sat(bought_in(1, printer) == 1989) ::: (B) The printer in office 1 was bought in 1989.
is_sat(bought_in(2, computer) == 1988) ::: (C) The computer in office 2 was bought in 1988.
is_sat(bought_in(3, computer) == 1987) ::: (D) The computer in office 3 was bought in 1987.
is_sat(bought_in(4, printer) == 1989) ::: (E) The printer in office 4 was bought in 1989."
"# Context:
A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.

# Question:
Which one of the following statements could be true?

# Options:
A) The printer in office 1 was bought in 1987.
B) The computer in office 2 was bought in 1987.
C) The computer in office 3 was bought in 1989.
D) The printer in office 4 was bought in 1988.
E) The printer in office 4 was bought in 1989.","# Declarations
offices = EnumSort([1, 2, 3, 4])
years = EnumSort([1987, 1988, 1989])
computers = EnumSort([c1, c2, c3, c4])
printers = EnumSort([p1, p2, p3, p4])
computer_year = Function([computers] -> [years])
printer_year = Function([printers] -> [years])
# Constraints
ForAll([o:offices], computer_year(computers[o-1]) <= printer_year(printers[o-1])) ::: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.
computer_year(c2) == printer_year(p1) ::: The computer in office 2 and the printer in office 1 were bought in the same year.
computer_year(c3) == printer_year(p4) ::: The computer in office 3 and the printer in office 4 were bought in the same year.
computer_year(c2) != computer_year(c3) ::: The computer in office 2 and the computer in office 3 were bought in different years.
And(computer_year(c1) == 1988, printer_year(p3) == 1988) ::: The computer in office 1 and the printer in office 3 were bought in 1988.
# Options
is_sat(printer_year(p1) == 1987) ::: (A) The printer in office 1 was bought in 1987.
is_sat(computer_year(c2) == 1987) ::: (B) The computer in office 2 was bought in 1987.
is_sat(computer_year(c3) == 1989) ::: (C) The computer in office 3 was bought in 1989.
is_sat(printer_year(p4) == 1988) ::: (D) The printer in office 4 was bought in 1988.
is_sat(printer_year(p4) == 1989) ::: (E) The printer in office 4 was bought in 1989."
"# Context:
Doctor Yamata works only on Mondays, Tuesdays, Wednesdays, Fridays, and Saturdays. She performs four different activities—lecturing, operating, treating patients, and conducting research. Each working day she performs exactly one activity in the morning and exactly one activity in the afternoon. During each week her work schedule must satisfy the following restrictions: She performs operations on exactly three mornings. If she operates on Monday, she does not operate on Tuesday. She lectures in the afternoon on exactly two consecutive calendar days. She treats patients on exactly one morning and exactly three afternoons. She conducts research on exactly one morning. On Saturday she neither lectures nor performs operations.

# Question:
Which one of the following statements must be true?

# Options:
A) There is one day on which the doctor treats patients both in the morning and in the afternoon.
B) The doctor conducts research on one of the days on which she lectures.
C) The doctor conducts research on one of the days on which she treats patients.
D) The doctor lectures on one of the days on which she treats patients.
E) The doctor lectures on one of the days on which she operates.","# Declarations
days = EnumSort([Monday, Tuesday, Wednesday, Friday, Saturday])
activities = EnumSort([lecturing, operating, treating_patients, conducting_research])
time_of_day = EnumSort([morning, afternoon])
activity_schedule = Function([days, time_of_day] -> [activities])
# Constraints
ForAll([d:days], Exists([t:time_of_day], activity_schedule(d, t) == lecturing)) ::: She lectures in the afternoon on exactly two consecutive calendar days.
ForAll([d:days], Exists([t:time_of_day], activity_schedule(d, t) == operating)) ::: She performs operations on exactly three mornings.
ForAll([d:days], Exists([t:time_of_day], activity_schedule(d, t) == treating_patients)) ::: She treats patients on exactly one morning and exactly three afternoons.
ForAll([d:days], Exists([t:time_of_day], activity_schedule(d, t) == conducting_research)) ::: She conducts research on exactly one morning.
ForAll([d:days], activity_schedule(d, morning) != activity_schedule(d, afternoon)) ::: Each working day she performs exactly one activity in the morning and exactly one activity in the afternoon.
activity_schedule(Saturday, morning) != operating ::: On Saturday she neither lectures nor performs operations.
activity_schedule(Saturday, afternoon) != operating ::: On Saturday she neither lectures nor performs operations.
activity_schedule(Saturday, morning) != lecturing ::: On Saturday she neither lectures nor performs operations.
activity_schedule(Saturday, afternoon) != lecturing ::: On Saturday she neither lectures nor performs operations.
Count([d:days], activity_schedule(d, morning) == operating) == 3 ::: She performs operations on exactly three mornings.
Count([d:days], activity_schedule(d, afternoon) == lecturing) == 2 ::: She lectures in the afternoon on exactly two consecutive calendar days.
Count([d:days], activity_schedule(d, morning) == treating_patients) == 1 ::: She treats patients on exactly one morning.
Count([d:days], activity_schedule(d, afternoon) == treating_patients) == 3 ::: She treats patients on exactly three afternoons.
Count([d:days], activity_schedule(d, morning) == conducting_research) == 1 ::: She conducts research on exactly one morning.
ForAll([d:days], Implies(activity_schedule(d, morning) == operating, activity_schedule(d, afternoon) != operating)) ::: If she operates on Monday, she does not operate on Tuesday.
# Options
is_valid(Exists([d:days], And(activity_schedule(d, morning) == treating_patients, activity_schedule(d, afternoon) == treating_patients))) ::: (A) There is one day on which the doctor treats patients both in the morning and in the afternoon.
is_valid(Exists([d:days], And(activity_schedule(d, morning) == conducting_research, activity_schedule(d, afternoon) == lecturing))) ::: (B) The doctor conducts research on one of the days on which she lectures.
is_valid(Exists([d:days], And(activity_schedule(d, morning) == conducting_research, activity_schedule(d, afternoon) == treating_patients))) ::: (C) The doctor conducts research on one of the days on which she treats patients.
is_valid(Exists([d:days], And(activity_schedule(d, afternoon) == lecturing, activity_schedule(d, morning) == treating_patients))) ::: (D) The doctor lectures on one of the days on which she treats patients.
is_valid(Exists([d:days], And(activity_schedule(d, afternoon) == lecturing, activity_schedule(d, morning) == operating))) ::: (E) The doctor lectures on one of the days on which she operates."
"# Context:
An official is assigning five runners—Larry, Ned, Olivia, Patricia, and Sonja—to parallel lanes numbered consecutively 1 through 5. The official will also assign each runner to represent a different charity—F, G, H, J, and K—not necessarily in order of the runner's names as given. The following ordering restrictions apply: The runner representing K is assigned to lane 4. Patricia is assigned to the only lane between the lanes of the runners representing F and G. There are exactly two lanes between Olivia's lane and the lane of the runner representing G. Sonja is assigned to a higher-numbered lane than the lane to which Ned is assigned.

# Question:
If Larry represents J, which one of the following could be the assignment of runners to lanes?

# Options:
A) Larry Olivia Ned Patricia Sonja
B) Larry Ned Olivia Sonja Patricia
C) Larry Sonja Patricia Ned Olivia
D) Ned Olivia Larry Patricia Sonja
E) Ned Sonja Olivia Patricia Larry","# Declarations
runners = EnumSort([Larry, Ned, Olivia, Patricia, Sonja])
lanes = EnumSort([1, 2, 3, 4, 5])
charities = EnumSort([F, G, H, J, K])
assigned_lane = Function([runners] -> [lanes])
assigned_charity = Function([runners] -> [charities])
# Constraints
ForAll([r:runners], Exists([c:charities], assigned_charity(r) == c)) ::: Each runner is assigned to a charity.
ForAll([c:charities], Exists([r:runners], assigned_charity(r) == c)) ::: Each charity is represented by a runner.
ForAll([r:runners, s:runners], Implies(r != s, assigned_charity(r) != assigned_charity(s))) ::: No two runners represent the same charity.
ForAll([r:runners, s:runners], Implies(r != s, assigned_lane(r) != assigned_lane(s))) ::: No two runners are assigned to the same lane.
ForAll([r:runners], Implies(assigned_charity(r) == K, assigned_lane(r) == 4)) ::: The runner representing K is assigned to lane 4.
Exists([r1:runners, r2:runners], And(assigned_charity(r1) == F, assigned_charity(r2) == G, Abs(assigned_lane(r1) - assigned_lane(r2)) == 2, assigned_lane(Patricia) == assigned_lane(r1) + 1)) ::: Patricia is assigned to the only lane between the lanes of the runners representing F and G.
Exists([r:runners], And(assigned_charity(r) == G, Abs(assigned_lane(Olivia) - assigned_lane(r)) == 2)) ::: There are exactly two lanes between Olivia's lane and the lane of the runner representing G.
assigned_lane(Sonja) > assigned_lane(Ned) ::: Sonja is assigned to a higher-numbered lane than the lane to which Ned is assigned.
assigned_charity(Larry) == J ::: Larry represents J.
# Options
is_sat(And(assigned_lane(Larry) == 1, assigned_lane(Olivia) == 2, assigned_lane(Ned) == 3, assigned_lane(Patricia) == 4, assigned_lane(Sonja) == 5)) ::: (A)
is_sat(And(assigned_lane(Larry) == 1, assigned_lane(Ned) == 2, assigned_lane(Olivia) == 3, assigned_lane(Sonja) == 4, assigned_lane(Patricia) == 5)) ::: (B)
is_sat(And(assigned_lane(Larry) == 1, assigned_lane(Sonja) == 2, assigned_lane(Patricia) == 3, assigned_lane(Ned) == 4, assigned_lane(Olivia) == 5)) ::: (C)
is_sat(And(assigned_lane(Ned) == 1, assigned_lane(Olivia) == 2, assigned_lane(Larry) == 3, assigned_lane(Patricia) == 4, assigned_lane(Sonja) == 5)) ::: (D)
is_sat(And(assigned_lane(Ned) == 1, assigned_lane(Sonja) == 2, assigned_lane(Olivia) == 3, assigned_lane(Patricia) == 4, assigned_lane(Larry) == 5)) ::: (E)"
"# Context:
Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.

# Question:
The time slot in which O must be played is completely determined if G is assigned to which one of the following time slots?

# Options:
A) the first
B) the third
C) the fourth
D) the fifth
E) the sixth","# Declarations
time_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])
tapes = EnumSort([G, H, L, O, P, S, news])
assigned = Function([time_slots] -> [tapes])
# Constraints
ForAll([t:time_slots], Exists([s:tapes], assigned(t) == s)) ::: Each tape is assigned to a different time slot.
ForAll([t:time_slots], assigned(t) != news) ::: The news tape must be played at some time after L.
ForAll([t:time_slots], assigned(t) != assigned(t+1)) ::: No two consecutive time slots have the same tape.
Exists([t:time_slots], And(assigned(t) == L, assigned(t+1) == O)) ::: L must be played immediately before O.
Exists([t:time_slots], And(assigned(t) == L, assigned(t+3) == P)) ::: There must be exactly two time slots between G and P.
Exists([t:time_slots], And(assigned(t) == L, assigned(t+4) == news)) ::: The news tape must be played at some time after L.
# Options
is_valid(ForAll([t:time_slots], Implies(assigned(1) == G, assigned(3) == O))) ::: (A) the first
is_valid(ForAll([t:time_slots], Implies(assigned(3) == G, assigned(4) == O))) ::: (B) the third
is_valid(ForAll([t:time_slots], Implies(assigned(4) == G, assigned(5) == O))) ::: (C) the fourth
is_valid(ForAll([t:time_slots], Implies(assigned(5) == G, assigned(6) == O))) ::: (D) the fifth
is_valid(ForAll([t:time_slots], Implies(assigned(6) == G, assigned(7) == O))) ::: (E) the sixth"
"# Context:
A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.

# Question:
If light 1 is off, which one of the following is a light that must also be off?

# Options:
A) light 3
B) light 4
C) light 5
D) light 6
E) light 7","# Declarations
lights = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])
is_on = Function([lights] -> [bool])
# Constraints
ForAll([l:lights], Or(is_on(l), Not(is_on(l)))) ::: Each light can either be on or off.
ForAll([l:lights], Implies(And(l >= 1, l <= 6), Not(And(is_on(l), is_on(l+1), is_on(l+2))))) ::: At least one of any three consecutively numbered lights is off.
is_on(8) ::: Light 8 is on.
Implies(is_on(1), And(Not(is_on(2)), Not(is_on(7)))) ::: Neither light 2 nor light 7 is on when light 1 is on.
ForAll([l:lights], Implies(And(l >= 1, l <= 6), Or(is_on(l), is_on(l+1), is_on(l+2)))) ::: At least one of the three lights on each side is on.
ForAll([l:lights], Implies(And(l >= 1, l <= 6), Implies(And(is_on(l), is_on(l+1), Not(is_on(l+2))), l+1 == 2))) ::: If any side has exactly one of its three lights on, then that light is its center light.
And(is_on(2), is_on(3)) ::: Two of the lights on the north side are on.
# Options
is_unsat(is_on(3)) ::: (A) light 3
is_unsat(is_on(4)) ::: (B) light 4
is_unsat(is_on(5)) ::: (C) light 5
is_unsat(is_on(6)) ::: (D) light 6
is_unsat(is_on(7)) ::: (E) light 7"
"# Context:
Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.

# Question:
If P is played fifth, L must be played

# Options:
A) first
B) second
C) third
D) fourth
E) sixth","# Declarations
time_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])
tapes = EnumSort([G, H, L, O, P, S, news])
assigned = Function([time_slots] -> [tapes])
# Constraints
ForAll([t:time_slots], Exists([s:tapes], assigned(t) == s)) ::: Each tape is to be assigned to a different time slot.
ForAll([t1:time_slots, t2:time_slots], Implies(t1 != t2, assigned(t1) != assigned(t2))) ::: Each tape is to be assigned to a different time slot.
Exists([t:time_slots], And(assigned(t) == L, assigned(t + 1) == O)) ::: L must be played immediately before O.
Exists([t:time_slots], And(assigned(t) == L, ForAll([t2:time_slots], Implies(assigned(t2) == news, t2 > t)))) ::: The news tape must be played at some time after L.
Exists([t1:time_slots, t2:time_slots], And(assigned(t1) == G, assigned(t2) == P, Or(t2 == t1 + 2, t1 == t2 + 2))) ::: There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.
assigned(5) == P ::: If P is played fifth.
# Options
is_sat(assigned(1) == L) ::: (A) first
is_sat(assigned(2) == L) ::: (B) second
is_sat(assigned(3) == L) ::: (C) third
is_sat(assigned(4) == L) ::: (D) fourth
is_sat(assigned(6) == L) ::: (E) sixth"
"# Context:
Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.

# Question:
Which one of the following is the latest time slot in which L can be played?

# Options:
A) the third
B) the fourth
C) the fifth
D) the sixth
E) the seventh","# Declarations
time_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])
tapes = EnumSort([G, H, L, O, P, S, news])
assigned = Function([time_slots] -> [tapes])
# Constraints
ForAll([t:time_slots], Exists([s:tapes], assigned(t) == s)) ::: Each tape is assigned to a different time slot.
ForAll([t1:time_slots, t2:time_slots], Implies(t1 != t2, assigned(t1) != assigned(t2))) ::: Each tape is assigned to a different time slot.
Exists([t:time_slots], And(assigned(t) == L, assigned(t+1) == O)) ::: L must be played immediately before O.
Exists([t:time_slots], And(assigned(t) == L, ForAll([t2:time_slots], Implies(t2 > t, assigned(t2) == news)))) ::: The news tape must be played at some time after L.
Exists([t1:time_slots, t2:time_slots], And(assigned(t1) == G, assigned(t2) == P, Or(t2 == t1+2, t1 == t2+2))) ::: There must be exactly two time slots between G and P.
# Options
is_sat(Exists([t:time_slots], And(assigned(t) == L, t == 3))) ::: (A) the third
is_sat(Exists([t:time_slots], And(assigned(t) == L, t == 4))) ::: (B) the fourth
is_sat(Exists([t:time_slots], And(assigned(t) == L, t == 5))) ::: (C) the fifth
is_sat(Exists([t:time_slots], And(assigned(t) == L, t == 6))) ::: (D) the sixth
is_sat(Exists([t:time_slots], And(assigned(t) == L, t == 7))) ::: (E) the seventh"
"# Context:
Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.

# Question:
If the tracks that directly connect Urstine and Quetzal are blocked in both directions, a traveler going from Semplain to Park and making the fewest possible intermediate stops must pass through

# Options:
A) French or Tonka
B) Greene or Urstine
C) Quetzal or Tonka
D) Quetzal or Urstine or both
E) Rincon or Tonka or both","# Declarations
stations = EnumSort([Rincon, Tonka, French, Semplain, Urstine, Quetzal, Park, Greene])
lines = EnumSort([L1, L2, L3, L4, L5])
connects = Function([lines, stations, stations] -> [bool])
blocked = Function([stations, stations] -> [bool])
# Constraints
ForAll([s1:stations, s2:stations], blocked(s1, s2) == blocked(s2, s1)) ::: ""If the tracks that directly connect Urstine and Quetzal are blocked in both directions""
blocked(Urstine, Quetzal) ::: ""If the tracks that directly connect Urstine and Quetzal are blocked in both directions""
connects(L1, Rincon, Tonka) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L1, Tonka, French) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L1, French, Semplain) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L1, Semplain, Urstine) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L1, Urstine, Quetzal) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L1, Quetzal, Park) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L1, Park, Rincon) ::: ""Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel""
connects(L2, Tonka, Semplain) ::: ""L2 connects Tonka with Semplain, and with no other station""
connects(L2, Semplain, Tonka) ::: ""L2 connects Tonka with Semplain, and with no other station""
connects(L3, Rincon, Urstine) ::: ""L3 connects Rincon with Urstine, and with no other station""
connects(L3, Urstine, Rincon) ::: ""L3 connects Rincon with Urstine, and with no other station""
connects(L4, Quetzal, Greene) ::: ""L4 runs from Quetzal through exactly one other station, Greene, to Rincon""
connects(L4, Greene, Rincon) ::: ""L4 runs from Quetzal through exactly one other station, Greene, to Rincon""
connects(L5, Quetzal, Tonka) ::: ""L5 connects Quetzal with Tonka, and with no other station""
connects(L5, Tonka, Quetzal) ::: ""L5 connects Quetzal with Tonka, and with no other station""
# Options
is_valid(Or(connects(L1, Semplain, French), connects(L1, Semplain, Tonka))) ::: (A) ""French or Tonka""
is_valid(Or(connects(L4, Quetzal, Greene), connects(L3, Rincon, Urstine))) ::: (B) ""Greene or Urstine""
is_valid(Or(connects(L5, Quetzal, Tonka), connects(L1, Semplain, Tonka))) ::: (C) ""Quetzal or Tonka""
is_valid(Or(connects(L1, Semplain, Quetzal), connects(L1, Semplain, Urstine))) ::: (D) ""Quetzal or Urstine or both""
is_valid(Or(connects(L1, Semplain, Rincon), connects(L1, Semplain, Tonka))) ::: (E) ""Rincon or Tonka or both"""
"# Context:
A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.

# Question:
If the fall oceanography orders are in folder 2, then which one of the following statements could be true?

# Options:
A) The spring mathematics orders are in folder 4.
B) The spring mathematics orders are in folder 6.
C) The fall nutrition orders are in folder 1.
D) The spring nutrition orders are in neither folder 3 nor folder 6.
E) Neither the spring nor the fall nutrition orders are in folder 3.","# Declarations
subjects = EnumSort([mathematics, nutrition, oceanography])
semesters = EnumSort([fall, spring])
folders = EnumSort([1, 2, 3, 4, 5, 6])
contains = Function([folders, subjects, semesters] -> [bool])
# Constraints
ForAll([f:folders], Exists([s:subjects, sem:semesters], contains(f, s, sem))) ::: Each folder contains only the orders for one of the six course offerings.
ForAll([s:subjects, sem:semesters], Exists([f:folders], contains(f, s, sem))) ::: Each course offering has a folder.
ForAll([f:folders], Count([s:subjects, sem:semesters], contains(f, s, sem)) == 1) ::: Each folder contains orders for exactly one course offering.
ForAll([s:subjects, sem:semesters], contains(1, s, sem) == contains(2, s, sem)) ::: Folder 1 contains orders for the same subject as folder 2 does.
ForAll([s1:subjects, sem1:semesters, s2:subjects, sem2:semesters], contains(3, s1, sem1) != contains(4, s2, sem2)) ::: The orders in folder 3 are for a different subject than are the orders in folder 4.
Or(contains(1, mathematics, fall), contains(4, mathematics, fall)) ::: The fall mathematics orders are in folder 1 or else folder 4.
Or(contains(1, oceanography, spring), contains(4, oceanography, spring)) ::: The spring oceanography orders are in folder 1 or else folder 4.
Not(contains(5, nutrition, spring)) ::: The spring nutrition orders are not in folder 5.
# Options
is_valid(contains(4, mathematics, spring)) ::: (A) The spring mathematics orders are in folder 4.
is_valid(contains(6, mathematics, spring)) ::: (B) The spring mathematics orders are in folder 6.
is_valid(contains(1, nutrition, fall)) ::: (C) The fall nutrition orders are in folder 1.
is_valid(And(Not(contains(3, nutrition, spring)), Not(contains(6, nutrition, spring)))) ::: (D) The spring nutrition orders are in neither folder 3 nor folder 6.
is_valid(And(Not(contains(3, nutrition, spring)), Not(contains(3, nutrition, fall)))) ::: (E) Neither the spring nor the fall nutrition orders are in folder 3."
"# Context:
Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.

# Question:
If H and S are to be scheduled as far from each other as possible, then the first, the second, and the third time slots could be filled, respectively, by

# Options:
A) G, H, and L
B) S, G, and the news
C) H, G, and L
D) H, L, and O
E) L, O, and S","# Declarations
tapes = EnumSort([G, H, L, O, P, S, news])
time_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])
assign = Function([tapes] -> [time_slots])
# Constraints
ForAll([t:tapes], Exists([s:time_slots], assign(t) == s)) ::: Each tape is assigned to a different time slot.
ForAll([t1:tapes, t2:tapes], Implies(t1 != t2, assign(t1) != assign(t2))) ::: No two tapes are assigned to the same time slot.
assign(L) == assign(O) - 1 ::: L must be played immediately before O.
assign(news) > assign(L) ::: The news tape must be played at some time after L.
Or(And(assign(G) == assign(P) - 2, assign(G) < assign(P)), And(assign(G) == assign(P) + 2, assign(G) > assign(P))) ::: There must be exactly two time slots between G and P.
# Options
is_valid(And(assign(G) == 1, assign(H) == 2, assign(L) == 3)) ::: (A) G, H, and L
is_valid(And(assign(S) == 1, assign(G) == 2, assign(news) == 3)) ::: (B) S, G, and the news
is_valid(And(assign(H) == 1, assign(G) == 2, assign(L) == 3)) ::: (C) H, G, and L
is_valid(And(assign(H) == 1, assign(L) == 2, assign(O) == 3)) ::: (D) H, L, and O
is_valid(And(assign(L) == 1, assign(O) == 2, assign(S) == 3)) ::: (E) L, O, and S"
"# Context:
A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.

# Question:
Which one of the following lists a pair of folders that must together contain orders for two different subjects?

# Options:
A) 3 and 5
B) 4 and 5
C) 3 and 6
D) 4 and 6
E) 5 and 6","# Declarations
folders = EnumSort([Folder1, Folder2, Folder3, Folder4, Folder5, Folder6])
subjects = EnumSort([Mathematics, Nutrition, Oceanography])
semesters = EnumSort([Fall, Spring])
contains = Function([folders, subjects, semesters] -> [bool])
# Constraints
ForAll([f1:folders, f2:folders], contains(f1, Mathematics, Fall) == contains(f2, Mathematics, Fall)) ::: The fall mathematics orders are in folder 1 or else folder 4.
ForAll([f1:folders, f2:folders], contains(f1, Oceanography, Spring) == contains(f2, Oceanography, Spring)) ::: The spring oceanography orders are in folder 1 or else folder 4.
ForAll([f:folders], Not(contains(f, Nutrition, Spring) == contains(Folder5, Nutrition, Spring))) ::: The spring nutrition orders are not in folder 5.
ForAll([f:folders], Exists([s:subjects, sem:semesters], contains(f, s, sem))) ::: Each folder contains only the orders for one of the six course offerings.
ForAll([f1:folders, f2:folders], Implies(And(f1 == Folder1, f2 == Folder2), contains(f1, s, sem) == contains(f2, s, sem))) ::: Folder 1 contains orders for the same subject as folder 2 does.
ForAll([f1:folders, f2:folders], Implies(And(f1 == Folder3, f2 == Folder4), contains(f1, s, sem) != contains(f2, s, sem))) ::: The orders in folder 3 are for a different subject than are the orders in folder 4.
# Options
is_valid(And(contains(Folder3, s, sem) != contains(Folder5, s, sem))) ::: (A)
is_valid(And(contains(Folder4, s, sem) != contains(Folder5, s, sem))) ::: (B)
is_valid(And(contains(Folder3, s, sem) != contains(Folder6, s, sem))) ::: (C)
is_valid(And(contains(Folder4, s, sem) != contains(Folder6, s, sem))) ::: (D)
is_valid(And(contains(Folder5, s, sem) != contains(Folder6, s, sem))) ::: (E)"
"# Context:
Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.

# Question:
If Y is in the middle of the west side of the park, then the two benches in which one of the following pairs CANNOT be two of the corner benches?

# Options:
A) K and X
B) K and Z
C) L and U
D) L and X
E) L and Z","# Declarations
benches = EnumSort([J, K, L, T, U, X, Y, Z])
colors = EnumSort([green, red, pink])
sides = EnumSort([north, south, east, west])
corner_positions = EnumSort([northwest, northeast, southeast, southwest])
color = Function([benches] -> [colors])
side = Function([benches] -> [sides])
corner = Function([benches] -> [corner_positions])
next_to = Function([benches, benches] -> [bool])
# Constraints
ForAll([b:benches], Or(color(b) == green, color(b) == red, color(b) == pink)) ::: All benches have a color.
ForAll([b1:benches, b2:benches], next_to(b1, b2) == next_to(b2, b1)) ::: next_to is symmetric.
ForAll([b1:benches, b2:benches], Implies(next_to(b1, b2), b1 != b2)) ::: Benches cannot be next to themselves.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == pink), Not(next_to(b1, b2)))) ::: No green bench stands next to a pink bench.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == green), next_to(b1, b2))) ::: Green benches stand next to one another.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == pink, color(b2) == pink), next_to(b1, b2))) ::: Pink benches stand next to one another.
color(J) == green ::: J is green.
color(K) == green ::: K is green.
color(L) == green ::: L is green.
color(T) == red ::: T is red.
color(U) == red ::: U is red.
color(X) == pink ::: X is pink.
color(Y) == pink ::: Y is pink.
color(Z) == pink ::: Z is pink.
corner(T) == southeast ::: The bench on the southeast corner is T.
side(J) == north ::: J stands at the center of the park's north side.
Implies(next_to(T, X), Not(next_to(T, L))) ::: If T stands next to X, then T does not also stand next to L.
side(Y) == west ::: Y is in the middle of the west side of the park.
# Options
is_unsat(And(next_to(K, X), corner(K) == northwest, corner(X) == northwest)) ::: (A) K and X
is_unsat(And(next_to(K, Z), corner(K) == northwest, corner(Z) == northwest)) ::: (B) K and Z
is_unsat(And(next_to(L, U), corner(L) == northwest, corner(U) == northwest)) ::: (C) L and U
is_unsat(And(next_to(L, X), corner(L) == northwest, corner(X) == northwest)) ::: (D) L and X
is_unsat(And(next_to(L, Z), corner(L) == northwest, corner(Z) == northwest)) ::: (E) L and Z"
"# Context:
Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.

# Question:
How many different stations are there that a traveler starting at Rincon could reach by using the subway lines without making any intermediate stops?

# Options:
A) two
B) three
C) four
D) five
E) six","# Declarations
stations = EnumSort([Rincon, Tonka, French, Semplain, Urstine, Quetzal, Park, Greene])
lines = EnumSort([L1, L2, L3, L4, L5])
connects = Function([lines, stations, stations] -> [bool])
reachable = Function([stations, stations] -> [bool])
# Constraints
ForAll([s1:stations, s2:stations], reachable(s1, s2) == Or(And(connects(L1, s1, s2), connects(L1, s2, s1)), And(connects(L2, s1, s2), connects(L2, s2, s1)), And(connects(L3, s1, s2), connects(L3, s2, s1)), And(connects(L4, s1, s2), connects(L4, s2, s1)), And(connects(L5, s1, s2), connects(L5, s2, s1)))) ::: ""A traveler can reach a station if there is a direct connection between the two stations on any of the lines.""
connects(L1, Rincon, Tonka) ::: ""L1 connects Rincon with Tonka.""
connects(L1, Tonka, French) ::: ""L1 connects Tonka with French.""
connects(L1, French, Semplain) ::: ""L1 connects French with Semplain.""
connects(L1, Semplain, Urstine) ::: ""L1 connects Semplain with Urstine.""
connects(L1, Urstine, Quetzal) ::: ""L1 connects Urstine with Quetzal.""
connects(L1, Quetzal, Park) ::: ""L1 connects Quetzal with Park.""
connects(L1, Park, Rincon) ::: ""L1 connects Park with Rincon.""
connects(L2, Tonka, Semplain) ::: ""L2 connects Tonka with Semplain.""
connects(L3, Rincon, Urstine) ::: ""L3 connects Rincon with Urstine.""
connects(L4, Quetzal, Greene) ::: ""L4 connects Quetzal with Greene.""
connects(L4, Greene, Rincon) ::: ""L4 connects Greene with Rincon.""
connects(L5, Quetzal, Tonka) ::: ""L5 connects Quetzal with Tonka.""
# Options
is_valid(Count([s:stations], reachable(Rincon, s)) == 2) ::: (A)
is_valid(Count([s:stations], reachable(Rincon, s)) == 3) ::: (B)
is_valid(Count([s:stations], reachable(Rincon, s)) == 4) ::: (C)
is_valid(Count([s:stations], reachable(Rincon, s)) == 5) ::: (D)
is_valid(Count([s:stations], reachable(Rincon, s)) == 6) ::: (E)"
"# Context:
Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.

# Question:
What is the maximum number of tapes that can separate S from the news?

# Options:
A) 1
B) 2
C) 3
D) 4
E) 5","# Declarations
tapes = EnumSort([G, H, L, O, P, S, news])
time_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])
assign = Function([tapes] -> [time_slots])
# Constraints
ForAll([t:tapes], Exists([s:time_slots], assign(t) == s)) ::: Each tape is assigned to a different time slot.
ForAll([t:tapes, t2:tapes], Implies(t != t2, assign(t) != assign(t2))) ::: No two tapes are assigned to the same time slot.
assign(L) == assign(O) - 1 ::: L must be played immediately before O.
assign(news) > assign(L) ::: The news tape must be played at some time after L.
Or(And(assign(G) == assign(P) - 2, assign(G) < assign(P)), And(assign(G) == assign(P) + 2, assign(G) > assign(P))) ::: There must be exactly two time slots between G and P.
# Options
is_valid(assign(S) == assign(news) - 1) ::: (A)
is_valid(assign(S) == assign(news) - 2) ::: (B)
is_valid(assign(S) == assign(news) - 3) ::: (C)
is_valid(assign(S) == assign(news) - 4) ::: (D)
is_valid(assign(S) == assign(news) - 5) ::: (E)"
"# Context:
A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.

# Question:
If no island that is directly connected by bridge with M is also directly connected by bridge with O, then there must be a bridge directly connecting

# Options:
A) J with L
B) J with M
C) K with O
D) L with M
E) L with O","# Declarations
islands = EnumSort([J, K, L, M, O])
bridge = Function([islands, islands] -> [bool])
# Constraints
ForAll([i:islands], Count([j:islands], bridge(i, j)) <= 3) ::: No island has more than three bridges that directly connect it with other islands.
Count([j:islands], bridge(J, j)) == 2 ::: J is directly connected by bridge with exactly two islands.
Count([j:islands], bridge(K, j)) == 1 ::: K is directly connected by bridge with exactly one island.
bridge(J, O) ::: A bridge directly connects J with O.
bridge(M, O) ::: A bridge directly connects M with O.
ForAll([i:islands], Or(bridge(J, i), bridge(L, i), bridge(K, i), bridge(M, i), bridge(O, i))) ::: J, K, and L are each directly connected by bridge with one or both of M and O.
ForAll([i:islands], Implies(bridge(M, i), Not(bridge(O, i)))) ::: If no island that is directly connected by bridge with M is also directly connected by bridge with O.
# Options
is_sat(bridge(J, L)) ::: (A) J with L
is_sat(bridge(J, M)) ::: (B) J with M
is_sat(bridge(K, O)) ::: (C) K with O
is_sat(bridge(L, M)) ::: (D) L with M
is_sat(bridge(L, O)) ::: (E) L with O"
"# Context:
A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.

# Question:
Which one of the following statements must be true?

# Options:
A) Jazz received more votes than Nipi.
B) Kola received more votes than Nipi.
C) Luck received more votes than Jazz.
D) Nipi received more votes than Oboy.
E) Ping received more votes than Kola.","# Declarations
names = EnumSort([Jazz, Kola, Luck, Mist, Nipi, Oboy, Ping])
votes = Function([names] -> [int])
# Constraints
ForAll([n1:names, n2:names], Implies(n1 != n2, votes(n1) != votes(n2))) ::: Every name received a different number of votes.
votes(Jazz) > votes(Oboy) ::: Jazz received more votes than Oboy.
votes(Oboy) > votes(Kola) ::: Oboy received more votes than Kola.
votes(Kola) > votes(Mist) ::: Kola received more votes than Mist.
Exists([n:names], votes(Nipi) > votes(n)) ::: Nipi did not receive the fewest votes.
And(votes(Ping) < votes(Luck), votes(Ping) > votes(Nipi), votes(Ping) > votes(Oboy)) ::: Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.
# Options
is_valid(votes(Jazz) > votes(Nipi)) ::: (A) Jazz received more votes than Nipi.
is_valid(votes(Kola) > votes(Nipi)) ::: (B) Kola received more votes than Nipi.
is_valid(votes(Luck) > votes(Jazz)) ::: (C) Luck received more votes than Jazz.
is_valid(votes(Nipi) > votes(Oboy)) ::: (D) Nipi received more votes than Oboy.
is_valid(votes(Ping) > votes(Kola)) ::: (E) Ping received more votes than Kola."
"# Context:
Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.

# Question:
The news tape can be played in any one of the following time slots EXCEPT the

# Options:
A) second
B) third
C) fourth
D) fifth
E) sixth","# Declarations
time_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])
tapes = EnumSort([G, H, L, O, P, S, news])
assigned = Function([time_slots] -> [tapes])
# Constraints
ForAll([t:time_slots], Exists([s:tapes], assigned(t) == s)) ::: Each tape is to be assigned to a different time slot.
ForAll([t:time_slots], assigned(t) != assigned(t+1)) ::: No tape is longer than any other tape.
Exists([t:time_slots], And(assigned(t) == L, assigned(t+1) == O)) ::: L must be played immediately before O.
Exists([t:time_slots], And(assigned(t) == L, Exists([t2:time_slots], And(t2 > t, assigned(t2) == news)))) ::: The news tape must be played at some time after L.
Exists([t:time_slots], And(assigned(t) == G, Exists([t2:time_slots], And(t2 != t, Abs(t2 - t) == 2, assigned(t2) == P)))) ::: There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.
# Options
is_unsat(assigned(2) == news) ::: (A)
is_unsat(assigned(3) == news) ::: (B)
is_unsat(assigned(4) == news) ::: (C)
is_unsat(assigned(5) == news) ::: (D)
is_unsat(assigned(6) == news) ::: (E)"
"# Context:
A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.

# Question:
Which one of the following statements must be false?

# Options:
A) The spring mathematics orders are in folder 3.
B) The fall nutrition orders are in folder 3.
C) The spring oceanography orders are in folder 1.
D) The spring nutrition orders are in folder 6.
E) The fall oceanography orders are in folder 5.","# Declarations
folders = EnumSort([folder1, folder2, folder3, folder4, folder5, folder6])
subjects = EnumSort([mathematics, nutrition, oceanography])
semesters = EnumSort([fall, spring])
contains = Function([folders, subjects, semesters] -> [bool])
# Constraints
ForAll([f:folders], Exists([s:subjects, sem:semesters], contains(f, s, sem))) ::: Each folder contains only the orders for one of the six course offerings.
ForAll([s:subjects, sem:semesters], contains(folder1, s, sem) == contains(folder2, s, sem)) ::: Folder 1 contains orders for the same subject as folder 2 does.
ForAll([s:subjects, sem:semesters], contains(folder3, s, sem) != contains(folder4, s, sem)) ::: The orders in folder 3 are for a different subject than are the orders in folder 4.
Or(contains(folder1, mathematics, fall), contains(folder4, mathematics, fall)) ::: The fall mathematics orders are in folder 1 or else folder 4.
Or(contains(folder1, oceanography, spring), contains(folder4, oceanography, spring)) ::: The spring oceanography orders are in folder 1 or else folder 4.
Not(contains(folder5, nutrition, spring)) ::: The spring nutrition orders are not in folder 5.
# Options
is_unsat(contains(folder3, mathematics, spring)) ::: (A) The spring mathematics orders are in folder 3.
is_unsat(contains(folder3, nutrition, fall)) ::: (B) The fall nutrition orders are in folder 3.
is_unsat(contains(folder1, oceanography, spring)) ::: (C) The spring oceanography orders are in folder 1.
is_unsat(contains(folder6, nutrition, spring)) ::: (D) The spring nutrition orders are in folder 6.
is_unsat(contains(folder5, oceanography, fall)) ::: (E) The fall oceanography orders are in folder 5."
"# Context:
A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.

# Question:
If a bridge directly connects L with M and a bridge directly connects L with O, then which one of the following must be true?

# Options:
A) A bridge directly connects J with M.
B) A bridge directly connects K with M.
C) A bridge directly connects K with O.
D) There are exactly two bridges directly connecting L with other islands.
E) There are exactly two bridges directly connecting M with other islands.","# Declarations
islands = EnumSort([J, K, L, M, O])
bridge = Function([islands, islands] -> [bool])
# Constraints
ForAll([i:islands], ForAll([j:islands], bridge(i, j) == bridge(j, i))) ::: Each bridge directly connects exactly two islands with each other
ForAll([i:islands], ForAll([j:islands], Implies(bridge(i, j), Not(bridge(j, i))))) ::: No more than one bridge directly connects any two islands
ForAll([i:islands], Count([j:islands], bridge(i, j)) <= 3) ::: No island has more than three bridges that directly connect it with other islands
Exists([j:islands], And(bridge(J, j), Or(j == M, j == O))) ::: J is directly connected by bridge with one or both of M and O
Exists([j:islands], And(bridge(K, j), Or(j == M, j == O))) ::: K is directly connected by bridge with one or both of M and O
Exists([j:islands], And(bridge(L, j), Or(j == M, j == O))) ::: L is directly connected by bridge with one or both of M and O
Count([j:islands], bridge(J, j)) == 2 ::: J is directly connected by bridge with exactly two islands
Count([j:islands], bridge(K, j)) == 1 ::: K is directly connected by bridge with exactly one island
bridge(J, O) ::: A bridge directly connects J with O
bridge(M, O) ::: A bridge directly connects M with O
bridge(L, M) ::: A bridge directly connects L with M
bridge(L, O) ::: A bridge directly connects L with O
# Options
is_valid(bridge(J, M)) ::: (A) A bridge directly connects J with M.
is_valid(bridge(K, M)) ::: (B) A bridge directly connects K with M.
is_valid(bridge(K, O)) ::: (C) A bridge directly connects K with O.
is_valid(Count([j:islands], bridge(L, j)) == 2) ::: (D) There are exactly two bridges directly connecting L with other islands.
is_valid(Count([j:islands], bridge(M, j)) == 2) ::: (E) There are exactly two bridges directly connecting M with other islands."
"# Context:
Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.

# Question:
In order to go by subway from French to Greene, the minimum number of intermediate stops a traveler must make is

# Options:
A) zero
B) one
C) two
D) three
E) four","# Declarations
stations = EnumSort([Rincon, Tonka, French, Semplain, Urstine, Quetzal, Park, Greene])
lines = EnumSort([L1, L2, L3, L4, L5])
connected = Function([stations, stations] -> [bool])
on_line = Function([stations, lines] -> [bool])
# Constraints
ForAll([s1:stations, s2:stations], connected(s1, s2) == connected(s2, s1)) ::: Trains run in both directions
ForAll([s:stations], on_line(s, L1) == Or(s == Rincon, s == Tonka, s == French, s == Semplain, s == Urstine, s == Quetzal, s == Park)) ::: L1 runs in a loop connecting exactly seven stations
ForAll([s:stations], on_line(s, L2) == Or(s == Tonka, s == Semplain)) ::: L2 connects Tonka with Semplain
ForAll([s:stations], on_line(s, L3) == Or(s == Rincon, s == Urstine)) ::: L3 connects Rincon with Urstine
ForAll([s:stations], on_line(s, L4) == Or(s == Quetzal, s == Greene, s == Rincon)) ::: L4 runs from Quetzal through Greene to Rincon
ForAll([s:stations], on_line(s, L5) == Or(s == Quetzal, s == Tonka)) ::: L5 connects Quetzal with Tonka
ForAll([s1:stations, s2:stations, l:lines], Implies(And(on_line(s1, l), on_line(s2, l)), connected(s1, s2))) ::: Trains stop at every station on the same line
# Options
is_valid(Count([s:stations], And(connected(French, s), connected(s, Greene))) == 0) ::: (A) zero
is_valid(Count([s:stations], And(connected(French, s), connected(s, Greene))) == 1) ::: (B) one
is_valid(Count([s:stations], And(connected(French, s), connected(s, Greene))) == 2) ::: (C) two
is_valid(Count([s:stations], And(connected(French, s), connected(s, Greene))) == 3) ::: (D) three
is_valid(Count([s:stations], And(connected(French, s), connected(s, Greene))) == 4) ::: (E) four"
"# Context:
A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.

# Question:
Which one of the following is a complete and accurate list of the islands any one of which could be directly connected by bridge with L ?

# Options:
A) J, K
B) J, M
C) J, O
D) J, M, O
E) J, K, M, O","# Declarations
islands = EnumSort([J, K, L, M, O])
connected = Function([islands, islands] -> [bool])
# Constraints
ForAll([i:islands], ForAll([j:islands], connected(i, j) == connected(j, i))) ::: Each bridge directly connects exactly two islands with each other
ForAll([i:islands], ForAll([j:islands], Implies(connected(i, j), Not(And(connected(i, j), connected(j, i)))))) ::: No more than one bridge directly connects any two islands
ForAll([i:islands], Count([j:islands], connected(i, j)) <= 3) ::: No island has more than three bridges that directly connect it with other islands
Or(connected(J, M), connected(J, O)) ::: J, K, and L are each directly connected by bridge with one or both of M and O
Or(connected(K, M), connected(K, O)) ::: J, K, and L are each directly connected by bridge with one or both of M and O
Or(connected(L, M), connected(L, O)) ::: J, K, and L are each directly connected by bridge with one or both of M and O
Count([i:islands], connected(J, i)) == 2 ::: J is directly connected by bridge with exactly two islands
Count([i:islands], connected(K, i)) == 1 ::: K is directly connected by bridge with exactly one island
connected(J, O) ::: A bridge directly connects J with O
connected(M, O) ::: A bridge directly connects M with O
# Options
is_accurate_list([connected(L, J), connected(L, M), connected(L, O)]) ::: (D) J, M, O"
"# Context:
Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.

# Question:
If Z is directly north of Y, which one of the following statements must be true?

# Options:
A) J is directly west of K.
B) K is directly east of U.
C) U is directly north of X.
D) X is directly south of J.
E) Z is directly south of J.","# Declarations
benches = EnumSort([J, K, L, T, U, X, Y, Z])
colors = EnumSort([green, red, pink])
directions = EnumSort([north, south, east, west])
color = Function([benches] -> [colors])
position = Function([benches, benches] -> [bool])
direction = Function([benches, benches] -> [directions])
# Constraints
ForAll([b:benches], Or(color(b) == green, color(b) == red, color(b) == pink)) ::: All benches have a color.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == pink), Not(position(b1, b2)))) ::: No green bench stands next to a pink bench.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == green), position(b1, b2))) ::: The green benches stand next to one another.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == pink, color(b2) == pink), position(b1, b2))) ::: The pink benches stand next to one another.
Implies(position(T, X), Not(position(T, L))) ::: If T stands next to X, then T does not also stand next to L.
color(J) == green ::: J is green.
color(K) == green ::: K is green.
color(L) == green ::: L is green.
color(T) == red ::: T is red.
color(U) == red ::: U is red.
color(X) == pink ::: X is pink.
color(Y) == pink ::: Y is pink.
color(Z) == pink ::: Z is pink.
direction(Z, Y) == north ::: Z is directly north of Y.
# Options
is_valid(direction(J, K) == west) ::: (A) J is directly west of K.
is_valid(direction(K, U) == east) ::: (B) K is directly east of U.
is_valid(direction(U, X) == north) ::: (C) U is directly north of X.
is_valid(direction(X, J) == south) ::: (D) X is directly south of J.
is_valid(direction(Z, J) == south) ::: (E) Z is directly south of J."
"# Context:
Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.

# Question:
Which one of the following could be true for March?

# Options:
A) Hubert, Lori, and Paul visit Toronto, and Regina and Sharon visit Vancouver.
B) Hubert, Lori, Paul, and Regina visit Montreal, and Sharon visits Vancouver.
C) Hubert, Paul, and Regina visit Toronto, and Lori and Sharon visit Montreal.
D) Hubert, Regina, and Sharon visit Montreal, and Lori and Paul visit Vancouver.
E) Lori, Paul, and Sharon visit Montreal, and Hubert and Regina visit Toronto.","# Declarations
students = EnumSort([Hubert, Lori, Paul, Regina, Sharon])
cities = EnumSort([Montreal, Toronto, Vancouver])
visit = Function([students] -> [cities])
# Constraints
ForAll([s:students], Exists([c:cities], visit(s) == c)) ::: Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March.
visit(Sharon) != visit(Paul) ::: Sharon visits a different city than Paul.
visit(Hubert) == visit(Regina) ::: Hubert visits the same city as Regina.
Or(visit(Lori) == Montreal, visit(Lori) == Toronto) ::: Lori visits Montreal or else Toronto.
Implies(visit(Paul) == Vancouver, visit(Hubert) == Vancouver) ::: If Paul visits Vancouver, Hubert visits Vancouver with him.
ForAll([s:students], Exists([o:students], And(s != o, visit(s) == visit(o)))) ::: Each student visits one of the cities with at least one of the other four students.
# Options
is_sat(And(visit(Hubert) == Toronto, visit(Lori) == Toronto, visit(Paul) == Toronto, visit(Regina) == Vancouver, visit(Sharon) == Vancouver)) ::: (A)
is_sat(And(visit(Hubert) == Montreal, visit(Lori) == Montreal, visit(Paul) == Montreal, visit(Regina) == Montreal, visit(Sharon) == Vancouver)) ::: (B)
is_sat(And(visit(Hubert) == Toronto, visit(Paul) == Toronto, visit(Regina) == Toronto, visit(Lori) == Montreal, visit(Sharon) == Montreal)) ::: (C)
is_sat(And(visit(Hubert) == Montreal, visit(Regina) == Montreal, visit(Sharon) == Montreal, visit(Lori) == Vancouver, visit(Paul) == Vancouver)) ::: (D)
is_sat(And(visit(Lori) == Montreal, visit(Paul) == Montreal, visit(Sharon) == Montreal, visit(Hubert) == Toronto, visit(Regina) == Toronto)) ::: (E)"
"# Context:
A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.

# Question:
Which one of the following could be the list of the contents of the folders, in order from folder 1 to folder 6 ?

# Options:
A) fall mathematics, spring mathematics, fall oceanography, fall nutrition, spring nutrition, spring oceanography
B) fall oceanography, spring nutrition, fall nutrition, fall mathematics, spring mathematics, spring oceanography
C) spring mathematics, fall mathematics, spring nutrition, fall oceanography, fall nutrition, spring oceanography
D) spring oceanography, fall oceanography, fall nutrition, fall mathematics, spring mathematics, spring nutrition
E) spring oceanography, fall oceanography, spring mathematics, fall mathematics, fall nutrition, spring nutrition","# Declarations
subjects = EnumSort([mathematics, nutrition, oceanography])
semesters = EnumSort([fall, spring])
folders = EnumSort([folder1, folder2, folder3, folder4, folder5, folder6])
contains = Function([folders, semesters, subjects] -> [bool])
# Constraints
ForAll([f:folders], Exists([s:semesters, sub:subjects], contains(f, s, sub))) ::: Each folder contains only the orders for one of the six course offerings.
ForAll([s:semesters, sub:subjects], Or(contains(folder1, s, sub), contains(folder2, s, sub))) ::: Folder 1 contains orders for the same subject as folder 2 does.
ForAll([s:semesters, sub:subjects], Not(And(contains(folder3, s, sub), contains(folder4, s, sub)))) ::: The orders in folder 3 are for a different subject than are the orders in folder 4.
ForAll([s:semesters, sub:subjects], Or(contains(folder1, fall, mathematics), contains(folder4, fall, mathematics))) ::: The fall mathematics orders are in folder 1 or else folder 4.
ForAll([s:semesters, sub:subjects], Or(contains(folder1, spring, oceanography), contains(folder4, spring, oceanography))) ::: The spring oceanography orders are in folder 1 or else folder 4.
ForAll([s:semesters, sub:subjects], Not(contains(folder5, spring, nutrition))) ::: The spring nutrition orders are not in folder 5.
# Options
is_valid(And(contains(folder1, fall, mathematics), contains(folder2, spring, mathematics), contains(folder3, fall, oceanography), contains(folder4, fall, nutrition), contains(folder5, spring, nutrition), contains(folder6, spring, oceanography))) ::: (A)
is_valid(And(contains(folder1, fall, oceanography), contains(folder2, spring, nutrition), contains(folder3, fall, nutrition), contains(folder4, fall, mathematics), contains(folder5, spring, mathematics), contains(folder6, spring, oceanography))) ::: (B)
is_valid(And(contains(folder1, spring, mathematics), contains(folder2, fall, mathematics), contains(folder3, spring, nutrition), contains(folder4, fall, oceanography), contains(folder5, fall, nutrition), contains(folder6, spring, oceanography))) ::: (C)
is_valid(And(contains(folder1, spring, oceanography), contains(folder2, fall, oceanography), contains(folder3, fall, nutrition), contains(folder4, fall, mathematics), contains(folder5, spring, mathematics), contains(folder6, spring, nutrition))) ::: (D)
is_valid(And(contains(folder1, spring, oceanography), contains(folder2, fall, oceanography), contains(folder3, spring, mathematics), contains(folder4, fall, mathematics), contains(folder5, fall, nutrition), contains(folder6, spring, nutrition))) ::: (E)"
"# Context:
A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.

# Question:
If the hobbyist selects a Y, which one of the following must be the group of fish she selects?

# Options:
A) G, H, K
B) H, J, K
C) H, J, L
D) H, K, L
E) J, K, L","# Declarations
fish = EnumSort([G, H, J, K, L])
plants = EnumSort([W, X, Y, Z])
selected_fish = Function([fish] -> [bool])
selected_plants = Function([plants] -> [bool])
# Constraints
ForAll([f:fish], Implies(selected_fish(f), Count([f:fish], selected_fish(f)) == 3)) ::: The hobbyist is stocking her aquarium with exactly three fish of different types.
ForAll([p:plants], Implies(selected_plants(p), Count([p:plants], selected_plants(p)) == 2)) ::: The hobbyist is stocking her aquarium with exactly two species of plants.
Implies(selected_fish(G), Not(selected_fish(H))) ::: If she selects the G, she can select neither the H nor a Y.
Implies(selected_fish(G), Not(selected_plants(Y))) ::: If she selects the G, she can select neither the H nor a Y.
Implies(Not(selected_fish(H)), Not(selected_fish(K))) ::: She cannot select the H unless she selects the K.
Implies(Not(selected_fish(J)), Not(selected_plants(W))) ::: She cannot select the J unless she selects a W.
Implies(selected_fish(K), selected_plants(X)) ::: If she selects the K, she must select an X.
# Options
is_valid(And(selected_fish(G), selected_fish(H), selected_fish(K))) ::: (A) G, H, K
is_valid(And(selected_fish(H), selected_fish(J), selected_fish(K))) ::: (B) H, J, K
is_valid(And(selected_fish(H), selected_fish(J), selected_fish(L))) ::: (C) H, J, L
is_valid(And(selected_fish(H), selected_fish(K), selected_fish(L))) ::: (D) H, K, L
is_valid(And(selected_fish(J), selected_fish(K), selected_fish(L))) ::: (E) J, K, L"
"# Context:
Petworld has exactly fourteen animals (three gerbils, three hamsters, three lizards, five snakes) that are kept in four separate cages (W, X, Y, Z) according to the following conditions: Each cage contains exactly two, four, or six animals. Any cage containing a gerbil also contains at least one hamster; any cage containing a hamster also contains at least one gerbil. Any cage containing a lizard also contains at least one snake; any cage containing a snake also contains at least one lizard. Neither cage Y nor cage Z contains a gerbil. Neither cage W nor cage X contains a lizard.

# Question:
At most, how many snakes can occupy cage Y at any one time?

# Options:
A) one
B) two
C) three
D) four
E) five","# Declarations
animals = EnumSort([gerbil1, gerbil2, gerbil3, hamster1, hamster2, hamster3, lizard1, lizard2, lizard3, snake1, snake2, snake3, snake4, snake5])
cages = EnumSort([W, X, Y, Z])
contains = Function([cages, animals] -> [bool])
count_animals_in_cage = Function([cages] -> [int])
count_gerbils_in_cage = Function([cages] -> [int])
count_hamsters_in_cage = Function([cages] -> [int])
count_lizards_in_cage = Function([cages] -> [int])
count_snakes_in_cage = Function([cages] -> [int])
# Constraints
ForAll([a:animals], Or(contains(W, a), contains(X, a), contains(Y, a), contains(Z, a))) ::: Each animal is in exactly one cage.
ForAll([c:cages], Or(count_animals_in_cage(c) == 2, count_animals_in_cage(c) == 4, count_animals_in_cage(c) == 6)) ::: Each cage contains exactly two, four, or six animals.
ForAll([c:cages], Implies(count_gerbils_in_cage(c) > 0, count_hamsters_in_cage(c) > 0)) ::: Any cage containing a gerbil also contains at least one hamster.
ForAll([c:cages], Implies(count_hamsters_in_cage(c) > 0, count_gerbils_in_cage(c) > 0)) ::: Any cage containing a hamster also contains at least one gerbil.
ForAll([c:cages], Implies(count_lizards_in_cage(c) > 0, count_snakes_in_cage(c) > 0)) ::: Any cage containing a lizard also contains at least one snake.
ForAll([c:cages], Implies(count_snakes_in_cage(c) > 0, count_lizards_in_cage(c) > 0)) ::: Any cage containing a snake also contains at least one lizard.
ForAll([a:animals], Not(And(contains(Y, a), a in [gerbil1, gerbil2, gerbil3]))) ::: Neither cage Y nor cage Z contains a gerbil.
ForAll([a:animals], Not(And(contains(Z, a), a in [gerbil1, gerbil2, gerbil3]))) ::: Neither cage Y nor cage Z contains a gerbil.
ForAll([a:animals], Not(And(contains(W, a), a in [lizard1, lizard2, lizard3]))) ::: Neither cage W nor cage X contains a lizard.
ForAll([a:animals], Not(And(contains(X, a), a in [lizard1, lizard2, lizard3]))) ::: Neither cage W nor cage X contains a lizard.
# Options
is_valid(count_snakes_in_cage(Y) <= 1) ::: (A) one
is_valid(count_snakes_in_cage(Y) <= 2) ::: (B) two
is_valid(count_snakes_in_cage(Y) <= 3) ::: (C) three
is_valid(count_snakes_in_cage(Y) <= 4) ::: (D) four
is_valid(count_snakes_in_cage(Y) <= 5) ::: (E) five"
"# Context:
Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.

# Question:
If Y is farther south than L and farther north than T, then the benches in each of the following pairs must be next to each other EXCEPT

# Options:
A) J and L
B) K and T
C) T and X
D) U and Y
E) X and Z","# Declarations
benches = EnumSort([J, K, L, T, U, X, Y, Z])
colors = EnumSort([green, red, pink])
color = Function([benches] -> [colors])
next_to = Function([benches, benches] -> [bool])
south_of = Function([benches, benches] -> [bool])
north_of = Function([benches, benches] -> [bool])
# Constraints
ForAll([b:benches], Implies(color(b) == green, Or(b == J, b == K, b == L))) ::: J, K, and L are green
ForAll([b:benches], Implies(color(b) == red, Or(b == T, b == U))) ::: T and U are red
ForAll([b:benches], Implies(color(b) == pink, Or(b == X, b == Y, b == Z))) ::: X, Y, and Z are pink
ForAll([b1:benches, b2:benches], Implies(next_to(b1, b2), next_to(b2, b1))) ::: Benches next to each other are mutual
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == green), next_to(b1, b2))) ::: Green benches stand next to one another
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == pink, color(b2) == pink), next_to(b1, b2))) ::: Pink benches stand next to one another
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == pink), Not(next_to(b1, b2)))) ::: No green bench stands next to a pink bench
Implies(next_to(T, X), Not(next_to(T, L))) ::: If T stands next to X, then T does not also stand next to L
south_of(T, J) ::: The bench on the southeast corner is T
north_of(J, T) ::: J stands at the center of the park's north side
south_of(Y, L) ::: Y is farther south than L
north_of(Y, T) ::: Y is farther north than T
# Options
is_unsat(next_to(J, L)) ::: (A) J and L
is_unsat(next_to(K, T)) ::: (B) K and T
is_unsat(next_to(T, X)) ::: (C) T and X
is_unsat(next_to(U, Y)) ::: (D) U and Y
is_unsat(next_to(X, Z)) ::: (E) X and Z"
"# Context:
Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.

# Question:
Which one of the following could be false in March?

# Options:
A) Sharon must visit Montreal if Paul visits Vancouver.
B) Regina must visit Vancouver if Paul visits Vancouver.
C) Regina visits a city with exactly two of the other four students.
D) Lori visits a city with exactly one of the other four students.
E) Lori visits a city with Paul or else with Sharon.","# Declarations
students = EnumSort([Hubert, Lori, Paul, Regina, Sharon])
cities = EnumSort([Montreal, Toronto, Vancouver])
visit = Function([students] -> [cities])
# Constraints
ForAll([s:students], Exists([c:cities], visit(s) == c)) ::: Each student visits exactly one of three cities.
visit(Sharon) != visit(Paul) ::: Sharon visits a different city than Paul.
visit(Hubert) == visit(Regina) ::: Hubert visits the same city as Regina.
Or(visit(Lori) == Montreal, visit(Lori) == Toronto) ::: Lori visits Montreal or else Toronto.
Implies(visit(Paul) == Vancouver, visit(Hubert) == Vancouver) ::: If Paul visits Vancouver, Hubert visits Vancouver with him.
ForAll([s:students], Exists([o:students], And(s != o, visit(s) == visit(o)))) ::: Each student visits one of the cities with at least one of the other four students.
# Options
is_unsat(Implies(visit(Paul) == Vancouver, visit(Sharon) == Montreal)) ::: (A) Sharon must visit Montreal if Paul visits Vancouver.
is_unsat(Implies(visit(Paul) == Vancouver, visit(Regina) == Vancouver)) ::: (B) Regina must visit Vancouver if Paul visits Vancouver.
is_unsat(Exists([c:cities], Count([s:students], visit(s) == c) == 3)) ::: (C) Regina visits a city with exactly two of the other four students.
is_unsat(Exists([c:cities], Count([s:students], visit(s) == c) == 2)) ::: (D) Lori visits a city with exactly one of the other four students.
is_unsat(Or(visit(Lori) == visit(Paul), visit(Lori) == visit(Sharon))) ::: (E) Lori visits a city with Paul or else with Sharon."
"# Context:
Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.

# Question:
For which one of the following benches are there two and no more than two locations either one of which could be the location the bench occupies?

# Options:
A) K
B) T
C) X
D) Y
E) Z","# Declarations
benches = EnumSort([J, K, L, T, U, X, Y, Z])
colors = EnumSort([green, red, pink])
locations = EnumSort([north, south, east, west, northeast, northwest, southeast, southwest])
color = Function([benches] -> [colors])
location = Function([benches] -> [locations])
next_to = Function([benches, benches] -> [bool])
# Constraints
ForAll([b:benches], Or(color(b) == green, color(b) == red, color(b) == pink)) ::: All benches are either green, red, or pink.
ForAll([b1:benches, b2:benches], next_to(b1, b2) == next_to(b2, b1)) ::: If bench b1 is next to bench b2, then bench b2 is next to bench b1.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == pink), Not(next_to(b1, b2)))) ::: No green bench stands next to a pink bench.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == green), next_to(b1, b2))) ::: The green benches stand next to one another.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == pink, color(b2) == pink), next_to(b1, b2))) ::: The pink benches stand next to one another.
location(T) == southeast ::: The bench on the southeast corner is T.
location(J) == north ::: J stands at the center of the park's north side.
Implies(next_to(T, X), Not(next_to(T, L))) ::: If T stands next to X, then T does not also stand next to L.
# Options
is_valid(Count([l:locations], location(K) == l) == 2) ::: (A) K
is_valid(Count([l:locations], location(T) == l) == 2) ::: (B) T
is_valid(Count([l:locations], location(X) == l) == 2) ::: (C) X
is_valid(Count([l:locations], location(Y) == l) == 2) ::: (D) Y
is_valid(Count([l:locations], location(Z) == l) == 2) ::: (E) Z"
"# Context:
Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.

# Question:
Each of the following statements must be true EXCEPT:

# Options:
A) The bench on the northwest corner is pink.
B) The bench on the northeast corner is green.
C) The bench on the southwest corner is pink.
D) The middle bench on the east side of the park is green.
E) The middle bench on the west side of the park is pink.","# Declarations
benches = EnumSort([J, K, L, T, U, X, Y, Z])
colors = EnumSort([green, red, pink])
corners = EnumSort([northwest, northeast, southeast, southwest])
sides = EnumSort([north, east, south, west])
color = Function([benches] -> [colors])
corner_bench = Function([corners] -> [benches])
side_bench = Function([sides] -> [benches])
next_to = Function([benches, benches] -> [bool])
# Constraints
ForAll([b:benches], Or(color(b) == green, color(b) == red, color(b) == pink)) ::: All benches are either green, red, or pink.
ForAll([b1:benches, b2:benches], next_to(b1, b2)) ::: If b1 is next to b2, then b2 is next to b1.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == pink), Not(next_to(b1, b2)))) ::: No green bench stands next to a pink bench.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == green, color(b2) == green), next_to(b1, b2))) ::: The green benches stand next to one another.
ForAll([b1:benches, b2:benches], Implies(And(color(b1) == pink, color(b2) == pink), next_to(b1, b2))) ::: The pink benches stand next to one another.
color(J) == green ::: J is green.
color(K) == green ::: K is green.
color(L) == green ::: L is green.
color(T) == red ::: T is red.
color(U) == red ::: U is red.
color(X) == pink ::: X is pink.
color(Y) == pink ::: Y is pink.
color(Z) == pink ::: Z is pink.
corner_bench(southeast) == T ::: The bench on the southeast corner is T.
side_bench(north) == J ::: J stands at the center of the park's north side.
Implies(next_to(T, X), Not(next_to(T, L))) ::: If T stands next to X, then T does not also stand next to L.
# Options
is_unsat(color(corner_bench(northwest)) == pink) ::: (A) The bench on the northwest corner is pink.
is_unsat(color(corner_bench(northeast)) == green) ::: (B) The bench on the northeast corner is green.
is_unsat(color(corner_bench(southwest)) == pink) ::: (C) The bench on the southwest corner is pink.
is_unsat(color(side_bench(east)) == green) ::: (D) The middle bench on the east side of the park is green.
is_unsat(color(side_bench(west)) == pink) ::: (E) The middle bench on the west side of the park is pink."
"# Context:
A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.

# Question:
If Ping received more votes than Jazz, then what is the maximum possible number of names whose ranks can be determined?

# Options:
A) two
B) three
C) four
D) five
E) six","# Declarations
soda_names = EnumSort([Jazz, Kola, Luck, Mist, Nipi, Oboy, Ping])
votes = Function([soda_names] -> [int])
# Constraints
votes(Jazz) > votes(Oboy) ::: Jazz received more votes than Oboy.
votes(Oboy) > votes(Kola) ::: Oboy received more votes than Kola.
votes(Kola) > votes(Mist) ::: Kola received more votes than Mist.
votes(Nipi) > votes(Mist) ::: Nipi did not receive the fewest votes.
votes(Ping) < votes(Luck) ::: Ping received fewer votes than Luck.
votes(Ping) > votes(Nipi) ::: Ping received more votes than Nipi.
votes(Ping) > votes(Oboy) ::: Ping received more votes than Oboy.
# Options
is_valid(Count([s:soda_names], And(votes(Jazz) > votes(Oboy), votes(Oboy) > votes(Kola), votes(Kola) > votes(Mist), votes(Ping) > votes(Nipi), votes(Ping) > votes(Oboy), votes(Ping) < votes(Luck))) == 5) ::: (D) five"
"# Context:
A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.

# Question:
If the crew cleaned Second Street earlier in the week than Seventh Street, then it must have cleaned which one of the following streets on Tuesday afternoon?

# Options:
A) First Street
B) Second Street
C) Third Street
D) Fifth Street
E) Eighth Street","# Declarations
streets = EnumSort([First, Second, Third, Fourth, Fifth, Sixth, Seventh, Eighth])
days = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])
times = EnumSort([Morning, Afternoon])
cleaned = Function([streets, days, times] -> [bool])
# Constraints
ForAll([s:streets, d:days, t:times], And(cleaned(s, d, t), Or(d != Friday, t != Morning))) ::: The crew cleaned no street on Friday morning.
ForAll([s:streets, d:days, t:times], And(cleaned(s, d, t), Or(d != Wednesday, t != Afternoon))) ::: The crew cleaned no street on Wednesday afternoon.
cleaned(Fourth, Tuesday, Morning) ::: It cleaned Fourth Street on Tuesday morning.
cleaned(Seventh, Thursday, Morning) ::: It cleaned Seventh Street on Thursday morning.
ForAll([s:streets, d:days, t:times], And(cleaned(s, d, t), Implies(t == Afternoon, Or(s == Second, s == Fifth, s == Eighth)))) ::: It cleaned Second, Fifth, and Eighth streets on afternoons.
Exists([d:days, t:times], And(cleaned(Sixth, d, t), cleaned(Fourth, d, t))) ::: It cleaned Fourth Street before Sixth Street.
Exists([d:days, t:times], And(cleaned(Eighth, d, t), cleaned(Fourth, d, t))) ::: It cleaned Fourth Street after Eighth Street.
Count([s:streets, d:days, t:times], cleaned(s, d, t)) == 8 ::: During one week the crew cleaned exactly eight streets.
# Options
is_valid(cleaned(First, Tuesday, Afternoon)) ::: (A)
is_unsat(cleaned(Second, Tuesday, Afternoon)) ::: (B)
is_valid(cleaned(Third, Tuesday, Afternoon)) ::: (C)
is_unsat(cleaned(Fifth, Tuesday, Afternoon)) ::: (D)
is_unsat(cleaned(Eighth, Tuesday, Afternoon)) ::: (E)"
"# Context:
A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.

# Question:
If the crew cleaned First Street earlier in the week than Third Street, then which one of the following statements must be false?

# Options:
A) The crew cleaned First Street on Tuesday afternoon.
B) The crew cleaned Second Street on Thursday afternoon.
C) The crew cleaned Third Street on Wednesday morning.
D) The crew cleaned Fifth Street on Thursday afternoon.
E) The crew cleaned Sixth Street on Friday afternoon.","# Declarations
streets = EnumSort([First, Second, Third, Fourth, Fifth, Sixth, Seventh, Eighth])
days = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])
times = EnumSort([morning, afternoon])
cleaned = Function([streets, days, times] -> [bool])
# Constraints
ForAll([s:streets, d:days, t:times], Implies(cleaned(s, d, t), Or(d != Friday, t != morning))) ::: The crew cleaned no street on Friday morning.
ForAll([s:streets, d:days, t:times], Implies(cleaned(s, d, t), Or(d != Wednesday, t != afternoon))) ::: The crew cleaned no street on Wednesday afternoon.
cleaned(Fourth, Tuesday, morning) ::: It cleaned Fourth Street on Tuesday morning.
cleaned(Seventh, Thursday, morning) ::: It cleaned Seventh Street on Thursday morning.
ForAll([d:days, t:times], Implies(cleaned(Fourth, d, t), Implies(cleaned(Sixth, d, t), False))) ::: It cleaned Fourth Street before Sixth Street.
ForAll([d:days, t:times], Implies(cleaned(Sixth, d, t), Implies(cleaned(Fourth, d, t), False))) ::: It cleaned Fourth Street before Sixth Street.
ForAll([d:days, t:times], Implies(cleaned(Eighth, d, t), Implies(cleaned(Fourth, d, t), False))) ::: It cleaned Fourth Street after Eighth Street.
ForAll([d:days, t:times], Implies(cleaned(Fourth, d, t), Implies(cleaned(Eighth, d, t), False))) ::: It cleaned Fourth Street after Eighth Street.
ForAll([s:streets, d:days, t:times], Implies(cleaned(s, d, t), Implies(t == afternoon, Or(s == Second, s == Fifth, s == Eighth)))) ::: It cleaned Second, Fifth, and Eighth streets on afternoons.
Count([s:streets, d:days, t:times], cleaned(s, d, t)) == 8 ::: During one week the crew cleaned exactly eight streets.
# Options
is_unsat(cleaned(First, Tuesday, afternoon)) ::: (A) The crew cleaned First Street on Tuesday afternoon.
is_unsat(cleaned(Second, Thursday, afternoon)) ::: (B) The crew cleaned Second Street on Thursday afternoon.
is_unsat(cleaned(Third, Wednesday, morning)) ::: (C) The crew cleaned Third Street on Wednesday morning.
is_unsat(cleaned(Fifth, Thursday, afternoon)) ::: (D) The crew cleaned Fifth Street on Thursday afternoon.
is_unsat(cleaned(Sixth, Friday, afternoon)) ::: (E) The crew cleaned Sixth Street on Friday afternoon."
"# Context:
A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.

# Question:
If the hobbyist selects the H, which one of the following must also be true?

# Options:
A) She selects at least one W.
B) She selects at least one X.
C) She selects the J, but no Y's.
D) She selects the K, but no X's.
E) She selects at least one X, but no Y's.","# Declarations
fish = EnumSort([G, H, J, K, L])
plants = EnumSort([W, X, Y, Z])
selected_fish = Function([fish] -> [bool])
selected_plants = Function([plants] -> [bool])
# Constraints
ForAll([f:fish], Implies(selected_fish(f), Count([f2:fish], selected_fish(f2)) == 3)) ::: The hobbyist is stocking her aquarium with exactly three fish of different types.
ForAll([p:plants], Implies(selected_plants(p), Count([p2:plants], selected_plants(p2)) == 2)) ::: The hobbyist is stocking her aquarium with exactly two species of plants.
Implies(selected_fish(G), Not(selected_fish(H))) ::: If she selects the G, she can select neither the H nor a Y.
Implies(selected_fish(G), Not(selected_plants(Y))) ::: If she selects the G, she can select neither the H nor a Y.
Implies(Not(selected_fish(H)), Not(selected_fish(K))) ::: She cannot select the H unless she selects the K.
Implies(Not(selected_fish(J)), Not(selected_plants(W))) ::: She cannot select the J unless she selects a W.
Implies(selected_fish(K), selected_plants(X)) ::: If she selects the K, she must select an X.
# Options
is_valid(Implies(selected_fish(H), Exists([p:plants], And(selected_plants(p), p == W)))) ::: (A) She selects at least one W.
is_valid(Implies(selected_fish(H), Exists([p:plants], And(selected_plants(p), p == X)))) ::: (B) She selects at least one X.
is_valid(Implies(selected_fish(H), And(selected_fish(J), ForAll([p:plants], Not(And(selected_plants(p), p == Y)))))) ::: (C) She selects the J, but no Y's.
is_valid(Implies(selected_fish(H), And(selected_fish(K), ForAll([p:plants], Not(And(selected_plants(p), p == X)))))) ::: (D) She selects the K, but no X's.
is_valid(Implies(selected_fish(H), And(Exists([p:plants], And(selected_plants(p), p == X)), ForAll([p:plants], Not(And(selected_plants(p), p == Y)))))) ::: (E) She selects at least one X, but no Y's."
"# Context:
A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.

# Question:
Which one of the following partners cannot have the third highest salary?

# Options:
A) Fox
B) Inman
C) Lopez
D) Malloy
E) Nassar","# Declarations
partners = EnumSort([Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, Nassar])
salary = Function([partners] -> [int])
# Constraints
ForAll([p:partners], salary(p) > 0) ::: All partners have a positive salary.
salary(Kohn) > salary(Inman) ::: Kohn's salary is greater than Inman's.
salary(Kohn) > salary(Lopez) ::: Kohn's salary is greater than Lopez's.
salary(Lopez) > salary(Nassar) ::: Lopez's salary is greater than Nassar's.
salary(Inman) > salary(Fox) ::: Inman's salary is greater than Fox's.
salary(Fox) > salary(Malloy) ::: Fox's salary is greater than Malloy's.
salary(Malloy) > salary(Glassen) ::: Malloy's salary is greater than Glassen's.
salary(Glassen) > salary(Jacoby) ::: Glassen's salary is greater than Jacoby's.
salary(Jacoby) > salary(Hae) ::: Jacoby's salary is greater than Hae's.
# Options
is_unsat(And(salary(Fox) > salary(Inman), salary(Fox) > salary(Lopez), salary(Fox) > salary(Malloy), salary(Fox) > salary(Nassar), salary(Fox) > salary(Glassen), salary(Fox) > salary(Jacoby), salary(Fox) > salary(Hae))) ::: (A) Fox cannot have the third highest salary.
is_unsat(And(salary(Inman) > salary(Fox), salary(Inman) > salary(Lopez), salary(Inman) > salary(Malloy), salary(Inman) > salary(Nassar), salary(Inman) > salary(Glassen), salary(Inman) > salary(Jacoby), salary(Inman) > salary(Hae))) ::: (B) Inman cannot have the third highest salary.
is_unsat(And(salary(Lopez) > salary(Fox), salary(Lopez) > salary(Inman), salary(Lopez) > salary(Malloy), salary(Lopez) > salary(Nassar), salary(Lopez) > salary(Glassen), salary(Lopez) > salary(Jacoby), salary(Lopez) > salary(Hae))) ::: (C) Lopez cannot have the third highest salary.
is_unsat(And(salary(Malloy) > salary(Fox), salary(Malloy) > salary(Inman), salary(Malloy) > salary(Lopez), salary(Malloy) > salary(Nassar), salary(Malloy) > salary(Glassen), salary(Malloy) > salary(Jacoby), salary(Malloy) > salary(Hae))) ::: (D) Malloy cannot have the third highest salary.
is_unsat(And(salary(Nassar) > salary(Fox), salary(Nassar) > salary(Inman), salary(Nassar) > salary(Lopez), salary(Nassar) > salary(Malloy), salary(Nassar) > salary(Glassen), salary(Nassar) > salary(Jacoby), salary(Nassar) > salary(Hae))) ::: (E) Nassar cannot have the third highest salary."
"# Context:
Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.

# Question:
If Cindy and Fran are the only people in one of the planes, which one of the following must be true?

# Options:
A) Bob flies with Anna.
B) Dave flies with Ed.
C) Dave and Ed fly with Bob.
D) Dave flies with Bob.
E) Ed flies with Anna.","# Declarations
planes = EnumSort([plane1, plane2, plane3, plane4])
pilots = EnumSort([Anna, Bob, Cindy])
copilots = EnumSort([Dave, Ed, Fran])
flies_in = Function([pilots, planes] -> [bool])
flies_with = Function([copilots, planes] -> [bool])
# Constraints
ForAll([p:planes], Exists([pi:pilots], flies_in(pi, p))) ::: No plane flies in the show without a qualified pilot aboard.
ForAll([p:planes], ForAll([pi:pilots], Implies(flies_in(pi, p), Or(p == plane1, p == plane2, p == plane3, p == plane4)))) ::: Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show.
ForAll([p:planes], ForAll([co:copilots], Implies(flies_with(co, p), Or(p == plane1, p == plane2, p == plane3, p == plane4)))) ::: Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show.
Or(flies_in(Anna, plane1), flies_in(Anna, plane4)) ::: Anna will only fly in either plane 1 or plane 4.
Or(flies_with(Dave, plane2), flies_with(Dave, plane3)) ::: Dave will only fly in either plane 2 or plane 3.
# Options
is_valid(And(flies_in(Bob, plane1), flies_in(Anna, plane1))) ::: (A) Bob flies with Anna.
is_valid(And(flies_with(Dave, plane2), flies_with(Ed, plane2))) ::: (B) Dave flies with Ed.
is_valid(And(flies_in(Bob, plane3), flies_with(Dave, plane3), flies_with(Ed, plane3))) ::: (C) Dave and Ed fly with Bob.
is_valid(And(flies_in(Bob, plane2), flies_with(Dave, plane2))) ::: (D) Dave flies with Bob.
is_valid(And(flies_in(Anna, plane4), flies_with(Ed, plane4))) ::: (E) Ed flies with Anna."
"# Context:
Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.

# Question:
If as many of the pilots and copilots as possible fly in plane 4, that group will consist of

# Options:
A) exactly two people
B) exactly three people
C) exactly four people
D) exactly five people
E) three pilots and two copilots","# Declarations
planes = EnumSort([plane1, plane2, plane3, plane4])
pilots = EnumSort([Anna, Bob, Cindy])
copilots = EnumSort([Dave, Ed, Fran])
flies_in = Function([pilots, planes] -> [bool])
flies_in_copilot = Function([copilots, planes] -> [bool])
# Constraints
ForAll([p:pilots], Exists([pl:planes], flies_in(p, pl))) ::: Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show.
ForAll([c:copilots], Exists([pl:planes], flies_in_copilot(c, pl))) ::: Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show.
ForAll([pl:planes], Exists([p:pilots], flies_in(p, pl))) ::: No plane flies in the show without a qualified pilot aboard.
ForAll([pl:planes], ForAll([p:pilots], Implies(flies_in(p, pl), Not(Exists([c:copilots], flies_in_copilot(c, pl)))))) ::: No one but qualified pilots and qualified copilots flies in the show.
Or(flies_in(Anna, plane1), flies_in(Anna, plane4)) ::: Anna will only fly in either plane 1 or plane 4.
Or(flies_in_copilot(Dave, plane2), flies_in_copilot(Dave, plane3)) ::: Dave will only fly in either plane 2 or plane 3.
# Options
is_sat(Count([p:pilots, c:copilots], Or(flies_in(p, plane4), flies_in_copilot(c, plane4))) == 2) ::: (A) exactly two people
is_sat(Count([p:pilots, c:copilots], Or(flies_in(p, plane4), flies_in_copilot(c, plane4))) == 3) ::: (B) exactly three people
is_sat(Count([p:pilots, c:copilots], Or(flies_in(p, plane4), flies_in_copilot(c, plane4))) == 4) ::: (C) exactly four people
is_sat(Count([p:pilots, c:copilots], Or(flies_in(p, plane4), flies_in_copilot(c, plane4))) == 5) ::: (D) exactly five people
is_sat(And(Count([p:pilots], flies_in(p, plane4)) == 3, Count([c:copilots], flies_in_copilot(c, plane4)) == 2)) ::: (E) three pilots and two copilots"
"# Context:
Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.

# Question:
If Walter has exactly two of the three symptoms, then he cannot have all of the symptoms of

# Options:
A) both illness J and illness L
B) both illness J and illness N
C) both illness K and illness L
D) both illness K and illness N
E) both illness L and illness N","# Declarations
illnesses = EnumSort([J, K, L, M, N])
symptoms = EnumSort([fever, headache, sneezing])
has_symptom = Function([illnesses, symptoms] -> [bool])
# Constraints
ForAll([i:illnesses], Or(has_symptom(i, fever), has_symptom(i, headache), has_symptom(i, sneezing))) ::: Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing.
ForAll([i:illnesses, s:symptoms], Implies(has_symptom(i, s), Or(s == fever, s == headache, s == sneezing))) ::: None of the illnesses has any symptom that is not one of these three.
And(has_symptom(J, headache), has_symptom(J, sneezing)) ::: Illness J is characterized by headache and sneezing.
ForAll([s:symptoms], Not(And(has_symptom(J, s), has_symptom(K, s)))) ::: Illnesses J and K have no symptoms in common.
Exists([s:symptoms], And(has_symptom(J, s), has_symptom(L, s))) ::: Illnesses J and L have at least one symptom in common.
Count([s:symptoms], has_symptom(L, s)) > Count([s:symptoms], has_symptom(K, s)) ::: Illness L has a greater number of symptoms than illness K.
ForAll([s:symptoms], Not(And(has_symptom(L, s), has_symptom(N, s)))) ::: Illnesses L and N have no symptoms in common.
Count([s:symptoms], has_symptom(M, s)) > Count([s:symptoms], has_symptom(J, s)) ::: Illness M has more symptoms than illness J.
# Options
is_unsat(And(Count([s:symptoms], has_symptom(J, s)) == 2, Count([s:symptoms], has_symptom(L, s)) == 2)) ::: (A) both illness J and illness L
is_unsat(And(Count([s:symptoms], has_symptom(J, s)) == 2, Count([s:symptoms], has_symptom(N, s)) == 2)) ::: (B) both illness J and illness N
is_unsat(And(Count([s:symptoms], has_symptom(K, s)) == 2, Count([s:symptoms], has_symptom(L, s)) == 2)) ::: (C) both illness K and illness L
is_unsat(And(Count([s:symptoms], has_symptom(K, s)) == 2, Count([s:symptoms], has_symptom(N, s)) == 2)) ::: (D) both illness K and illness N
is_unsat(And(Count([s:symptoms], has_symptom(L, s)) == 2, Count([s:symptoms], has_symptom(N, s)) == 2)) ::: (E) both illness L and illness N"
"# Context:
Exactly six dogs—P, Q, R, S, T, and U—are entered in a dog show. The judge of the show awards exactly four ribbons, one for each of first, second, third, and fourth places, to four of the dogs. The information that follows is all that is available about the six dogs: Each dog is either a greyhound or a labrador, but not both. Two of the six dogs are female and four are male. The judge awards ribbons to both female dogs, exactly one of which is a labrador. Exactly one labrador wins a ribbon. Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T. Dogs P and R are greyhounds. Dogs S and U are labradors.

# Question:
Which one of the following dogs must be male?

# Options:
A) dog P
B) dog R
C) dog S
D) dog T
E) dog U","# Declarations
dogs = EnumSort([P, Q, R, S, T, U])
gender = EnumSort([male, female])
breed = EnumSort([greyhound, labrador])
places = EnumSort([first, second, third, fourth])
ribbon = Function([dogs] -> [bool])
dog_gender = Function([dogs] -> [gender])
dog_breed = Function([dogs] -> [breed])
# Constraints
ForAll([d:dogs], Or(dog_breed(d) == greyhound, dog_breed(d) == labrador)) ::: Each dog is either a greyhound or a labrador, but not both.
Count([d:dogs], dog_gender(d) == female) == 2 ::: Two of the six dogs are female and four are male.
Exists([d:dogs], And(dog_gender(d) == female, dog_breed(d) == labrador, ribbon(d))) ::: The judge awards ribbons to both female dogs, exactly one of which is a labrador.
Exists([d:dogs], And(dog_breed(d) == labrador, ribbon(d))) ::: Exactly one labrador wins a ribbon.
ribbon(P) ::: Dogs P and R place ahead of dog S.
ribbon(R) ::: Dogs P and R place ahead of dog S.
Not(ribbon(S)) ::: Dog S places ahead of dogs Q and T.
Not(ribbon(Q)) ::: Dog S places ahead of dogs Q and T.
Not(ribbon(T)) ::: Dog S places ahead of dogs Q and T.
dog_breed(P) == greyhound ::: Dogs P and R are greyhounds.
dog_breed(R) == greyhound ::: Dogs P and R are greyhounds.
dog_breed(S) == labrador ::: Dogs S and U are labradors.
dog_breed(U) == labrador ::: Dogs S and U are labradors.
# Options
is_sat(dog_gender(P) == male) ::: (A) dog P
is_sat(dog_gender(R) == male) ::: (B) dog R
is_sat(dog_gender(S) == male) ::: (C) dog S
is_sat(dog_gender(T) == male) ::: (D) dog T
is_sat(dog_gender(U) == male) ::: (E) dog U"
"# Context:
The eight partners of a law firm are Gregg, Hodges, Ivan, James, King, MacNeil, Nader, and Owens. In each of the years 1961 through 1968, exactly one of the partners joined the firm. Hodges joined the firm before Nader. King joined the firm before James. Nader and James joined the firm before Gregg. Nader joined the firm before Owens. James joined the firm before MacNeil. Gregg joined the firm before Ivan.

# Question:
Which one of the following CANNOT be true?

# Options:
A) Hodges joined the law firm in 1961.
B) Hodges joined the law firm in 1963.
C) Gregg joined the law firm in 1964.
D) MacNeil joined the law firm in 1964.
E) Owens joined the law firm in 1964.","# Declarations
partners = EnumSort([Gregg, Hodges, Ivan, James, King, MacNeil, Nader, Owens])
years = EnumSort([1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968])
joined = Function([partners] -> [years])
# Constraints
ForAll([p:partners], Exists([y:years], joined(p) == y)) ::: In each of the years 1961 through 1968, exactly one of the partners joined the firm.
joined(Hodges) < joined(Nader) ::: Hodges joined the firm before Nader.
joined(King) < joined(James) ::: King joined the firm before James.
And(joined(Nader) < joined(Gregg), joined(James) < joined(Gregg)) ::: Nader and James joined the firm before Gregg.
joined(Nader) < joined(Owens) ::: Nader joined the firm before Owens.
joined(James) < joined(MacNeil) ::: James joined the firm before MacNeil.
joined(Gregg) < joined(Ivan) ::: Gregg joined the firm before Ivan.
# Options
is_unsat(joined(Hodges) == 1961) ::: (A) Hodges joined the law firm in 1961.
is_unsat(joined(Hodges) == 1963) ::: (B) Hodges joined the law firm in 1963.
is_unsat(joined(Gregg) == 1964) ::: (C) Gregg joined the law firm in 1964.
is_unsat(joined(MacNeil) == 1964) ::: (D) MacNeil joined the law firm in 1964.
is_unsat(joined(Owens) == 1964) ::: (E) Owens joined the law firm in 1964."
"# Context:
A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.

# Question:
Which one of the following statements could be true?

# Options:
A) No January ticket is green.
B) No February ticket is green.
C) Only line 2 tickets are red.
D) One set of January tickets is green and one set of January tickets is yellow.
E) The line 2 tickets for January are the same color as the line 1 tickets for February.","# Declarations
lines = EnumSort([line1, line2, line3])
months = EnumSort([January, February])
colors = EnumSort([green, purple, red, yellow])
ticket_color = Function([lines, months] -> [colors])
# Constraints
ForAll([l:lines, m:months], Exists([c:colors], ticket_color(l, m) == c)) ::: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow.
ForAll([l:lines], ticket_color(l, January) != ticket_color(l, February)) ::: For each line, the January tickets are a different color than the February tickets.
ForAll([m:months], And(ticket_color(line1, m) != ticket_color(line2, m), ticket_color(line1, m) != ticket_color(line3, m), ticket_color(line2, m) != ticket_color(line3, m))) ::: For each month, tickets for different lines are in different colors.
Exists([l:lines], ticket_color(l, January) == red) ::: Exactly one set of January tickets is red.
Or(ticket_color(line3, January) == green, ticket_color(line3, February) == green) & Not(And(ticket_color(line3, January) == green, ticket_color(line3, February) == green)) ::: For line 3, either the January tickets or the February tickets, but not both, are green.
ticket_color(line2, January) == purple ::: The January tickets for line 2 are purple.
ForAll([l:lines], ticket_color(l, February) != purple) ::: No February tickets are purple.
# Options
is_sat(ForAll([l:lines, m:months], ticket_color(l, m) != green)) ::: (A) No January ticket is green.
is_sat(ForAll([l:lines, m:months], ticket_color(l, m) != green)) ::: (B) No February ticket is green.
is_sat(ForAll([l:lines, m:months], Implies(ticket_color(l, m) == red, l == line2))) ::: (C) Only line 2 tickets are red.
is_sat(Exists([l1:lines], ticket_color(l1, January) == green) & Exists([l2:lines], ticket_color(l2, January) == yellow)) ::: (D) One set of January tickets is green and one set of January tickets is yellow.
is_sat(ticket_color(line2, January) == ticket_color(line1, February)) ::: (E) The line 2 tickets for January are the same color as the line 1 tickets for February."
"# Context:
Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.

# Question:
If Bob and Anna fly on the same plane, which one of the following must be true?

# Options:
A) Cindy flies with Dave and Ed.
B) Cindy flies with Ed.
C) Dave flies with Cindy.
D) Dave flies with Cindy, Ed, and Fran.
E) Fran flies with Ed.","# Declarations
planes = EnumSort([plane1, plane2, plane3, plane4])
pilots = EnumSort([Anna, Bob, Cindy])
copilots = EnumSort([Dave, Ed, Fran])
flies_in = Function([pilots, planes] -> [bool])
flies_with = Function([copilots, planes] -> [bool])
# Constraints
ForAll([p:pilots], Exists([pl:planes], flies_in(p, pl))) ::: Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show.
ForAll([c:copilots], Exists([pl:planes], flies_with(c, pl))) ::: Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show.
ForAll([pl:planes], Exists([p:pilots], flies_in(p, pl))) ::: No plane flies in the show without a qualified pilot aboard.
ForAll([pl:planes], ForAll([p:pilots], Implies(flies_in(p, pl), Not(Exists([c:copilots], flies_with(c, pl)))))) ::: No one but qualified pilots and qualified copilots flies in the show.
Or(flies_in(Anna, plane1), flies_in(Anna, plane4)) ::: Anna will only fly in either plane 1 or plane 4.
Or(flies_with(Dave, plane2), flies_with(Dave, plane3)) ::: Dave will only fly in either plane 2 or plane 3.
# Options
is_valid(Exists([pl:planes], And(flies_in(Cindy, pl), flies_with(Dave, pl), flies_with(Ed, pl)))) ::: (A) Cindy flies with Dave and Ed.
is_valid(Exists([pl:planes], And(flies_in(Cindy, pl), flies_with(Ed, pl)))) ::: (B) Cindy flies with Ed.
is_valid(Exists([pl:planes], And(flies_in(Cindy, pl), flies_with(Dave, pl)))) ::: (C) Dave flies with Cindy.
is_valid(Exists([pl:planes], And(flies_in(Cindy, pl), flies_with(Dave, pl), flies_with(Ed, pl), flies_with(Fran, pl)))) ::: (D) Dave flies with Cindy, Ed, and Fran.
is_valid(Exists([pl:planes], And(flies_with(Fran, pl), flies_with(Ed, pl)))) ::: (E) Fran flies with Ed."
"# Context:
Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.

# Question:
If none of the six people orders pork chops, then which one of the following statements must be true?

# Options:
A) John orders veal cutlet.
B) Kate orders tilefish.
C) Lewis orders tilefish.
D) One of the men orders swordfish.
E) One of the women orders tilefish.","# Declarations
people = EnumSort([John, Kate, Lewis, Marie, Nat, Olive])
entrees = EnumSort([pork_chops, roast_beef, swordfish, tilefish, veal_cutlet])
order = Function([people] -> [entrees])
# Constraints
ForAll([p1:people, p2:people], Implies(p1 != p2, order(p1) != order(p2))) ::: The two people in each couple do not order the same kind of entree as each other.
ForAll([m1:people, m2:people], Implies(m1 != m2, order(m1) != order(m2))) ::: None of the men orders the same kind of entree as any of the other men.
order(Marie) == swordfish ::: Marie orders swordfish.
And(order(John) != swordfish, order(John) != tilefish, order(Nat) != swordfish, order(Nat) != tilefish) ::: Neither John nor Nat orders a fish entree.
order(Olive) == roast_beef ::: Olive orders roast beef.
ForAll([p:people], order(p) != pork_chops) ::: None of the six people orders pork chops.
# Options
is_valid(order(John) == veal_cutlet) ::: (A)
is_valid(order(Kate) == tilefish) ::: (B)
is_valid(order(Lewis) == tilefish) ::: (C)
is_valid(Exists([m:people], order(m) == swordfish)) ::: (D)
is_valid(Exists([w:people], order(w) == tilefish)) ::: (E)"
"# Context:
Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.

# Question:
Which one of the following statements could be true?

# Options:
A) John orders the same kind of entree as Marie does.
B) Kate orders the same kind of entree as Nat does.
C) Lewis orders the same kind of entree as Nat does.
D) Marie orders the same kind of entree as Olive does.
E) Nat orders the same kind of entree as Olive does.","# Declarations
people = EnumSort([John, Kate, Lewis, Marie, Nat, Olive])
entrees = EnumSort([pork_chops, roast_beef, swordfish, tilefish, veal_cutlet])
order = Function([people] -> [entrees])
# Constraints
ForAll([p1:people, p2:people], Implies(p1 != p2, order(p1) != order(p2))) ::: The two people in each couple do not order the same kind of entree as each other.
ForAll([m1:people, m2:people], Implies(And(m1 != m2, Or(m1 == John, m1 == Lewis, m1 == Nat), Or(m2 == John, m2 == Lewis, m2 == Nat)), order(m1) != order(m2))) ::: None of the men orders the same kind of entree as any of the other men.
order(Marie) == swordfish ::: Marie orders swordfish.
And(order(John) != swordfish, order(John) != tilefish, order(Nat) != swordfish, order(Nat) != tilefish) ::: Neither John nor Nat orders a fish entree.
order(Olive) == roast_beef ::: Olive orders roast beef.
# Options
is_unsat(order(John) == order(Marie)) ::: (A)
is_unsat(order(Kate) == order(Nat)) ::: (B)
is_unsat(order(Lewis) == order(Nat)) ::: (C)
is_unsat(order(Marie) == order(Olive)) ::: (D)
is_sat(order(Nat) == order(Olive)) ::: (E)"
"# Context:
Exactly six dogs—P, Q, R, S, T, and U—are entered in a dog show. The judge of the show awards exactly four ribbons, one for each of first, second, third, and fourth places, to four of the dogs. The information that follows is all that is available about the six dogs: Each dog is either a greyhound or a labrador, but not both. Two of the six dogs are female and four are male. The judge awards ribbons to both female dogs, exactly one of which is a labrador. Exactly one labrador wins a ribbon. Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T. Dogs P and R are greyhounds. Dogs S and U are labradors.

# Question:
Which one of the following statements could be true?

# Options:
A) Dog P does not win a ribbon.
B) Dog R does not win a ribbon.
C) Dog S does not win a ribbon.
D) Dog T wins a ribbon.
E) Dog U wins a ribbon.","# Declarations
dogs = EnumSort([P, Q, R, S, T, U])
gender = EnumSort([male, female])
breed = EnumSort([greyhound, labrador])
places = EnumSort([first, second, third, fourth])
ribbon = Function([dogs] -> [bool])
dog_gender = Function([dogs] -> [gender])
dog_breed = Function([dogs] -> [breed])
dog_place = Function([dogs] -> [places])
# Constraints
ForAll([d:dogs], Or(dog_breed(d) == greyhound, dog_breed(d) == labrador)) ::: Each dog is either a greyhound or a labrador, but not both.
Count([d:dogs], dog_gender(d) == female) == 2 ::: Two of the six dogs are female and four are male.
Exists([d:dogs], And(dog_gender(d) == female, dog_breed(d) == labrador)) ::: The judge awards ribbons to both female dogs, exactly one of which is a labrador.
Count([d:dogs], And(ribbon(d), dog_breed(d) == labrador)) == 1 ::: Exactly one labrador wins a ribbon.
ribbon(P) ::: Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T.
ribbon(R) ::: Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T.
Not(ribbon(S)) ::: Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T.
Not(ribbon(Q)) ::: Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T.
Not(ribbon(T)) ::: Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T.
dog_breed(P) == greyhound ::: Dogs P and R are greyhounds.
dog_breed(R) == greyhound ::: Dogs P and R are greyhounds.
dog_breed(S) == labrador ::: Dogs S and U are labradors.
dog_breed(U) == labrador ::: Dogs S and U are labradors.
# Options
is_sat(Not(ribbon(P))) ::: (A) Dog P does not win a ribbon.
is_sat(Not(ribbon(R))) ::: (B) Dog R does not win a ribbon.
is_sat(Not(ribbon(S))) ::: (C) Dog S does not win a ribbon.
is_sat(ribbon(T)) ::: (D) Dog T wins a ribbon.
is_sat(ribbon(U)) ::: (E) Dog U wins a ribbon."
"# Context:
Exactly six dogs—P, Q, R, S, T, and U—are entered in a dog show. The judge of the show awards exactly four ribbons, one for each of first, second, third, and fourth places, to four of the dogs. The information that follows is all that is available about the six dogs: Each dog is either a greyhound or a labrador, but not both. Two of the six dogs are female and four are male. The judge awards ribbons to both female dogs, exactly one of which is a labrador. Exactly one labrador wins a ribbon. Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T. Dogs P and R are greyhounds. Dogs S and U are labradors.

# Question:
Which one of the following statements CANNOT be true?

# Options:
A) A female greyhound wins the second place ribbon.
B) A female labrador wins the second place ribbon.
C) A female labrador wins the third place ribbon.
D) A male greyhound wins the fourth place ribbon.
E) A female greyhound wins the fourth place ribbon.","# Declarations
dogs = EnumSort([P, Q, R, S, T, U])
dog_types = EnumSort([greyhound, labrador])
genders = EnumSort([male, female])
places = EnumSort([first, second, third, fourth])
type_of = Function([dogs] -> [dog_types])
gender_of = Function([dogs] -> [genders])
place_of = Function([dogs] -> [places])
# Constraints
ForAll([d:dogs], Or(type_of(d) == greyhound, type_of(d) == labrador)) ::: Each dog is either a greyhound or a labrador, but not both.
Count([d:dogs], gender_of(d) == female) == 2 ::: Two of the six dogs are female and four are male.
Exists([d:dogs], And(gender_of(d) == female, type_of(d) == labrador)) ::: The judge awards ribbons to both female dogs, exactly one of which is a labrador.
Exists([d:dogs], type_of(d) == labrador) ::: Exactly one labrador wins a ribbon.
place_of(P) != fourth ::: Dogs P and R place ahead of dog S.
place_of(R) != fourth ::: Dogs P and R place ahead of dog S.
place_of(S) != first ::: Dogs P and R place ahead of dog S.
place_of(S) != second ::: Dogs P and R place ahead of dog S.
place_of(Q) != first ::: Dog S places ahead of dogs Q and T.
place_of(Q) != second ::: Dog S places ahead of dogs Q and T.
place_of(T) != first ::: Dog S places ahead of dogs Q and T.
place_of(T) != second ::: Dog S places ahead of dogs Q and T.
type_of(P) == greyhound ::: Dogs P and R are greyhounds.
type_of(R) == greyhound ::: Dogs P and R are greyhounds.
type_of(S) == labrador ::: Dogs S and U are labradors.
type_of(U) == labrador ::: Dogs S and U are labradors.
# Options
is_unsat(Exists([d:dogs], And(gender_of(d) == female, type_of(d) == greyhound, place_of(d) == second))) ::: (A)
is_unsat(Exists([d:dogs], And(gender_of(d) == female, type_of(d) == labrador, place_of(d) == second))) ::: (B)
is_unsat(Exists([d:dogs], And(gender_of(d) == female, type_of(d) == labrador, place_of(d) == third))) ::: (C)
is_unsat(Exists([d:dogs], And(gender_of(d) == male, type_of(d) == greyhound, place_of(d) == fourth))) ::: (D)
is_unsat(Exists([d:dogs], And(gender_of(d) == female, type_of(d) == greyhound, place_of(d) == fourth))) ::: (E)"
"# Context:
J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.

# Question:
If one segment of the path directly connects chalets K and O, then which one of the following statements could be true?

# Options:
A) Chalet J is directly connected to chalet M.
B) Chalet K is directly connected to chalet N.
C) Chalet L is directly connected to chalet O.
D) Chalet L is directly connected to exactly two chalets.
E) Chalet O is directly connected to exactly one chalet.","# Declarations
chalets = EnumSort([J, K, L, M, N, O])
path_segment = Function([chalets, chalets] -> [bool])
# Constraints
ForAll([c1:chalets, c2:chalets], path_segment(c1, c2) == path_segment(c2, c1)) ::: The path is composed of five straight segments, each of which directly connects exactly two of the chalets.
ForAll([c:chalets], Exists([c1:chalets, c2:chalets], And(path_segment(c, c1), path_segment(c, c2), c1 != c2))) ::: Each chalet is directly connected by a segment of the path to another chalet.
ForAll([c:chalets], Count([c1:chalets], path_segment(c, c1)) <= 2) ::: No chalet is directly connected by segments of the path to more than two other chalets.
path_segment(J, N) ::: One segment of the path directly connects chalets J and N.
path_segment(K, L) ::: Another segment directly connects chalets K and L.
path_segment(K, O) ::: One segment of the path directly connects chalets K and O.
# Options
is_valid(path_segment(J, M)) ::: (A) Chalet J is directly connected to chalet M.
is_valid(path_segment(K, N)) ::: (B) Chalet K is directly connected to chalet N.
is_valid(path_segment(L, O)) ::: (C) Chalet L is directly connected to chalet O.
is_valid(Count([c:chalets], path_segment(L, c)) == 2) ::: (D) Chalet L is directly connected to exactly two chalets.
is_valid(Count([c:chalets], path_segment(O, c)) == 1) ::: (E) Chalet O is directly connected to exactly one chalet."
"# Context:
A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.

# Question:
The salary rankings of each of the nine partners could be completely determined if which one of the following statements were true?

# Options:
A) Lopez's salary is greater than Fox's.
B) Lopez's salary is greater than Inman's.
C) Nassar's salary is greater than Fox's.
D) Nassar's salary is greater than Inman's.
E) Nassar's salary is greater than Malloy's.","# Declarations
partners = EnumSort([Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, Nassar])
salary = Function([partners] -> [int])
# Constraints
salary(Kohn) > salary(Inman) ::: Kohn's salary is greater than both Inman's and Lopez's.
salary(Kohn) > salary(Lopez) ::: Kohn's salary is greater than both Inman's and Lopez's.
salary(Lopez) > salary(Nassar) ::: Lopez's salary is greater than Nassar's.
salary(Inman) > salary(Fox) ::: Inman's salary is greater than Fox's.
salary(Fox) > salary(Malloy) ::: Fox's salary is greater than Malloy's.
salary(Malloy) > salary(Glassen) ::: Malloy's salary is greater than Glassen's.
salary(Glassen) > salary(Jacoby) ::: Glassen's salary is greater than Jacoby's.
salary(Jacoby) > salary(Hae) ::: Jacoby's salary is greater than Hae's.
# Options
is_valid(salary(Lopez) > salary(Fox)) ::: (A) Lopez's salary is greater than Fox's.
is_valid(salary(Lopez) > salary(Inman)) ::: (B) Lopez's salary is greater than Inman's.
is_valid(salary(Nassar) > salary(Fox)) ::: (C) Nassar's salary is greater than Fox's.
is_valid(salary(Nassar) > salary(Inman)) ::: (D) Nassar's salary is greater than Inman's.
is_valid(salary(Nassar) > salary(Malloy)) ::: (E) Nassar's salary is greater than Malloy's."
"# Context:
A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.

# Question:
What is the minimum number of different salaries earned by the nine partners of the firm?

# Options:
A) 5
B) 6
C) 7
D) 8
E) 9","# Declarations
partners = EnumSort([Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, Nassar])
salary = Function([partners] -> [int])
# Constraints
ForAll([p1:partners, p2:partners], Implies(p1 != p2, salary(p1) != salary(p2))) ::: Each partner has a unique salary.
salary(Kohn) > salary(Inman) ::: Kohn's salary is greater than Inman's.
salary(Kohn) > salary(Lopez) ::: Kohn's salary is greater than Lopez's.
salary(Lopez) > salary(Nassar) ::: Lopez's salary is greater than Nassar's.
salary(Inman) > salary(Fox) ::: Inman's salary is greater than Fox's.
salary(Fox) > salary(Malloy) ::: Fox's salary is greater than Malloy's.
salary(Malloy) > salary(Glassen) ::: Malloy's salary is greater than Glassen's.
salary(Glassen) > salary(Jacoby) ::: Glassen's salary is greater than Jacoby's.
salary(Jacoby) > salary(Hae) ::: Jacoby's salary is greater than Hae's.
# Options
is_valid(Count([p:partners], True) == 5) ::: (A)
is_valid(Count([p:partners], True) == 6) ::: (B)
is_valid(Count([p:partners], True) == 7) ::: (C)
is_valid(Count([p:partners], True) == 8) ::: (D)
is_valid(Count([p:partners], True) == 9) ::: (E)"
"# Context:
J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.

# Question:
Which one of the following chalets cannot be directly connected by segments of the path to exactly two other chalets?

# Options:
A) K
B) L
C) M
D) N
E) O","# Declarations
chalets = EnumSort([J, K, L, M, N, O])
connected = Function([chalets, chalets] -> [bool])
# Constraints
ForAll([c:chalets], Count([c1:chalets], connected(c, c1)) == 2) ::: Each chalet is directly connected by a segment of the path to exactly two other chalets.
connected(J, N) ::: One segment of the path directly connects chalets J and N.
connected(K, L) ::: Another segment directly connects chalets K and L.
ForAll([c1:chalets, c2:chalets], Implies(And(c1 == J, c2 == M), Not(connected(c1, c2)))) ::: J is directly opposite M.
ForAll([c1:chalets, c2:chalets], Implies(And(c1 == K, c2 == N), Not(connected(c1, c2)))) ::: K is directly opposite N.
ForAll([c1:chalets, c2:chalets], Implies(And(c1 == L, c2 == O), Not(connected(c1, c2)))) ::: L is directly opposite O.
# Options
is_unsat(ForAll([c1:chalets, c2:chalets], And(connected(K, c1), connected(K, c2), c1 != c2, Count([c3:chalets], connected(K, c3)) == 2))) ::: (A) K
is_unsat(ForAll([c1:chalets, c2:chalets], And(connected(L, c1), connected(L, c2), c1 != c2, Count([c3:chalets], connected(L, c3)) == 2))) ::: (B) L
is_unsat(ForAll([c1:chalets, c2:chalets], And(connected(M, c1), connected(M, c2), c1 != c2, Count([c3:chalets], connected(M, c3)) == 2))) ::: (C) M
is_unsat(ForAll([c1:chalets, c2:chalets], And(connected(N, c1), connected(N, c2), c1 != c2, Count([c3:chalets], connected(N, c3)) == 2))) ::: (D) N
is_unsat(ForAll([c1:chalets, c2:chalets], And(connected(O, c1), connected(O, c2), c1 != c2, Count([c3:chalets], connected(O, c3)) == 2))) ::: (E) O"
"# Context:
Hannah spends 14 days, exclusive of travel time, in a total of six cities. Each city she visits is in one of three countries—X, Y, or Z. Each of the three countries has many cities. Hannah visits at least one city in each of the three countries. She spends at least two days in each city she visits. She spends only whole days in any city.

# Question:
If Hannah visits a combined total of four cities in countries X and Y, what is the greatest total number of days she can spend visiting cities in country Y?

# Options:
A) 6
B) 7
C) 8
D) 9
E) 10","# Declarations
cities = EnumSort([City1, City2, City3, City4, City5, City6])
countries = EnumSort([X, Y, Z])
days = EnumSort([Day1, Day2, Day3, Day4, Day5, Day6, Day7, Day8, Day9, Day10, Day11, Day12, Day13, Day14])
visit = Function([cities] -> [countries])
spend = Function([cities] -> [days])
# Constraints
ForAll([c:cities], Count([d:days], spend(c) == d) >= 2) ::: Hannah spends at least two days in each city she visits.
Count([c:cities], visit(c) == X) + Count([c:cities], visit(c) == Y) == 4 ::: Hannah visits a combined total of four cities in countries X and Y.
Count([c:cities], visit(c) == X) >= 1 ::: Hannah visits at least one city in each of the three countries.
Count([c:cities], visit(c) == Y) >= 1 ::: Hannah visits at least one city in each of the three countries.
Count([c:cities], visit(c) == Z) >= 1 ::: Hannah visits at least one city in each of the three countries.
Count([d:days], Exists([c:cities], spend(c) == d)) == 14 ::: Hannah spends 14 days, exclusive of travel time, in a total of six cities.
# Options
is_sat(Count([d:days], Exists([c:cities], And(visit(c) == Y, spend(c) == d))) == 6) ::: (A)
is_sat(Count([d:days], Exists([c:cities], And(visit(c) == Y, spend(c) == d))) == 7) ::: (B)
is_sat(Count([d:days], Exists([c:cities], And(visit(c) == Y, spend(c) == d))) == 8) ::: (C)
is_sat(Count([d:days], Exists([c:cities], And(visit(c) == Y, spend(c) == d))) == 9) ::: (D)
is_sat(Count([d:days], Exists([c:cities], And(visit(c) == Y, spend(c) == d))) == 10) ::: (E)"
"# Context:
There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.

# Question:
Which one of the following families CANNOT live next to the Kahns?

# Options:
A) the Lowes
B) the Newmans
C) the Owens
D) the Piatts
E) the Rutans","# Declarations
houses = EnumSort([house1, house2, house3, house4, house5, house6, house7])
families = EnumSort([Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans])
occupies = Function([houses] -> [families])
# Constraints
ForAll([h:houses], Exists([f:families], occupies(h) == f)) ::: Each house is occupied by exactly one of seven families.
occupies(house1) != Rutans ::: The Rutans do not live in the first house on the street.
occupies(house7) != Rutans ::: The Rutans do not live in the last house on the street.
occupies(house4) == Kahns ::: The Kahns live in the fourth house from the west end of the street.
Or(occupies(house3) == Muirs, occupies(house5) == Muirs) ::: The Muirs live next to the Kahns.
And(occupies(house5) != Piatts, occupies(house6) != Piatts, occupies(house7) != Piatts) ::: The Piatts live east of both the Kahns and the Muirs but west of the Lowes.
# Options
is_unsat(occupies(house3) == Lowes) ::: (A) the Lowes
is_unsat(occupies(house3) == Newmans) ::: (B) the Newmans
is_unsat(occupies(house3) == Owens) ::: (C) the Owens
is_unsat(occupies(house3) == Piatts) ::: (D) the Piatts
is_unsat(occupies(house3) == Rutans) ::: (E) the Rutans"
"# Context:
A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.

# Question:
If Malloy and Nassar earn the same salary, at least how many of the partners must have lower salaries than Lopez?

# Options:
A) 3
B) 4
C) 5
D) 6
E) 7","# Declarations
partners = EnumSort([Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, Nassar])
salary = Function([partners] -> [int])
# Constraints
salary(Kohn) > salary(Inman) ::: Kohn's salary is greater than both Inman's and Lopez's.
salary(Kohn) > salary(Lopez) ::: Kohn's salary is greater than both Inman's and Lopez's.
salary(Lopez) > salary(Nassar) ::: Lopez's salary is greater than Nassar's.
salary(Inman) > salary(Fox) ::: Inman's salary is greater than Fox's.
salary(Fox) > salary(Malloy) ::: Fox's salary is greater than Malloy's.
salary(Malloy) > salary(Glassen) ::: Malloy's salary is greater than Glassen's.
salary(Glassen) > salary(Jacoby) ::: Glassen's salary is greater than Jacoby's.
salary(Jacoby) > salary(Hae) ::: Jacoby's salary is greater than Hae's.
salary(Malloy) == salary(Nassar) ::: If Malloy and Nassar earn the same salary.
# Options
is_valid(Count([p:partners], salary(p) < salary(Lopez)) >= 3) ::: (A)
is_valid(Count([p:partners], salary(p) < salary(Lopez)) >= 4) ::: (B)
is_valid(Count([p:partners], salary(p) < salary(Lopez)) >= 5) ::: (C)
is_valid(Count([p:partners], salary(p) < salary(Lopez)) >= 6) ::: (D)
is_valid(Count([p:partners], salary(p) < salary(Lopez)) >= 7) ::: (E)"